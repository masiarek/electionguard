{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is ElectionGuard? ElectionGuard is an open source software development kit (SDK) that makes voting more secure, transparent and accessible. It is designed for election system vendors to incorporate end-to-end verifiability into their systems and any interested organization to perform and publish post-election audits . New to ElectionGuard? Welcome! Thanks for your interest. Trying to figure out how to help and learn? If you're a developer, head over to the developer getting started . If you're an election administrator or want to learn more about ElectionGuard and its underpinnings, start with the guide . If you want to help and aren't a developer, all kinds of help with documentation, outreach, and advocacy is welcomed. Follow discussions , join the office hours , and check out the roadmap to see where it's intended to go. Open-Source This library and all linked ElectionGuard projects, are licensed under the MIT license. There is no fee for using ElectionGuard. Security Issues Reporting We encourage the developer and security community to conduct research, report issues, and suggest improvements on this code base. However, unlike performance or feature bugs, please do not report security vulnerabilities in public Github comments. Each repository has a SECURITY file with instructions on responsibly reporting security vulnerabilities under Microsoft's CVD process. Contributing Help defend democracy and contribute to the project . We welcome discussions on our discussions page , feel free to check in and ask your questions and drop your suggestions regarding the specifications over there. Questions ElectionGuard would love for you to ask questions out in the open using Github Issues. If you really want to email the ElectionGuard team, reach out at electionguard@microsoft.com . Thank you A huge thank you to those who have helped us along the way: Josh Benaloh (whose PhD thesis was the genesis of much of this work) Our contributors and community InfernoRed Technology VotingWorks Center for Civic Design Oxide Design Many teams within Microsoft","title":"What is ElectionGuard?"},{"location":"#_1","text":"","title":""},{"location":"#what-is-electionguard","text":"ElectionGuard is an open source software development kit (SDK) that makes voting more secure, transparent and accessible. It is designed for election system vendors to incorporate end-to-end verifiability into their systems and any interested organization to perform and publish post-election audits . New to ElectionGuard? Welcome! Thanks for your interest. Trying to figure out how to help and learn? If you're a developer, head over to the developer getting started . If you're an election administrator or want to learn more about ElectionGuard and its underpinnings, start with the guide . If you want to help and aren't a developer, all kinds of help with documentation, outreach, and advocacy is welcomed. Follow discussions , join the office hours , and check out the roadmap to see where it's intended to go.","title":"What is ElectionGuard?"},{"location":"#open-source","text":"This library and all linked ElectionGuard projects, are licensed under the MIT license. There is no fee for using ElectionGuard.","title":"Open-Source"},{"location":"#security-issues-reporting","text":"We encourage the developer and security community to conduct research, report issues, and suggest improvements on this code base. However, unlike performance or feature bugs, please do not report security vulnerabilities in public Github comments. Each repository has a SECURITY file with instructions on responsibly reporting security vulnerabilities under Microsoft's CVD process.","title":"Security Issues Reporting"},{"location":"#contributing","text":"Help defend democracy and contribute to the project . We welcome discussions on our discussions page , feel free to check in and ask your questions and drop your suggestions regarding the specifications over there.","title":"Contributing"},{"location":"#questions","text":"ElectionGuard would love for you to ask questions out in the open using Github Issues. If you really want to email the ElectionGuard team, reach out at electionguard@microsoft.com .","title":"Questions"},{"location":"#thank-you","text":"A huge thank you to those who have helped us along the way: Josh Benaloh (whose PhD thesis was the genesis of much of this work) Our contributors and community InfernoRed Technology VotingWorks Center for Civic Design Oxide Design Many teams within Microsoft","title":"Thank you"},{"location":"basics/Introduction/","text":"Introduction Work in Progress This is a work in progress. Feel free to contribute.","title":"Introduction"},{"location":"basics/Introduction/#introduction","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Introduction"},{"location":"basics/steps/0_Configure_Election/","text":"Configure Election Manifest An election in ElectionGuard is defined as a set of metadata and cryptographic artifacts necessary to encrypt, conduct, tally, decrypt, and verify an election. The Data format used for election metadata is based on the NIST Election Common Standard Data Specification but includes some modifications to support the end-to-end cryptography of ElectionGuard. Election metadata is described in a specific format parseable into an Election Manifest and its validity is checked to ensure that it is of an appropriate structure to conduct an End-to-End Verified ElectionGuard Election. ElectionGuard only verifies the components of the election metadata that are necessary to encrypt and decrypt the election. Some components of the election metadata are not checked for structural validity, but are used when generating a hash representation of the Election Manifest. Additionally, a context is created during the Key Ceremony that includes the cryptographic artifacts necessary for encrypting ballots. Guardians A core component of the ElectionGuard security architecture involves election guardians. Election guardians are trustworthy, independent individuals that participate in the key and tally ceremonies of ElectionGuard e2e-v elections. By using multiple guardians to conduct the tally process, no one person controls all the keys necessary to decrypt ballots. However, with multiple actors it becomes necessary to compensate for guardians going missing or obstructing the tally process by supporting quorums and dispute resolution when a guardian challenges a result, as they are allowed. As such, it is necessary when setting up an election to specify the maximum number of guardians that can participate, but also the quorum, the minimum number of guardians necessary to perform a tally. The more guardians that are allowed, the higher the quorum can (and should) be set (a high number of guardians with a low quorum creates an opportunity for collusion among guardians). It is advised to set quorums not just above majority levels but as high as can be reasonably expected (e.g. set a quorum of 5 or 6, not 4, for an election with 7 guardians).","title":"Configure Election"},{"location":"basics/steps/0_Configure_Election/#configure-election","text":"","title":"Configure Election"},{"location":"basics/steps/0_Configure_Election/#manifest","text":"An election in ElectionGuard is defined as a set of metadata and cryptographic artifacts necessary to encrypt, conduct, tally, decrypt, and verify an election. The Data format used for election metadata is based on the NIST Election Common Standard Data Specification but includes some modifications to support the end-to-end cryptography of ElectionGuard. Election metadata is described in a specific format parseable into an Election Manifest and its validity is checked to ensure that it is of an appropriate structure to conduct an End-to-End Verified ElectionGuard Election. ElectionGuard only verifies the components of the election metadata that are necessary to encrypt and decrypt the election. Some components of the election metadata are not checked for structural validity, but are used when generating a hash representation of the Election Manifest. Additionally, a context is created during the Key Ceremony that includes the cryptographic artifacts necessary for encrypting ballots.","title":"Manifest"},{"location":"basics/steps/0_Configure_Election/#guardians","text":"A core component of the ElectionGuard security architecture involves election guardians. Election guardians are trustworthy, independent individuals that participate in the key and tally ceremonies of ElectionGuard e2e-v elections. By using multiple guardians to conduct the tally process, no one person controls all the keys necessary to decrypt ballots. However, with multiple actors it becomes necessary to compensate for guardians going missing or obstructing the tally process by supporting quorums and dispute resolution when a guardian challenges a result, as they are allowed. As such, it is necessary when setting up an election to specify the maximum number of guardians that can participate, but also the quorum, the minimum number of guardians necessary to perform a tally. The more guardians that are allowed, the higher the quorum can (and should) be set (a high number of guardians with a low quorum creates an opportunity for collusion among guardians). It is advised to set quorums not just above majority levels but as high as can be reasonably expected (e.g. set a quorum of 5 or 6, not 4, for an election with 7 guardians).","title":"Guardians"},{"location":"basics/steps/1_Key_Ceremony/","text":"Key Ceremony The ElectionGuard Key Ceremony is the process used by Election Officials to share encryption keys for an election. Before an election, a fixed number of Guardians are selected to hold the private keys needed to decrypt the election results. A Quorum count of Guardians can also be specified to compensate for guardians who may be missing at the time of Decryption. For instance, 5 Guardians may be selected to hold the keys, but only 3 of them are required to decrypt the election results. Guardians are typically Election Officials, Trustees Canvass Board Members, Government Officials or other trusted authorities who are responsible and accountable for conducting the election. Summary The Key Ceremony is broken into several high-level steps. Each Guardian must announce their attendance in the key ceremony, generate their own public-private key pairs, and then share those key pairs with the Quorum. Then the data that is shared is mathematically verified using Non-Interactive Zero Knowledge Proofs, and finally a joint public key is created to encrypt ballots in the election. Attendance Guardians exchange all public keys and ensure each fellow guardian has received an election and auxiliary public key ensuring that all guardians are in attendance. Key Sharing Guardians generate a partial key backup for each guardian and share with that designated key with that guardian. Then each designated guardian sends a verification back to the sender. The sender then publishes to the group when all verifications are received. Joint Key The final step is to publish the joint election key after all keys and backups have been shared.","title":"Key Ceremony"},{"location":"basics/steps/1_Key_Ceremony/#key-ceremony","text":"The ElectionGuard Key Ceremony is the process used by Election Officials to share encryption keys for an election. Before an election, a fixed number of Guardians are selected to hold the private keys needed to decrypt the election results. A Quorum count of Guardians can also be specified to compensate for guardians who may be missing at the time of Decryption. For instance, 5 Guardians may be selected to hold the keys, but only 3 of them are required to decrypt the election results. Guardians are typically Election Officials, Trustees Canvass Board Members, Government Officials or other trusted authorities who are responsible and accountable for conducting the election.","title":"Key Ceremony"},{"location":"basics/steps/1_Key_Ceremony/#summary","text":"The Key Ceremony is broken into several high-level steps. Each Guardian must announce their attendance in the key ceremony, generate their own public-private key pairs, and then share those key pairs with the Quorum. Then the data that is shared is mathematically verified using Non-Interactive Zero Knowledge Proofs, and finally a joint public key is created to encrypt ballots in the election.","title":"Summary"},{"location":"basics/steps/1_Key_Ceremony/#attendance","text":"Guardians exchange all public keys and ensure each fellow guardian has received an election and auxiliary public key ensuring that all guardians are in attendance.","title":"Attendance"},{"location":"basics/steps/1_Key_Ceremony/#key-sharing","text":"Guardians generate a partial key backup for each guardian and share with that designated key with that guardian. Then each designated guardian sends a verification back to the sender. The sender then publishes to the group when all verifications are received.","title":"Key Sharing"},{"location":"basics/steps/1_Key_Ceremony/#joint-key","text":"The final step is to publish the joint election key after all keys and backups have been shared.","title":"Joint Key"},{"location":"basics/steps/2_Encryption/","text":"Encryption The primary function of ElectionGuard is to encrypt ballots. Ballots are encrypted on a uniquely identified device within the context of a specific election. The election public key is used to encrypt ballots. A master nonce value is generated for each ballot and the nonce is used to derive other nonce values for encrypting the selection on each ballot.","title":"Encryption"},{"location":"basics/steps/2_Encryption/#encryption","text":"The primary function of ElectionGuard is to encrypt ballots. Ballots are encrypted on a uniquely identified device within the context of a specific election. The election public key is used to encrypt ballots. A master nonce value is generated for each ballot and the nonce is used to derive other nonce values for encrypting the selection on each ballot.","title":"Encryption"},{"location":"basics/steps/3_Cast_and_Challenge/","text":"Cast and Challenge Each ballot that is completed by a voter must be either cast or challenged. A cast ballot is a ballot that the voter accepts as valid and wishes to include in the official election tally. A challenge ballot, also referred to as a spoiled ballot, is a ballot that the voter does not accept as valid and wishes to exclude from the official election tally. ElectionGuard includes a mechanism to mark a specific ballot as either cast or spoiled. Cast ballots are included in the tally record, while spoiled ballots are not. Spoiled ballots are decrypted into plaintext and published along with the rest of the election record.","title":"Cast and Challenge"},{"location":"basics/steps/3_Cast_and_Challenge/#cast-and-challenge","text":"Each ballot that is completed by a voter must be either cast or challenged. A cast ballot is a ballot that the voter accepts as valid and wishes to include in the official election tally. A challenge ballot, also referred to as a spoiled ballot, is a ballot that the voter does not accept as valid and wishes to exclude from the official election tally. ElectionGuard includes a mechanism to mark a specific ballot as either cast or spoiled. Cast ballots are included in the tally record, while spoiled ballots are not. Spoiled ballots are decrypted into plaintext and published along with the rest of the election record.","title":"Cast and Challenge"},{"location":"basics/steps/4_Decryption/","text":"Decryption At the conclusion of voting, all of the cast ballots are published in their encrypted form in the election record together with the proofs that the ballots are well-formed. Additionally, all of the encryptions of each option are homomorphically-combined to form an encryption of the total number of times that each option was selected. The homomorphically-combined encryptions are decrypted to generate the election tally. Individual cast ballots are not decrypted. Individual spoiled ballots are decrypted and the plaintext values are published along with the encrypted representations and the proofs. In order to decrypt the homomorphically-combined encryption of each selection, each Guardian participating in the decryption must compute a specific Decryption Share of the decryption. It is preferable that all guardians be present for decryption, however in the event that guardians cannot be present, ElectionGuard includes a mechanism to decrypt with the Quorum of Guardians. During the Key Ceremony a Quorum of Guardians is defined that represents the minimum number of guardians that must be present to decrypt the election. If the decryption is to proceed with a Quorum of Guardians greater than or equal to the Quorum count, but less than the total number of guardians, then a subset of the Available Guardians must also each construct a Partial Decryption Share for the missing Missing Guardian, in addition to providing their own Decryption Share. It is important to note that mathematically not every present guardian has to compute a Partial Decryption Share for every Missing Guardian. Only the Quorum Count of guardians are necessary to construct Partial Decryption Shares in order to compensate for any Missing Guardian. In this implementation, ElectionGuard takes an approach that utilizes all Available Guardians to compensate for Missing Guardians. When it is determined that guardians are missing, all available guardians each calculate a Partial Decryption Share for the missing guardian and publish the result. A Quorum of Guardians count of available Partial Decryption Shares is randomly selected from the pool of available partial decryption shares for a givenMissing Guardian. If more than one guardian is missing, we randomly choose to ignore the Partial Decryption Share provided by one of the Available Guardians whose partial decryption share was chosen for the previous Missing Guardian, and randomly select again from the pool of available Partial Decryption Shares. This ensures that all available guardians have the opportunity to participate in compensating for Missing Guardians.","title":"Decryption"},{"location":"basics/steps/4_Decryption/#decryption","text":"At the conclusion of voting, all of the cast ballots are published in their encrypted form in the election record together with the proofs that the ballots are well-formed. Additionally, all of the encryptions of each option are homomorphically-combined to form an encryption of the total number of times that each option was selected. The homomorphically-combined encryptions are decrypted to generate the election tally. Individual cast ballots are not decrypted. Individual spoiled ballots are decrypted and the plaintext values are published along with the encrypted representations and the proofs. In order to decrypt the homomorphically-combined encryption of each selection, each Guardian participating in the decryption must compute a specific Decryption Share of the decryption. It is preferable that all guardians be present for decryption, however in the event that guardians cannot be present, ElectionGuard includes a mechanism to decrypt with the Quorum of Guardians. During the Key Ceremony a Quorum of Guardians is defined that represents the minimum number of guardians that must be present to decrypt the election. If the decryption is to proceed with a Quorum of Guardians greater than or equal to the Quorum count, but less than the total number of guardians, then a subset of the Available Guardians must also each construct a Partial Decryption Share for the missing Missing Guardian, in addition to providing their own Decryption Share. It is important to note that mathematically not every present guardian has to compute a Partial Decryption Share for every Missing Guardian. Only the Quorum Count of guardians are necessary to construct Partial Decryption Shares in order to compensate for any Missing Guardian. In this implementation, ElectionGuard takes an approach that utilizes all Available Guardians to compensate for Missing Guardians. When it is determined that guardians are missing, all available guardians each calculate a Partial Decryption Share for the missing guardian and publish the result. A Quorum of Guardians count of available Partial Decryption Shares is randomly selected from the pool of available partial decryption shares for a givenMissing Guardian. If more than one guardian is missing, we randomly choose to ignore the Partial Decryption Share provided by one of the Available Guardians whose partial decryption share was chosen for the previous Missing Guardian, and randomly select again from the pool of available Partial Decryption Shares. This ensures that all available guardians have the opportunity to participate in compensating for Missing Guardians.","title":"Decryption"},{"location":"basics/steps/5_Publish_Record/","text":"Publish Record Publishing the election record helps ensure third parties can verify the election. publish.py provides a publish method that serializes the key election files. This makes use of the Serializable class exists to allow easy serializing to JSON files. These JSON files can then be shared and sent so others can verify.","title":"Publish Record"},{"location":"basics/steps/5_Publish_Record/#publish-record","text":"Publishing the election record helps ensure third parties can verify the election. publish.py provides a publish method that serializes the key election files. This makes use of the Serializable class exists to allow easy serializing to JSON files. These JSON files can then be shared and sent so others can verify.","title":"Publish Record"},{"location":"basics/steps/6_Verification/","text":"Verification Deserializing is the first step to verification. The from_json and from_json_file methods on Serializable are available to deserialize output JSON files back into their original classes.","title":"Verification"},{"location":"basics/steps/6_Verification/#verification","text":"Deserializing is the first step to verification. The from_json and from_json_file methods on Serializable are available to deserialize output JSON files back into their original classes.","title":"Verification"},{"location":"concepts/Homomorphic_Aggregation/","text":"Homomorphic Aggregation Work in Progress This is a work in progress. Feel free to contribute.","title":"Aggregation"},{"location":"concepts/Homomorphic_Aggregation/#homomorphic-aggregation","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Homomorphic Aggregation"},{"location":"concepts/Homomorphic_Encryption/","text":"Homomorphic Aggregation Work in Progress This is a work in progress. Feel free to contribute.","title":"Encryption"},{"location":"concepts/Homomorphic_Encryption/#homomorphic-aggregation","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Homomorphic Aggregation"},{"location":"concepts/Manifest_Building/","text":"Election Manifest There are many types of elections. We need a base set of data that shows how these different types of elections are handled in an ElectionGuard end-to-end verifiable election (or ballot comparison audits). We worked with InfernoRed, VotingWorks, and Dan Wallach of Rice University (thanks folks!) to develop a set of conventions, tests, and sample data (based on a starting dataset sample from the Center for Civic Design) that demonstrate how to encode the information necessary to conduct an election into a format that ElectionGuard can use. The election terms and structure are based whenever possible on the NIST SP-1500-100 Election Results Common Data Format Specification ( PDF ) and the Civics Common Standard Data Specification . The information captured by the NIST standard is codified into an election manifest that defines common elements when conducting an election, such as locations, candidates, parties, contests, and ballot styles. ElectionGuard uses the data contained in the Election Manifest to associate ballots with specific ballot styles and to verify the accuracy of data at different stages of the election process. Note that not all of the data contained in the Election Manifest impacts the computations of tallies and zero-knowledge proofs used in the published election data that demonstrates end-to-end verifiability; however it is important to include as much data as possible in order to distinguish one election from another. With a well-defined Election Manifest, improperly formatted ballot encryption requests will fail with error messages at the moment of initial encryption; the enforcement of any logic or behavior to prevent overvoting or other malformed ballot submissions are handled by the encrypting device, not ElectionGuard. In addition, since json files do not accommodate comments, all notations and exceptions are documented in this readme. Election Data Structure Elections are characterized into types by NIST as shown in the table below: election type description general For an election held typically on the national day for elections. partisan-primary-closed For a primary election that is for a specific party where voter eligibility is based on registration. partisan-primary-open For a primary election that is for a specific party where voter declares desired party or chooses in private. primary For a primary election without a specified type, such as a nonpartisan primary. runoff For an election to decide a prior contest that ended with no candidate receiving a majority of the votes. special For an election held out of sequence for special circumstances, for example, to fill a vacated office. other Used when the election type is not listed in this enumeration. If used, include a specific value of the OtherType element. We present two sample manifests: general and partisan-primary-closed . The core distinction between the two samples is the role of party: in general elections, voters can choose to vote for candidates from any party in a contest, regardless of party affiliation. In partisan primaries, voters can only vote in contests germane to their party declaration or affiliation. As such, special , runoff , and primary election types will follow the general pattern, and partisan-primary-open will follow the partisan-primary-closed pattern. Open primary elections can follow either pattern as determined by their governing rules and regulations. (As noted above, ElectionGuard expects properly-formed ballots; e.g., it would error and fail to encrypt a ballot in an open-primary-closed election if a contest with an incorrect party affiliation were submitted (as indicated by the ).) Ballot Styles and Geography At least in the United States, many complications are introduced by voting simultaneously on election contests that apply in specific geographies and jurisdictions. For example, a single election could include contests for congress, state assembly, school, and utility districts, each with their own geographic boundaries, many that do not respect town or county lines. The ElectionGuard Election Manifest data format is flexible to accommodate most situations, but it is usually up to the election commission and the external system to determine what each component of the manifest actually means. In the following examples, we will work through the process of defining different election types at a high level and describe the process of building the election manifest. Geographic and Ballot Style Breakdown Each election can be thought of as a list of contests that are relevant to a certain group of people in a specific place. In order to determine who is supposed to vote on which contests, we first need to define the geographic jurisdictions where the election is taking place. The NIST Guidelines present an excellent discussion of the geographic interplay of different contests. The diagram from page 12 is presented below. As the diagram shows, congressional, state assembly, school district and other geographic boundaries project onto towns and municipalities in different ways. Elections manage this complexity by creating unique ballot styles that present to voters only the contests that pertain to them. Different jurisdictions use terms such as wards, precincts, and districts to describe the areas of overlap that guide ballot style creation. We will use precinct but ward and district could be used instead. Contests, Candidates and Parties In most cases, a resident of a specific precinct or location will expect to see a certain list of contests that are relevant to them. A contest is a specific collection of available choices ( selections ) from which the voter may choose some subset. For the ElectionGuard Election Manifest, each possible selection in a contest must be associated with a candidate, even for Referendum-style contests. If a contest also supports write-in values, then a write-in candidate is also defined. Candidates may also be associated with specific parties, but this is not required for all election types. Introducing Hamilton County, OZ To help disambiguate, let's explore an example. Geographic Jurisdictions Hamilton County includes 3 townships: LaCroix, Arlington, Harris. The town of LaCroix also has a utility district that comprises its own precinct for special referendums. Arlington has two distinct school districts. The county is also split into two congressional districts, district 5 and district 7. Harris township is entirely within Congressional District 5, but both LaCroix and Arlington are split between congressional districts 5 and 7. ] Building the Geographic Jurisdiction Mapping (Geopolitical Units) The Election Manifest includes an array of objects called geopoliticalUnits (a.k.a. gpUnit ). Each Geopolitical Unit must include the following fields: objectId - a unique identifier for the gpUnit. This value is used to map a contest to a specific jurisdiction name - the friendly name of the gp Unit type - they type of jurisdiction (one of the Reporting Unit Types ) contact information - the contact info for the geopolitical unit Geopolitical units are polygons on a map represented by legal jurisdictions. In our example Election Manifest for hamilton County, there is one geopolitical unit for each jurisdictional boundary in the image above: Hamilton County Congressional District 5 congressional District 7 LaCroix Township Exeter Utility District (within LaCroix Township) Harris Township Arlington Township Pismo Beach School District (within Arlington Township) Somerset School District (within Arlington Township) When defining the geopolitical units for an election, we define all of the possible geopolitical units for an election; even if there are no contests for a specific jurisdiction. This way, if contests are added or removed during the setup phase, you do not also have to remember to update the list of geopolitical units. Alternatively, you can define only the GP Units for which there are contests. The General Election Contests A general election will occur in Hamilton County. The county is voting along with the rest of the province, and the county is responsible for tabulating its own election results. This means that the Election Scope is defined at the county level. For the general election, the following sets of contests (and associated geographic boundaries) obtain: The National Contests - President and Vice President. This contest demonstrates a \"vote for the ticket\" and allows write-ins Province Contests - Governor - this contest demonstrates a long list of candidate names Congressional Contests - Congress Districts 5 and 7 - these contests demonstrate how to split a district using multiple ballot styles Township Contests - Retain Chief Justice - This contest demonstrates a contest that applies to a specific town whose boundaries are split across multiple ballot styles School District Contests - School Board - these contests demonstrate contests with multiple selections ( n-of-m ) and allow write-ins School Board, and Utility district referendum to show ballot style splits Utility District Contest - Utility District - This contest demonstrates a referendum-style contest with long descriptions and display language translation into Spanish Each contest must be associated with exactly ONE electoralDistrictId . The electoralDistrictId field on the contest is populated with the objectId of the associated Geopolitical Unit (e.g. the Contest congress-district-7-contest has the electoralDistrictId congress-district-7 Each contest must also define a sequenceOrder . the sequence order is an indexing mechanism used internally. It is not the sequence that the contests are displayed to the user . The order in which contests are displayed to the user is up to the implementing application. The General Election Ballot Styles A ballot style is the set of contests that a specific voter should see on their ballot for a given location. The ballot style is associated to the set of geopolitical units relevant to a specific point on a map. Since each contest is also associated with a geopolitical unit, a mapping is created between a point on a map and the contests that are relevant to that point. For instance, a voter that lives in the Exeter Utility District should see contests that are relevant to Congressional District 7, LaCroix Township and the Exeter Utility District. | Geopolitical Units are overlapping polygons, and ballot styles are the list of polygons relevant to a specific point on the map. Similar to Geopolitical Units, we define all of the possible ballot styles for an election in our example, even if there are no contests specific to a ballot style. This is subjective and the behavior may be different for the integrating system: Congressional District 7 Outside Any Township Congressional District 7 LaCroix Township Congressional District 7 LaCroix Township Exeter Utility District Congressional District 7 Arlington Township Congressional District 7 Arlington Township Pismo Beach School district Congressional District 7 Arlington Township Somerset School district Congressional District 5 Outside Any Township Congressional District 5 LaCroix Township Congressional District 5 Harris Township Congressional District 5 Arlington Township Pismo Beach School district Congressional District 5 Arlington Township Somerset School district By defining all of the possible ballot styles and all of the possible geopolitical units, we ensure that if a contest is added or removed, we only have to make sure the contest is correct. We do not have to modify the list of geopolitical units or ballot styles. Data Flexibility The relationship between a ballot style and the contests that are displayed on it are subjective to the implementing application. This example is just one way to define this relationship that is purposefully verbose. For instance, in our example we define a geopolitical unit as a set of overlapping polygons, and a ballot style as the intersection of those polygons at a specific point. This is a top-down approach. Alternatively, we could have defined a geopolitical unit as the intersection area of those polygons and mapped one ballot style to each geopolitical unit 1 to 1. for instance, instead of defining a single GP Unit each for: Congressional District 5, Congressional District 7, LaCroix Township, Exeter Utility district, etc; we could have instead defined the GP Units as: Congressional District 5 No Township Congressional District 7 No Township Congressional District 5 inside LaCroix Congressional District 5 Inside LaCroix and Exeter, etc. Then, instead of each Ballot Style having multiple GP Units, each ballot style would have applied to exactly one GP Unit. Data Validation When the election Manifest is loaded into ElectionGuard, its validity is checked semantically against the data format required to conduct an ElectionGuard Election. Specifically, we check that: Each Geopolitical Unit has a unique objectId Each Ballot Style maps to at least one valid Geopolitical Unit Each Party has a unique objectId Each Candidate either does not have a party, or is associated with a valid party Each Contest has a unique Sequence Order Each Contest is associated with exactly one valid Geopolitical Unit Each Contest has a valid number of Selections for the number of seats in the contest Each Selection on each Contest is associated with a valid Candidate as long as the election manifest format matches the validation criteria, the election can proceed as an ElectionGuard election. Frequently Asked Questions Q: What if my ballot styles are not associated with geopolitical units? A: There are a few ways to handle this. In most cases, you can simply map the ballot style 1 to 1 to the geopolitical unit. for instance, if ballot-style-1 includes contest-1 then you may create geopolitical-unit-1 and associate both the ballot style and the contest to that geopolitical unit. This documentation is under review and subject to change. Please do not hesitate to open a github issue if you have questions, or find errors or omissions.","title":"Building"},{"location":"concepts/Manifest_Building/#election-manifest","text":"There are many types of elections. We need a base set of data that shows how these different types of elections are handled in an ElectionGuard end-to-end verifiable election (or ballot comparison audits). We worked with InfernoRed, VotingWorks, and Dan Wallach of Rice University (thanks folks!) to develop a set of conventions, tests, and sample data (based on a starting dataset sample from the Center for Civic Design) that demonstrate how to encode the information necessary to conduct an election into a format that ElectionGuard can use. The election terms and structure are based whenever possible on the NIST SP-1500-100 Election Results Common Data Format Specification ( PDF ) and the Civics Common Standard Data Specification . The information captured by the NIST standard is codified into an election manifest that defines common elements when conducting an election, such as locations, candidates, parties, contests, and ballot styles. ElectionGuard uses the data contained in the Election Manifest to associate ballots with specific ballot styles and to verify the accuracy of data at different stages of the election process. Note that not all of the data contained in the Election Manifest impacts the computations of tallies and zero-knowledge proofs used in the published election data that demonstrates end-to-end verifiability; however it is important to include as much data as possible in order to distinguish one election from another. With a well-defined Election Manifest, improperly formatted ballot encryption requests will fail with error messages at the moment of initial encryption; the enforcement of any logic or behavior to prevent overvoting or other malformed ballot submissions are handled by the encrypting device, not ElectionGuard. In addition, since json files do not accommodate comments, all notations and exceptions are documented in this readme.","title":"Election Manifest"},{"location":"concepts/Manifest_Building/#election-data-structure","text":"Elections are characterized into types by NIST as shown in the table below: election type description general For an election held typically on the national day for elections. partisan-primary-closed For a primary election that is for a specific party where voter eligibility is based on registration. partisan-primary-open For a primary election that is for a specific party where voter declares desired party or chooses in private. primary For a primary election without a specified type, such as a nonpartisan primary. runoff For an election to decide a prior contest that ended with no candidate receiving a majority of the votes. special For an election held out of sequence for special circumstances, for example, to fill a vacated office. other Used when the election type is not listed in this enumeration. If used, include a specific value of the OtherType element. We present two sample manifests: general and partisan-primary-closed . The core distinction between the two samples is the role of party: in general elections, voters can choose to vote for candidates from any party in a contest, regardless of party affiliation. In partisan primaries, voters can only vote in contests germane to their party declaration or affiliation. As such, special , runoff , and primary election types will follow the general pattern, and partisan-primary-open will follow the partisan-primary-closed pattern. Open primary elections can follow either pattern as determined by their governing rules and regulations. (As noted above, ElectionGuard expects properly-formed ballots; e.g., it would error and fail to encrypt a ballot in an open-primary-closed election if a contest with an incorrect party affiliation were submitted (as indicated by the ).)","title":"Election Data Structure"},{"location":"concepts/Manifest_Building/#ballot-styles-and-geography","text":"At least in the United States, many complications are introduced by voting simultaneously on election contests that apply in specific geographies and jurisdictions. For example, a single election could include contests for congress, state assembly, school, and utility districts, each with their own geographic boundaries, many that do not respect town or county lines. The ElectionGuard Election Manifest data format is flexible to accommodate most situations, but it is usually up to the election commission and the external system to determine what each component of the manifest actually means. In the following examples, we will work through the process of defining different election types at a high level and describe the process of building the election manifest.","title":"Ballot Styles and Geography"},{"location":"concepts/Manifest_Building/#geographic-and-ballot-style-breakdown","text":"Each election can be thought of as a list of contests that are relevant to a certain group of people in a specific place. In order to determine who is supposed to vote on which contests, we first need to define the geographic jurisdictions where the election is taking place. The NIST Guidelines present an excellent discussion of the geographic interplay of different contests. The diagram from page 12 is presented below. As the diagram shows, congressional, state assembly, school district and other geographic boundaries project onto towns and municipalities in different ways. Elections manage this complexity by creating unique ballot styles that present to voters only the contests that pertain to them. Different jurisdictions use terms such as wards, precincts, and districts to describe the areas of overlap that guide ballot style creation. We will use precinct but ward and district could be used instead.","title":"Geographic and Ballot Style Breakdown"},{"location":"concepts/Manifest_Building/#contests-candidates-and-parties","text":"In most cases, a resident of a specific precinct or location will expect to see a certain list of contests that are relevant to them. A contest is a specific collection of available choices ( selections ) from which the voter may choose some subset. For the ElectionGuard Election Manifest, each possible selection in a contest must be associated with a candidate, even for Referendum-style contests. If a contest also supports write-in values, then a write-in candidate is also defined. Candidates may also be associated with specific parties, but this is not required for all election types.","title":"Contests, Candidates and Parties"},{"location":"concepts/Manifest_Building/#introducing-hamilton-county-oz","text":"To help disambiguate, let's explore an example.","title":"Introducing Hamilton County, OZ"},{"location":"concepts/Manifest_Building/#geographic-jurisdictions","text":"Hamilton County includes 3 townships: LaCroix, Arlington, Harris. The town of LaCroix also has a utility district that comprises its own precinct for special referendums. Arlington has two distinct school districts. The county is also split into two congressional districts, district 5 and district 7. Harris township is entirely within Congressional District 5, but both LaCroix and Arlington are split between congressional districts 5 and 7. ]","title":"Geographic Jurisdictions"},{"location":"concepts/Manifest_Building/#building-the-geographic-jurisdiction-mapping-geopolitical-units","text":"The Election Manifest includes an array of objects called geopoliticalUnits (a.k.a. gpUnit ). Each Geopolitical Unit must include the following fields: objectId - a unique identifier for the gpUnit. This value is used to map a contest to a specific jurisdiction name - the friendly name of the gp Unit type - they type of jurisdiction (one of the Reporting Unit Types ) contact information - the contact info for the geopolitical unit Geopolitical units are polygons on a map represented by legal jurisdictions. In our example Election Manifest for hamilton County, there is one geopolitical unit for each jurisdictional boundary in the image above: Hamilton County Congressional District 5 congressional District 7 LaCroix Township Exeter Utility District (within LaCroix Township) Harris Township Arlington Township Pismo Beach School District (within Arlington Township) Somerset School District (within Arlington Township) When defining the geopolitical units for an election, we define all of the possible geopolitical units for an election; even if there are no contests for a specific jurisdiction. This way, if contests are added or removed during the setup phase, you do not also have to remember to update the list of geopolitical units. Alternatively, you can define only the GP Units for which there are contests.","title":"Building the Geographic Jurisdiction Mapping (Geopolitical Units)"},{"location":"concepts/Manifest_Building/#the-general-election-contests","text":"A general election will occur in Hamilton County. The county is voting along with the rest of the province, and the county is responsible for tabulating its own election results. This means that the Election Scope is defined at the county level. For the general election, the following sets of contests (and associated geographic boundaries) obtain: The National Contests - President and Vice President. This contest demonstrates a \"vote for the ticket\" and allows write-ins Province Contests - Governor - this contest demonstrates a long list of candidate names Congressional Contests - Congress Districts 5 and 7 - these contests demonstrate how to split a district using multiple ballot styles Township Contests - Retain Chief Justice - This contest demonstrates a contest that applies to a specific town whose boundaries are split across multiple ballot styles School District Contests - School Board - these contests demonstrate contests with multiple selections ( n-of-m ) and allow write-ins School Board, and Utility district referendum to show ballot style splits Utility District Contest - Utility District - This contest demonstrates a referendum-style contest with long descriptions and display language translation into Spanish Each contest must be associated with exactly ONE electoralDistrictId . The electoralDistrictId field on the contest is populated with the objectId of the associated Geopolitical Unit (e.g. the Contest congress-district-7-contest has the electoralDistrictId congress-district-7 Each contest must also define a sequenceOrder . the sequence order is an indexing mechanism used internally. It is not the sequence that the contests are displayed to the user . The order in which contests are displayed to the user is up to the implementing application.","title":"The General Election Contests"},{"location":"concepts/Manifest_Building/#the-general-election-ballot-styles","text":"A ballot style is the set of contests that a specific voter should see on their ballot for a given location. The ballot style is associated to the set of geopolitical units relevant to a specific point on a map. Since each contest is also associated with a geopolitical unit, a mapping is created between a point on a map and the contests that are relevant to that point. For instance, a voter that lives in the Exeter Utility District should see contests that are relevant to Congressional District 7, LaCroix Township and the Exeter Utility District. | Geopolitical Units are overlapping polygons, and ballot styles are the list of polygons relevant to a specific point on the map. Similar to Geopolitical Units, we define all of the possible ballot styles for an election in our example, even if there are no contests specific to a ballot style. This is subjective and the behavior may be different for the integrating system: Congressional District 7 Outside Any Township Congressional District 7 LaCroix Township Congressional District 7 LaCroix Township Exeter Utility District Congressional District 7 Arlington Township Congressional District 7 Arlington Township Pismo Beach School district Congressional District 7 Arlington Township Somerset School district Congressional District 5 Outside Any Township Congressional District 5 LaCroix Township Congressional District 5 Harris Township Congressional District 5 Arlington Township Pismo Beach School district Congressional District 5 Arlington Township Somerset School district By defining all of the possible ballot styles and all of the possible geopolitical units, we ensure that if a contest is added or removed, we only have to make sure the contest is correct. We do not have to modify the list of geopolitical units or ballot styles.","title":"The General Election Ballot Styles"},{"location":"concepts/Manifest_Building/#data-flexibility","text":"The relationship between a ballot style and the contests that are displayed on it are subjective to the implementing application. This example is just one way to define this relationship that is purposefully verbose. For instance, in our example we define a geopolitical unit as a set of overlapping polygons, and a ballot style as the intersection of those polygons at a specific point. This is a top-down approach. Alternatively, we could have defined a geopolitical unit as the intersection area of those polygons and mapped one ballot style to each geopolitical unit 1 to 1. for instance, instead of defining a single GP Unit each for: Congressional District 5, Congressional District 7, LaCroix Township, Exeter Utility district, etc; we could have instead defined the GP Units as: Congressional District 5 No Township Congressional District 7 No Township Congressional District 5 inside LaCroix Congressional District 5 Inside LaCroix and Exeter, etc. Then, instead of each Ballot Style having multiple GP Units, each ballot style would have applied to exactly one GP Unit.","title":"Data Flexibility"},{"location":"concepts/Manifest_Building/#data-validation","text":"When the election Manifest is loaded into ElectionGuard, its validity is checked semantically against the data format required to conduct an ElectionGuard Election. Specifically, we check that: Each Geopolitical Unit has a unique objectId Each Ballot Style maps to at least one valid Geopolitical Unit Each Party has a unique objectId Each Candidate either does not have a party, or is associated with a valid party Each Contest has a unique Sequence Order Each Contest is associated with exactly one valid Geopolitical Unit Each Contest has a valid number of Selections for the number of seats in the contest Each Selection on each Contest is associated with a valid Candidate as long as the election manifest format matches the validation criteria, the election can proceed as an ElectionGuard election.","title":"Data Validation"},{"location":"concepts/Manifest_Building/#frequently-asked-questions","text":"Q: What if my ballot styles are not associated with geopolitical units? A: There are a few ways to handle this. In most cases, you can simply map the ballot style 1 to 1 to the geopolitical unit. for instance, if ballot-style-1 includes contest-1 then you may create geopolitical-unit-1 and associate both the ballot style and the contest to that geopolitical unit. This documentation is under review and subject to change. Please do not hesitate to open a github issue if you have questions, or find errors or omissions.","title":"Frequently Asked Questions"},{"location":"concepts/Manifest_Example/","text":"Manifest Example Work in Progress This is a work in progress. Feel free to contribute.","title":"Example"},{"location":"concepts/Manifest_Example/#manifest-example","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Manifest Example"},{"location":"concepts/Structure_and_Processes/","text":"Structure and Processes ElectionGuard provides tools to enable end-to-end verifiable elections. This allows voters to check for themselves that their votes have been accurately counted. The ElectionGuard process has three principal components. Pre-election key generation Ballot encryption Post-election decryption of tallies Pre-Election Key Generation ElectionGuard utilizes Guardians to protect confidentiality of ballots. The Guardians independently generate public-private key pairs from public election parameters. flowchart TD A(\"Guardian T 1 (K 1 ,S 1 )\")-->B(K 1 ); C(\"Guardian T 2 (K 2 ,S 2 )\")-->D(K 2 ); E(\"Guardian T n (K n ,S n )\")-->F(K n ); style B fill:#FFFFFF00,stroke:#FFFFFF00 style D fill:#FFFFFF00,stroke:#FFFFFF00 style F fill:#FFFFFF00,stroke:#FFFFFF00 The individual public keys are then combined to form the election public key using simple multiplication. \\[ K=\\prod_{i=1}^{n} K_i \\] At this point in the process, the only way to decrypt data encrypted with the election public key K is for all n Guardians to individually apply their secret keys. This situation is fragile since a single missing Guardian will prevent an election from being completed. To remedy this, as the final pre-election step, the Guardians distribute to each other shares of their private keys. The sharing is done according to a pre-determined quorum parameter k and will allow any quorum set of k Guardians to complete a decryption. graph LR A(\"Guardian T 1 (K 1 ,S 1 )\")-->|S 1,2 |B(\"Guardian T 2 (K 2 ,S 2 )\"); B-->|S 2,1 |A; A-->|S 1,n |C(\"Guardian T n (K n ,S n )\"); B-->|S 2,n |C; C-->|S n,2 |B; C-->|S n,1 |A; Balot Encryption An encrypted ballot consists entirely of encryptions of zeros and ones. A simple clear form ballot with a single contest might look something like the following. \\[ \\braket{{\\color{RoyalBlue} 0,1,0,0}} \\] This would represent a ballot with a single contest in which the second of four options has been selected. The encrypted version of this ballot would consist of four encrypted values \\[ \\braket{C_1,C_2,C_3,C_4} \\] accompanied by \"proofs\" that each W_i is an encryption of either zero or one. But this is not enough to show that an encrypted ballot represents a legitimate vote because the clear form might be as follows. \\[ \\braket{{\\color{RoyalBlue} 0,1,0,1}} \\] The above ballot would indicate votes for both the second and fourth options, and this may not be allowed. To address this, we use the homomorphic property of the encryption which allows us to combine encryptions to produce an encryption of the sum. By using simple encryption, we can form a new encrypted value as \\[ C=\\prod_{i=1}^{4} C_i \\] and include a proof that this W is an encryption of one to show that the ballot doesn\u2019t include excessive votes. Placeholders This isn\u2019t quite everything we need, because a voter might choose to not vote in a contest. The resulting clear form of this ballot would look like the following. \\[ \\braket{{\\color{RoyalBlue} 0,0,0,0}} \\] If we were to homomorphically combine values in an encrypted form of this ballot, we would get an encryption of zero \u2013 not an encryption of one. We wouldn\u2019t want to reveal this fact, because even a voter who chooses not to vote deserves privacy. To address this, we add a placeholder option to each contest that can be thought of as a \"none of the above\" vote. So a contest with four options would be typically be represented by a ballot with five positions \u2013 with the fifth option set to one if the voter selects none of the four options offered. \\[ \\braket{{\\color{RoyalBlue} 0,0,0,0},{\\color{SkyBlue} 1}} \\] [Color changes are for exposition only.] Internally, a placeholder option looks no different from an ordinary option. But we can now ensure that a homomorphic combination of all of the encryptions on a ballot will be one. An encrypted ballot can now be shown to be legitimate by proving that each value is an encryption of either zero and one and the homomorphic combination of all of the encryptions in each contest is an encryption of one. \\[ \\braket{{\\color{RoyalBlue} 0,0,0,0},{\\color{SkyBlue} 1}} \\longrightarrow {\\color{DarkBlue} 1} \\] Some might recognize this as a \"map-reduce\" operation (or for those familiar with Kenneth Iverson's APL, a simple reduction operation). The operator applied to encrypted values is simple multiplication. But the effect is to produce an encryption of the sum of the clear form values. Selection Limits There is one further generalization that must be accommodated. In some elections, there are contests where a voter is allowed to select more than one option. For example, there might be five options of which a voter is allowed to select up to three. To accommodate this possibility, we note the selection limit for each contest and generalize the use of placeholders. In most elections, all or most contests will have a selection limit of one, and one placeholder option will be added to each such contest. However, if the selection limit is higher, additional placeholder values are added \u2013 with the total number of placeholders matching the selection limit. For example, a \"choose up to three of five\" contest will be captured with eight encrypted values, the first five of which match the selections that can be made by a voter, and the last three of which are placeholder values that can be set if a voter does not make the maximum number of selections. The following offers some examples of how the clear form of a choose three of five ballot might be set. \\[\\begin{align} \\braket{{\\color{RoyalBlue} 1,0,0,1,1,}{\\color{SkyBlue}0,0,0}} \\longrightarrow {\\color{DarkBlue}3} \\\\ \\braket{{\\color{RoyalBlue} 0,1,1,0,1,}{\\color{SkyBlue}0,0,0}} \\longrightarrow {\\color{DarkBlue}3} \\\\ \\braket{{\\color{RoyalBlue} 1,0,0,1,0,}{\\color{SkyBlue} 0,0,1}}\\longrightarrow {\\color{DarkBlue}3} \\\\ \\braket{{\\color{RoyalBlue} 0,0,0,1,0,}{\\color{SkyBlue} 0,1,1}} \\longrightarrow {\\color{DarkBlue}3} \\\\ \\braket{{\\color{RoyalBlue}0,0,0,0,0,}{\\color{SkyBlue} 1,1,1}} \\longrightarrow {\\color{DarkBlue}3} \\\\ \\end{align}\\] [Color changes are for exposition only.] The first two instance represent ballots in which all three allowed votes have been used; the next instance shows a ballot in which only two options were selected; the following ballot instance contains one selection (and two placeholders set); and the final instance shows a case when a voter has made no selections and all three placeholders are used. In all of the above examples, an associated encrypted ballot is shown to be legitimate by showing that every value is an encryption of zero or one and the homomorphic combination of all of the encryptions produces an encryption of three. Write-in Votes ElectionGuard currently does not distinguish between write-ins. If a write-in option is offered, ElectionGuard treats it as any other selection. ElectionGuard tallies the number of write-ins for any contest without indicating what was written in. Multiple Contests Most elections consist of more than a single contest. A single ballot can therefore include multiple contests. An encrypted ballot still consists entirely of encryptions of zeros and ones, but the interpretation of these encryptions and the accompanying proofs depend upon details provided in the ballot manifest. \\[ \\braket{{\\color{RoyalBlue} 0,1,0,}{\\color{SkyBlue} 0};{\\color{ForestGreen} 1,0,}{\\color{YellowGreen} 0};{\\color{RoyalBlue} 0,0,}{\\color{SkyBlue} 1};{\\color{ForestGreen} 1,0,1,0,0,}{\\color{YellowGreen} 0,0,1}} \\] [Color changes are for exposition only.] The above example shows a clear form of a ballot with four contests in which the second of three options is selected in the first contest (with the fourth position as an unused placeholder), the first of two options is chosen in the second contest (with the third position as an unused placeholder), neither of two options is selected in the third contest (with the placeholder set to one), and the first and third option selected in a \"three of five\" fourth contest with one of three placeholders set to one. The encrypted form of the example above should be accompanied by proofs that all eighteen of the components are encryptions of zero or one, that the first four encryptions homomorphically combine to form an encryption of one, the next three encryptions homomorphically combine to form an encryption of one, the following three encryptions homomorphically combine to form an encryption of one, and the final eight encryptions homomorphically combine to form an encryption of three. Post-Election Decryption of Tallies When an election is complete, there will be a set of encrypted ballots that have been cast by voters and will be published in the election record. The homomorphic property that is used within individual ballots to show that the number of selected options for each contest is correct can also be used across ballots to compute tallies. For example, suppose that the five clear form ballots shown above as samples in a choose-three-of-five contest represent actual ballots cast in an election. \\[\\begin{align} \\braket{{\\color{RoyalBlue} 1,0,0,1,1,}{\\color{SkyBlue} 0,0,0}} \\\\ \\braket{{\\color{RoyalBlue} 0,1,1,0,1,}{\\color{SkyBlue} 0,0,0}} \\\\ \\braket{{\\color{RoyalBlue} 1,0,0,1,0,}{\\color{SkyBlue} 0,0,1}} \\\\ \\braket{{\\color{RoyalBlue} 0,0,0,1,0,}{\\color{SkyBlue} 0,1,1}} \\\\ \\braket{{\\color{RoyalBlue} 0,0,0,0,0,}{\\color{SkyBlue} 1,1,1}} \\\\ \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\\\ \\braket{{\\color{RoyalBlue} 2,1,1,3,2,}{\\color{SkyBlue} 1,2,3}} \\\\ \\end{align}\\] Verifiable Decryption Guardians can each apply their private keys to an encrypted value to perform a partial decryption. graph TD A(\"Guardian T 1 (K 1 ,S 1 )\")-->B(M 1 ); C(\"Guardian T 2 (K 2 ,S 2 )\")-->D(M 2 ); A1(C)-->A; C1(C)-->C; E(\"Guardian T n (K n ,S n )\")-->F(M n ); E1(C)-->E; style B fill:#FFFFFF00,stroke:#FFFFFF00 style D fill:#FFFFFF00,stroke:#FFFFFF00 style C1 fill:#FFFFFF00,stroke:#FFFFFF00 style A1 fill:#FFFFFF00,stroke:#FFFFFF00 style E1 fill:#FFFFFF00,stroke:#FFFFFF00 style F fill:#FFFFFF00,stroke:#FFFFFF00 The partial decryptions \\(M_i\\) can be combined \u2013 again using ordinary multiplication \u2013 to form the full decryption. \\[ M = \\prod _{i=1} ^n M_i \\] Together with each partial decryption, each guardian produces additional data that can be used by observers to very that the decryptions are correct. Missing Guardians If one or more Guardians are missing during a decryption, a quorum of any \\(k\\) available Guardians can form the partial decryption of the missing Guardian. graph TD A(\"Guardian T i 1 S j,i 1 \")-->B(M j,i 1 ); C(\"Guardian T i 2 S j,i 2 \")-->D(M j,i 2 ); A1(C)-->A; C1(C)-->C; E(\"Guardian T i k S j,i k \")-->F(M j,i k ); E1(C)-->E; style B fill:#FFFFFF00,stroke:#FFFFFF00 style D fill:#FFFFFF00,stroke:#FFFFFF00 style C1 fill:#FFFFFF00,stroke:#FFFFFF00 style A1 fill:#FFFFFF00,stroke:#FFFFFF00 style E1 fill:#FFFFFF00,stroke:#FFFFFF00 style F fill:#FFFFFF00,stroke:#FFFFFF00 The \\(k\\) values \\(M_{j,i_{1}},M_{j,i_{2}}, ... ,M_{j,i_{k}},\\) can be combined to calculate the missing partial decryption. In this way, an aggregate ballot can be fully and verifiably decrypted by any quorum set of \\(k\\) Guardians. Casting and Spoiling Voters need to be provided with a mechanism to encrypt their selections and have confidence that their selections have been correctly encrypted. The process used by ElectionGuard is to encrypt ballots as instructed by voters and then to allow voters to optionally spoil encrypted ballots. A spoiled ballot is verifiably decrypted (as with the aggregate ballot above), and the voter is given the opportunity to cast a new ballot. graph TD id[Make Selections]-->id1[Have Ballot Encrypted]; id1-->id2[Choose Cast or Spoil]; id2-->|Cast| id3[Record Encrypted Ballot as Cast]; id2-->|Spoil| id4[Decrypt Ballot and Record it as Spoiled]; id4-->id; The Election Record Once voting is complete, an election record is published containing all of the following artifacts. All cast encrypted ballot Proofs that all cast encrypted ballots are properly formed A tally ballot formed as the homomorphic aggregation of all cast ballots A verifiable decryption of the tally ballot All spoiled ballots Verifiable decryptions of all spoiled ballots Cast Ballots: #tb1 td{ border-width:0.5px; border-style:solid; border-color:#3d414b; text-align: center; vertical-align: middle } #tb1 th{ border-width:0.5px;border-style:solid; text-align: center; border-color:#3d414b; vertical-align: middle; height:20px } .hd{text-align:center;vertical-align:top} .em{background-color:#0E84EE} .lm{background-color:#1fccff} #tb1 #rm .em{border-left:none;border-right:none;background-color:transparent} Contest1 Contest2 Contest3 Encrypted Ballot 1 Proof of Correct Form Encrypted Ballot 2 Proof of Correct Form Encrypted Ballot 3 Proof of Correct Form Encrypted Ballot 4 Proof of Correct Form Encrypted Ballot 5 Proof of Correct Form Encrypted Ballot 6 Proof of Correct Form x x x x x x x x x x x x Encrypted Tally Decrypted Tally 3 1 2 1 2 3 0 2 2 1 1 3 Proof of Correct Decryption Spoiled Ballot 1: table td{ border-width:0.5px; border-style:solid; border-color:#3d414b; text-align: center; vertical-align: middle } table th{ border-width:0.5px;border-style:solid; text-align: center; border-color:#3d414b; vertical-align: middle; height:20px } Contest1 Contest2 Contest3 Encrypted Ballot Decrypted Ballot 0 1 0 0 1 0 0 0 0 0 0 1 Proof of Correct Decryption Spoiled Ballot 2: Contest1 Contest2 Contest3 Encrypted Ballot Decrypted Ballot 1 0 0 0 0 0 1 1 1 0 0 0 Proof of Correct Decryption Spoiled Ballot 3: Contest1 Contest2 Contest3 Encrypted Ballot Decrypted Ballot 1 0 0 0 0 0 0 1 0 0 0 1 Proof of Correct Decryption Spoiled Ballot 4: Contest1 Contest2 Contest3 Encrypted Ballot Decrypted Ballot 0 0 1 0 0 1 0 0 0 1 0 0 Proof of Correct Decryption Verification Voters are able to verify that their own ballots have been correctly recorded by utilizing the ballot spoiling process described above. Anyone can verify that recorded ballots have been accurately tallied by verifying the following items. For each cast ballot, the proof that the ballot is properly formed The tally ballot is the homomorphic aggregation of all cast ballots The proof that the aggregate tally ballot has been correctly decrypted In addition, the election record contains spoiled ballots for which the following should be verified. The proof of the correct decryption of each spoiled ballot Each spoiled ballot is properly formed (this can be done by checking proofs of proper formation or simply by inspecting the decryption) Although logically, the verification of correct decryption of spoiled ballots can be done by the individual voters who spoiled those ballots as part of the verification of correct recording; practically, this process closely matches the process of verifying correct decryption of the aggregate tally ballot. By transferring this responsibility to those verifying the election record, voters who want to verify correct recording of their ballots can be relieved of the responsibility of writing/executing code to check the decryption arithmetic and can instead check merely whether the claimed decryptions of spoiled ballots match their expectations.","title":"Structures and Processes"},{"location":"concepts/Structure_and_Processes/#structure-and-processes","text":"ElectionGuard provides tools to enable end-to-end verifiable elections. This allows voters to check for themselves that their votes have been accurately counted. The ElectionGuard process has three principal components. Pre-election key generation Ballot encryption Post-election decryption of tallies","title":"Structure and Processes"},{"location":"concepts/Structure_and_Processes/#pre-election-key-generation","text":"ElectionGuard utilizes Guardians to protect confidentiality of ballots. The Guardians independently generate public-private key pairs from public election parameters. flowchart TD A(\"Guardian T 1 (K 1 ,S 1 )\")-->B(K 1 ); C(\"Guardian T 2 (K 2 ,S 2 )\")-->D(K 2 ); E(\"Guardian T n (K n ,S n )\")-->F(K n ); style B fill:#FFFFFF00,stroke:#FFFFFF00 style D fill:#FFFFFF00,stroke:#FFFFFF00 style F fill:#FFFFFF00,stroke:#FFFFFF00 The individual public keys are then combined to form the election public key using simple multiplication. \\[ K=\\prod_{i=1}^{n} K_i \\] At this point in the process, the only way to decrypt data encrypted with the election public key K is for all n Guardians to individually apply their secret keys. This situation is fragile since a single missing Guardian will prevent an election from being completed. To remedy this, as the final pre-election step, the Guardians distribute to each other shares of their private keys. The sharing is done according to a pre-determined quorum parameter k and will allow any quorum set of k Guardians to complete a decryption. graph LR A(\"Guardian T 1 (K 1 ,S 1 )\")-->|S 1,2 |B(\"Guardian T 2 (K 2 ,S 2 )\"); B-->|S 2,1 |A; A-->|S 1,n |C(\"Guardian T n (K n ,S n )\"); B-->|S 2,n |C; C-->|S n,2 |B; C-->|S n,1 |A;","title":"Pre-Election Key Generation"},{"location":"concepts/Structure_and_Processes/#balot-encryption","text":"An encrypted ballot consists entirely of encryptions of zeros and ones. A simple clear form ballot with a single contest might look something like the following. \\[ \\braket{{\\color{RoyalBlue} 0,1,0,0}} \\] This would represent a ballot with a single contest in which the second of four options has been selected. The encrypted version of this ballot would consist of four encrypted values \\[ \\braket{C_1,C_2,C_3,C_4} \\] accompanied by \"proofs\" that each W_i is an encryption of either zero or one. But this is not enough to show that an encrypted ballot represents a legitimate vote because the clear form might be as follows. \\[ \\braket{{\\color{RoyalBlue} 0,1,0,1}} \\] The above ballot would indicate votes for both the second and fourth options, and this may not be allowed. To address this, we use the homomorphic property of the encryption which allows us to combine encryptions to produce an encryption of the sum. By using simple encryption, we can form a new encrypted value as \\[ C=\\prod_{i=1}^{4} C_i \\] and include a proof that this W is an encryption of one to show that the ballot doesn\u2019t include excessive votes.","title":"Balot Encryption"},{"location":"concepts/Structure_and_Processes/#placeholders","text":"This isn\u2019t quite everything we need, because a voter might choose to not vote in a contest. The resulting clear form of this ballot would look like the following. \\[ \\braket{{\\color{RoyalBlue} 0,0,0,0}} \\] If we were to homomorphically combine values in an encrypted form of this ballot, we would get an encryption of zero \u2013 not an encryption of one. We wouldn\u2019t want to reveal this fact, because even a voter who chooses not to vote deserves privacy. To address this, we add a placeholder option to each contest that can be thought of as a \"none of the above\" vote. So a contest with four options would be typically be represented by a ballot with five positions \u2013 with the fifth option set to one if the voter selects none of the four options offered. \\[ \\braket{{\\color{RoyalBlue} 0,0,0,0},{\\color{SkyBlue} 1}} \\] [Color changes are for exposition only.] Internally, a placeholder option looks no different from an ordinary option. But we can now ensure that a homomorphic combination of all of the encryptions on a ballot will be one. An encrypted ballot can now be shown to be legitimate by proving that each value is an encryption of either zero and one and the homomorphic combination of all of the encryptions in each contest is an encryption of one. \\[ \\braket{{\\color{RoyalBlue} 0,0,0,0},{\\color{SkyBlue} 1}} \\longrightarrow {\\color{DarkBlue} 1} \\] Some might recognize this as a \"map-reduce\" operation (or for those familiar with Kenneth Iverson's APL, a simple reduction operation). The operator applied to encrypted values is simple multiplication. But the effect is to produce an encryption of the sum of the clear form values.","title":"Placeholders"},{"location":"concepts/Structure_and_Processes/#selection-limits","text":"There is one further generalization that must be accommodated. In some elections, there are contests where a voter is allowed to select more than one option. For example, there might be five options of which a voter is allowed to select up to three. To accommodate this possibility, we note the selection limit for each contest and generalize the use of placeholders. In most elections, all or most contests will have a selection limit of one, and one placeholder option will be added to each such contest. However, if the selection limit is higher, additional placeholder values are added \u2013 with the total number of placeholders matching the selection limit. For example, a \"choose up to three of five\" contest will be captured with eight encrypted values, the first five of which match the selections that can be made by a voter, and the last three of which are placeholder values that can be set if a voter does not make the maximum number of selections. The following offers some examples of how the clear form of a choose three of five ballot might be set. \\[\\begin{align} \\braket{{\\color{RoyalBlue} 1,0,0,1,1,}{\\color{SkyBlue}0,0,0}} \\longrightarrow {\\color{DarkBlue}3} \\\\ \\braket{{\\color{RoyalBlue} 0,1,1,0,1,}{\\color{SkyBlue}0,0,0}} \\longrightarrow {\\color{DarkBlue}3} \\\\ \\braket{{\\color{RoyalBlue} 1,0,0,1,0,}{\\color{SkyBlue} 0,0,1}}\\longrightarrow {\\color{DarkBlue}3} \\\\ \\braket{{\\color{RoyalBlue} 0,0,0,1,0,}{\\color{SkyBlue} 0,1,1}} \\longrightarrow {\\color{DarkBlue}3} \\\\ \\braket{{\\color{RoyalBlue}0,0,0,0,0,}{\\color{SkyBlue} 1,1,1}} \\longrightarrow {\\color{DarkBlue}3} \\\\ \\end{align}\\] [Color changes are for exposition only.] The first two instance represent ballots in which all three allowed votes have been used; the next instance shows a ballot in which only two options were selected; the following ballot instance contains one selection (and two placeholders set); and the final instance shows a case when a voter has made no selections and all three placeholders are used. In all of the above examples, an associated encrypted ballot is shown to be legitimate by showing that every value is an encryption of zero or one and the homomorphic combination of all of the encryptions produces an encryption of three.","title":"Selection Limits"},{"location":"concepts/Structure_and_Processes/#write-in-votes","text":"ElectionGuard currently does not distinguish between write-ins. If a write-in option is offered, ElectionGuard treats it as any other selection. ElectionGuard tallies the number of write-ins for any contest without indicating what was written in.","title":"Write-in Votes"},{"location":"concepts/Structure_and_Processes/#multiple-contests","text":"Most elections consist of more than a single contest. A single ballot can therefore include multiple contests. An encrypted ballot still consists entirely of encryptions of zeros and ones, but the interpretation of these encryptions and the accompanying proofs depend upon details provided in the ballot manifest. \\[ \\braket{{\\color{RoyalBlue} 0,1,0,}{\\color{SkyBlue} 0};{\\color{ForestGreen} 1,0,}{\\color{YellowGreen} 0};{\\color{RoyalBlue} 0,0,}{\\color{SkyBlue} 1};{\\color{ForestGreen} 1,0,1,0,0,}{\\color{YellowGreen} 0,0,1}} \\] [Color changes are for exposition only.] The above example shows a clear form of a ballot with four contests in which the second of three options is selected in the first contest (with the fourth position as an unused placeholder), the first of two options is chosen in the second contest (with the third position as an unused placeholder), neither of two options is selected in the third contest (with the placeholder set to one), and the first and third option selected in a \"three of five\" fourth contest with one of three placeholders set to one. The encrypted form of the example above should be accompanied by proofs that all eighteen of the components are encryptions of zero or one, that the first four encryptions homomorphically combine to form an encryption of one, the next three encryptions homomorphically combine to form an encryption of one, the following three encryptions homomorphically combine to form an encryption of one, and the final eight encryptions homomorphically combine to form an encryption of three.","title":"Multiple Contests"},{"location":"concepts/Structure_and_Processes/#post-election-decryption-of-tallies","text":"When an election is complete, there will be a set of encrypted ballots that have been cast by voters and will be published in the election record. The homomorphic property that is used within individual ballots to show that the number of selected options for each contest is correct can also be used across ballots to compute tallies. For example, suppose that the five clear form ballots shown above as samples in a choose-three-of-five contest represent actual ballots cast in an election. \\[\\begin{align} \\braket{{\\color{RoyalBlue} 1,0,0,1,1,}{\\color{SkyBlue} 0,0,0}} \\\\ \\braket{{\\color{RoyalBlue} 0,1,1,0,1,}{\\color{SkyBlue} 0,0,0}} \\\\ \\braket{{\\color{RoyalBlue} 1,0,0,1,0,}{\\color{SkyBlue} 0,0,1}} \\\\ \\braket{{\\color{RoyalBlue} 0,0,0,1,0,}{\\color{SkyBlue} 0,1,1}} \\\\ \\braket{{\\color{RoyalBlue} 0,0,0,0,0,}{\\color{SkyBlue} 1,1,1}} \\\\ \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\enspace \\downarrow \\\\ \\braket{{\\color{RoyalBlue} 2,1,1,3,2,}{\\color{SkyBlue} 1,2,3}} \\\\ \\end{align}\\]","title":"Post-Election Decryption of Tallies"},{"location":"concepts/Structure_and_Processes/#verifiable-decryption","text":"Guardians can each apply their private keys to an encrypted value to perform a partial decryption. graph TD A(\"Guardian T 1 (K 1 ,S 1 )\")-->B(M 1 ); C(\"Guardian T 2 (K 2 ,S 2 )\")-->D(M 2 ); A1(C)-->A; C1(C)-->C; E(\"Guardian T n (K n ,S n )\")-->F(M n ); E1(C)-->E; style B fill:#FFFFFF00,stroke:#FFFFFF00 style D fill:#FFFFFF00,stroke:#FFFFFF00 style C1 fill:#FFFFFF00,stroke:#FFFFFF00 style A1 fill:#FFFFFF00,stroke:#FFFFFF00 style E1 fill:#FFFFFF00,stroke:#FFFFFF00 style F fill:#FFFFFF00,stroke:#FFFFFF00 The partial decryptions \\(M_i\\) can be combined \u2013 again using ordinary multiplication \u2013 to form the full decryption. \\[ M = \\prod _{i=1} ^n M_i \\] Together with each partial decryption, each guardian produces additional data that can be used by observers to very that the decryptions are correct.","title":"Verifiable Decryption"},{"location":"concepts/Structure_and_Processes/#missing-guardians","text":"If one or more Guardians are missing during a decryption, a quorum of any \\(k\\) available Guardians can form the partial decryption of the missing Guardian. graph TD A(\"Guardian T i 1 S j,i 1 \")-->B(M j,i 1 ); C(\"Guardian T i 2 S j,i 2 \")-->D(M j,i 2 ); A1(C)-->A; C1(C)-->C; E(\"Guardian T i k S j,i k \")-->F(M j,i k ); E1(C)-->E; style B fill:#FFFFFF00,stroke:#FFFFFF00 style D fill:#FFFFFF00,stroke:#FFFFFF00 style C1 fill:#FFFFFF00,stroke:#FFFFFF00 style A1 fill:#FFFFFF00,stroke:#FFFFFF00 style E1 fill:#FFFFFF00,stroke:#FFFFFF00 style F fill:#FFFFFF00,stroke:#FFFFFF00 The \\(k\\) values \\(M_{j,i_{1}},M_{j,i_{2}}, ... ,M_{j,i_{k}},\\) can be combined to calculate the missing partial decryption. In this way, an aggregate ballot can be fully and verifiably decrypted by any quorum set of \\(k\\) Guardians.","title":"Missing Guardians"},{"location":"concepts/Structure_and_Processes/#casting-and-spoiling","text":"Voters need to be provided with a mechanism to encrypt their selections and have confidence that their selections have been correctly encrypted. The process used by ElectionGuard is to encrypt ballots as instructed by voters and then to allow voters to optionally spoil encrypted ballots. A spoiled ballot is verifiably decrypted (as with the aggregate ballot above), and the voter is given the opportunity to cast a new ballot. graph TD id[Make Selections]-->id1[Have Ballot Encrypted]; id1-->id2[Choose Cast or Spoil]; id2-->|Cast| id3[Record Encrypted Ballot as Cast]; id2-->|Spoil| id4[Decrypt Ballot and Record it as Spoiled]; id4-->id;","title":"Casting and Spoiling"},{"location":"concepts/Structure_and_Processes/#the-election-record","text":"Once voting is complete, an election record is published containing all of the following artifacts. All cast encrypted ballot Proofs that all cast encrypted ballots are properly formed A tally ballot formed as the homomorphic aggregation of all cast ballots A verifiable decryption of the tally ballot All spoiled ballots Verifiable decryptions of all spoiled ballots Cast Ballots: #tb1 td{ border-width:0.5px; border-style:solid; border-color:#3d414b; text-align: center; vertical-align: middle } #tb1 th{ border-width:0.5px;border-style:solid; text-align: center; border-color:#3d414b; vertical-align: middle; height:20px } .hd{text-align:center;vertical-align:top} .em{background-color:#0E84EE} .lm{background-color:#1fccff} #tb1 #rm .em{border-left:none;border-right:none;background-color:transparent} Contest1 Contest2 Contest3 Encrypted Ballot 1 Proof of Correct Form Encrypted Ballot 2 Proof of Correct Form Encrypted Ballot 3 Proof of Correct Form Encrypted Ballot 4 Proof of Correct Form Encrypted Ballot 5 Proof of Correct Form Encrypted Ballot 6 Proof of Correct Form x x x x x x x x x x x x Encrypted Tally Decrypted Tally 3 1 2 1 2 3 0 2 2 1 1 3 Proof of Correct Decryption Spoiled Ballot 1: table td{ border-width:0.5px; border-style:solid; border-color:#3d414b; text-align: center; vertical-align: middle } table th{ border-width:0.5px;border-style:solid; text-align: center; border-color:#3d414b; vertical-align: middle; height:20px } Contest1 Contest2 Contest3 Encrypted Ballot Decrypted Ballot 0 1 0 0 1 0 0 0 0 0 0 1 Proof of Correct Decryption Spoiled Ballot 2: Contest1 Contest2 Contest3 Encrypted Ballot Decrypted Ballot 1 0 0 0 0 0 1 1 1 0 0 0 Proof of Correct Decryption Spoiled Ballot 3: Contest1 Contest2 Contest3 Encrypted Ballot Decrypted Ballot 1 0 0 0 0 0 0 1 0 0 0 1 Proof of Correct Decryption Spoiled Ballot 4: Contest1 Contest2 Contest3 Encrypted Ballot Decrypted Ballot 0 0 1 0 0 1 0 0 0 1 0 0 Proof of Correct Decryption","title":"The Election Record"},{"location":"concepts/Structure_and_Processes/#verification","text":"Voters are able to verify that their own ballots have been correctly recorded by utilizing the ballot spoiling process described above. Anyone can verify that recorded ballots have been accurately tallied by verifying the following items. For each cast ballot, the proof that the ballot is properly formed The tally ballot is the homomorphic aggregation of all cast ballots The proof that the aggregate tally ballot has been correctly decrypted In addition, the election record contains spoiled ballots for which the following should be verified. The proof of the correct decryption of each spoiled ballot Each spoiled ballot is properly formed (this can be done by checking proofs of proper formation or simply by inspecting the decryption) Although logically, the verification of correct decryption of spoiled ballots can be done by the individual voters who spoiled those ballots as part of the verification of correct recording; practically, this process closely matches the process of verifying correct decryption of the aggregate tally ballot. By transferring this responsibility to those verifying the election record, voters who want to verify correct recording of their ballots can be relieved of the responsibility of writing/executing code to check the decryption arithmetic and can instead check merely whether the claimed decryptions of spoiled ballots match their expectations.","title":"Verification"},{"location":"concepts/Verifiability/","text":"Creating a Verifiable Election ElectionGuard is a software development kit (SDK) election system vendors can use to implement end-to-end verifiable (E2E-V) elections. Because it is designed to be integrated into both existing and new systems, it needs to be flexible. However, for end-to-end verifiability to be achieved, the following 3 core capabilities must be delivered: The voter is given a verification code they can use to verify their ballot was included in the final tally The voter has the means to challenge a ballot The election results and all its encrypted artifacts, including zero knowledge proofs, are published to enable full independent verifiability by third parties We describe each of these capabilities in detail below. Voter Verification Code A voter verification code is generated by the ballot encryption process of ElectionGuard. It is generated when the user has submitted their ballot to the voting system. Generating the Verification Code Submitting a ballot can mean virtually pressing a \"Submit\" button on a touchscreen voting device, inserting a paper ballot into a digital scanner, or some other event that causes a cast vote record to be generated in the voting system. From a user experience standpoint, the ballot encryption occurs at a point after the voter has filled out all contests they plan to, and has had a chance to review all their choices in a summary screen (or the completed paper ballot). In the ballot marking device use case, the ballot would be encrypted after the voter presses submit. For a ballot scanner, the cast vote record is generated after the scanner has interpreted the ballot. Please note that while the diagrams above show devices such as 'encrypted ballot server', ElectionGuard is intended to be run in an offline environment ; as such, if an API or server is used to listen for or communicate encryption requests, they are expected to be run locally in a secure environment. Once the ballot has been encrypted, the encrypting device needs to handle the verification code returned by the ballot encryption process and present it to the voter, ideally by printing it at the moment of creation in a format easy for the voter to take with them. When the election results are published (see \"Publishing election results\" below), these verification codes are published alongside, enabling them to see that their ballots were included in the election tally (or, in the case of Challenge Ballots, that they were included as challenge ballots (see \"Challenging a Ballot\" below)) The verification code format is a mix of human-readable words and alphanumeric codes. The first word is always human-readable to facilitate a search-like discovery experience (to try, go to our demo tracking site and begin typing 'coo' to surface the verification code above, or simply click the image to be taken directly). Challenging a ballot Encrypting a ballot and generating a verification code is the first step in an E2E-V process for the voter. For E2E-V compliance, the voter has to be offered the ability to challenge or \"spoil\" the ballot after the verification code has been generated and provided to the voter. When a ballot is challenged, it is no longer eligible to be included in the final tally. If the voter wants to register a vote after a challenge, they will need to begin the process again with a new ballot. In addition, when a ballot is challenged, the system must be able to perform a decryption of the challenged ballot and reveal its contents to the voter. Challenging of ballots increases the inherent security of the system, since the system has to assume that any ballot encrypted might have to be revealed, exposing any manipulation that may have occurred after submission; the system can't assume its actions will remain hidden. Individual voters can obtain as much confidence as they desire by challenging as many ballots as they wish. Although they won't ever be shown that the encryption of a cast ballot matches their selections, voters can see that every challenged ballot was correctly encrypted and committed to before the decision to cast or challenge was made. The ability to observe that all challenge ballots are correct thereby provides indirect evidence that cast ballots were also correct. Publishing Verifiable results When the election is complete and the results tallied, E2E-V elections publish the results so they can be verified independently. E2E-V election verifiers are written by third parties according to their interpretation of the ElectionGuard Specification . Any data published by an election should enable each and every cast encrypted ballot to be interrogated and tallied independently. From the spec: An ElectionGuard ballot is comprised entirely of encryptions of one (indicating selection made) and zero (indicating selection not made). Two things must be proven about the encryption of each vote: The encryption associated with each option is either an encryption of zero or an encryption of one. The sum of all encrypted values in a contest is equal to the selection limit for that contest (usually one). ElGamal encryption enables efficient zero-knowledge proofs of these requirements, and the Fiat-Shamir heuristic can be used to make these proofs non-interactive. Chaum-Pedersen proofs are used to demonstrate that an encryption is that of a specified value, and these are combined with the Cramer-Damg\u00e5rd-Schoenmakers technique to show that an encryption is that of one of a specified set of values \u2013 particularly that a value is an encryption of either zero or one. The set of encryptions of selections in a contest are homomorphically combined, and the result is shown to be an encryption of that contest\u2019s selection limit, again using a Chaum-Pedersen proof. Once every ballot is proven to be properly formed (as above), all of the votes for each option are homomorphically summed to produce encryptions of the tallies for each option. The final step is then to decrypt these tallies and provide additional proofs that the decryption are correct. Showing Verification Code Results to Voters In addition to satisfying the data requirements for proper verification, any publishing exercise needs to also enable individual voters to query for the ballot that matches their verification code. Verification code results of cast ballots will indicate that the ballot was included in the final tally, and any associated metadata about the device that recorded the ballot (time, location, election, etc.; see example above). Challenge ballots are also published. Results for verification codes of challenge ballots should indicate that the ballot was not included in the election tally. Because the ballot is not included in the election tally, the contents can be decrypted and presented as well.","title":"Introduction"},{"location":"concepts/Verifiability/#creating-a-verifiable-election","text":"ElectionGuard is a software development kit (SDK) election system vendors can use to implement end-to-end verifiable (E2E-V) elections. Because it is designed to be integrated into both existing and new systems, it needs to be flexible. However, for end-to-end verifiability to be achieved, the following 3 core capabilities must be delivered: The voter is given a verification code they can use to verify their ballot was included in the final tally The voter has the means to challenge a ballot The election results and all its encrypted artifacts, including zero knowledge proofs, are published to enable full independent verifiability by third parties We describe each of these capabilities in detail below.","title":"Creating a Verifiable Election"},{"location":"concepts/Verifiability/#voter-verification-code","text":"A voter verification code is generated by the ballot encryption process of ElectionGuard. It is generated when the user has submitted their ballot to the voting system.","title":"Voter Verification Code"},{"location":"concepts/Verifiability/#generating-the-verification-code","text":"Submitting a ballot can mean virtually pressing a \"Submit\" button on a touchscreen voting device, inserting a paper ballot into a digital scanner, or some other event that causes a cast vote record to be generated in the voting system. From a user experience standpoint, the ballot encryption occurs at a point after the voter has filled out all contests they plan to, and has had a chance to review all their choices in a summary screen (or the completed paper ballot). In the ballot marking device use case, the ballot would be encrypted after the voter presses submit. For a ballot scanner, the cast vote record is generated after the scanner has interpreted the ballot. Please note that while the diagrams above show devices such as 'encrypted ballot server', ElectionGuard is intended to be run in an offline environment ; as such, if an API or server is used to listen for or communicate encryption requests, they are expected to be run locally in a secure environment. Once the ballot has been encrypted, the encrypting device needs to handle the verification code returned by the ballot encryption process and present it to the voter, ideally by printing it at the moment of creation in a format easy for the voter to take with them. When the election results are published (see \"Publishing election results\" below), these verification codes are published alongside, enabling them to see that their ballots were included in the election tally (or, in the case of Challenge Ballots, that they were included as challenge ballots (see \"Challenging a Ballot\" below)) The verification code format is a mix of human-readable words and alphanumeric codes. The first word is always human-readable to facilitate a search-like discovery experience (to try, go to our demo tracking site and begin typing 'coo' to surface the verification code above, or simply click the image to be taken directly).","title":"Generating the Verification Code"},{"location":"concepts/Verifiability/#challenging-a-ballot","text":"Encrypting a ballot and generating a verification code is the first step in an E2E-V process for the voter. For E2E-V compliance, the voter has to be offered the ability to challenge or \"spoil\" the ballot after the verification code has been generated and provided to the voter. When a ballot is challenged, it is no longer eligible to be included in the final tally. If the voter wants to register a vote after a challenge, they will need to begin the process again with a new ballot. In addition, when a ballot is challenged, the system must be able to perform a decryption of the challenged ballot and reveal its contents to the voter. Challenging of ballots increases the inherent security of the system, since the system has to assume that any ballot encrypted might have to be revealed, exposing any manipulation that may have occurred after submission; the system can't assume its actions will remain hidden. Individual voters can obtain as much confidence as they desire by challenging as many ballots as they wish. Although they won't ever be shown that the encryption of a cast ballot matches their selections, voters can see that every challenged ballot was correctly encrypted and committed to before the decision to cast or challenge was made. The ability to observe that all challenge ballots are correct thereby provides indirect evidence that cast ballots were also correct.","title":"Challenging a ballot"},{"location":"concepts/Verifiability/#publishing-verifiable-results","text":"When the election is complete and the results tallied, E2E-V elections publish the results so they can be verified independently. E2E-V election verifiers are written by third parties according to their interpretation of the ElectionGuard Specification . Any data published by an election should enable each and every cast encrypted ballot to be interrogated and tallied independently. From the spec: An ElectionGuard ballot is comprised entirely of encryptions of one (indicating selection made) and zero (indicating selection not made). Two things must be proven about the encryption of each vote: The encryption associated with each option is either an encryption of zero or an encryption of one. The sum of all encrypted values in a contest is equal to the selection limit for that contest (usually one). ElGamal encryption enables efficient zero-knowledge proofs of these requirements, and the Fiat-Shamir heuristic can be used to make these proofs non-interactive. Chaum-Pedersen proofs are used to demonstrate that an encryption is that of a specified value, and these are combined with the Cramer-Damg\u00e5rd-Schoenmakers technique to show that an encryption is that of one of a specified set of values \u2013 particularly that a value is an encryption of either zero or one. The set of encryptions of selections in a contest are homomorphically combined, and the result is shown to be an encryption of that contest\u2019s selection limit, again using a Chaum-Pedersen proof. Once every ballot is proven to be properly formed (as above), all of the votes for each option are homomorphically summed to produce encryptions of the tallies for each option. The final step is then to decrypt these tallies and provide additional proofs that the decryption are correct.","title":"Publishing Verifiable results"},{"location":"concepts/Verifiability/#showing-verification-code-results-to-voters","text":"In addition to satisfying the data requirements for proper verification, any publishing exercise needs to also enable individual voters to query for the ballot that matches their verification code. Verification code results of cast ballots will indicate that the ballot was included in the final tally, and any associated metadata about the device that recorded the ballot (time, location, election, etc.; see example above). Challenge ballots are also published. Results for verification codes of challenge ballots should indicate that the ballot was not included in the election tally. Because the ballot is not included in the election tally, the contents can be decrypted and presented as well.","title":"Showing Verification Code Results to Voters"},{"location":"concepts/Verifier/","text":"","title":"Verifier"},{"location":"concepts/Voter_Verification/","text":"","title":"Voter"},{"location":"contribute/","text":"Contribute Whenever possible and as a guiding principle, the evolution of the ElectionGuard SDK will be driven by the use cases and priorities of the community and in service of best-practice implementations of real-world, secret-ballot public elections. Community contributions are highly valued. Help defend democracy and contribute to ElectionGuard. Where to Start? There are many locations to contribute to ElectionGuard. ElectionGuard is an open source platform and depends on an active community and ecosystem. The SDK is comprised of five repositories: ElectionGuard Specification ElectionGuard Python ElectionGuard C++ ElectionGuard Python API ElectionGuard React UI Ways to get involved Learn about ElectionGuard and share the information Post questions or ideas in our discussion board Join our weekly video office hours Develop on issues in the repos with tags of good first issue or help wanted Add to and improve documentation. Keep it Plain English and include helpful images . Contributions ElectionGuard relies on its community for its success. For example, for end-to-end verifiable elections, integrity is improved by the number of independent verifiers that confirm the results of an election. Verifiers Python Verifier by Rainbow Huang C# Verifier by Brandon Alexander Java Verifier by John Caron Python Verifier (electionguard-verify) by Nicholas Boucher Library Ports Java port of Python Library by John Caron","title":"Contribute"},{"location":"contribute/#contribute","text":"Whenever possible and as a guiding principle, the evolution of the ElectionGuard SDK will be driven by the use cases and priorities of the community and in service of best-practice implementations of real-world, secret-ballot public elections. Community contributions are highly valued. Help defend democracy and contribute to ElectionGuard.","title":"Contribute"},{"location":"contribute/#where-to-start","text":"There are many locations to contribute to ElectionGuard. ElectionGuard is an open source platform and depends on an active community and ecosystem. The SDK is comprised of five repositories: ElectionGuard Specification ElectionGuard Python ElectionGuard C++ ElectionGuard Python API ElectionGuard React UI","title":"Where to Start?"},{"location":"contribute/#ways-to-get-involved","text":"Learn about ElectionGuard and share the information Post questions or ideas in our discussion board Join our weekly video office hours Develop on issues in the repos with tags of good first issue or help wanted Add to and improve documentation. Keep it Plain English and include helpful images .","title":"Ways to get involved"},{"location":"contribute/#contributions","text":"ElectionGuard relies on its community for its success. For example, for end-to-end verifiable elections, integrity is improved by the number of independent verifiers that confirm the results of an election.","title":"Contributions"},{"location":"contribute/#verifiers","text":"Python Verifier by Rainbow Huang C# Verifier by Brandon Alexander Java Verifier by John Caron Python Verifier (electionguard-verify) by Nicholas Boucher","title":"Verifiers"},{"location":"contribute/#library-ports","text":"Java port of Python Library by John Caron","title":"Library Ports"},{"location":"develop/Applications/","text":"Applications There are many different paths for creating applications that work using ElectionGuard. For many of these paths, there are reference implementations that can be forked or used as examples or used as packages. Many reference implementations include packaging or containerization for easy consumption. Below are some examples of paths a developer could take when developing using ElectionGuard. This list is by no means complete and some of these paths can be combined for different applications and use cases. If you develop an app for ElectionGuard, we suggest you utilize our badges to indicate which version of the specification your application targets. Paths ElectionGuard Core An ElectionGuard Core is an application that implements the base level features such as Ballot Encryption by implementing them according to the specification. The internal examples of this are the Python and C++ reference implementations. There is a community example of this with the Java port done by the community. Ballot Marking Ballot marking is the process of recording a voter's selections on a ballot. A ballot marking app displays the contests from the manifest according to an individuals voter's ballot style and language. The voter then votes and the selections are recorded on a plaintext ballot . Ballot Encryption Ballot encryption is the process of converting voter selections into data such that it cannot be read by unauthorized parties. A ballot encryption app provides this fundamental functionality. The app functions as a tool that encrypts a plaintext ballot into a encrypted ballot aka ciphertext ballot . Two quick ways to start are by using the ElectionGuard encryption nuget package or or python package . Ballot Box A ballot box app takes the encrypted ballot of a voter and allows a user to submit the ballot as cast or spoil the ballot. A submitted cast ballot is aggregated into the tally. A submitted spoiled ballot is added to the list of spoiled ballots. Administer Election Administering an election for ElectionGuard usually requires the following steps. An example of this is available in electionguard-ui repository . Setup Election - An election should be setup with a manifest and selected guardians Key Ceremony - A key ceremony should be run that results in the encryption key that can be used for the ballots. Tally Ceremony - A tally ceremony when run will decrypt the tally and any spoiled ballots Election Record - An election record should be retrievable at the end of the election for publication and verification purposes. A quick way to start is to use the electionguard api-client and the electionguard-python-api . Publish Election The results of election can be displayed after an election is closed. An example of this is available in electionguard-ui repository . This application should contain three pieces. Results - Using decrypted tally and manifest, the tallied results should be displayed. Ballot Confirmation - Confirm a ballot is in the Election Record. Confirm Cast - Confirm a ballot was cast and included in tally Challenge Ballot - Confirm a ballot was spoiled and display decrypted spoiled ballot to user Download Election Record - The Election Record should be downloadable for the public. Verify Election A verifier app verifies an election is true and accurate by using the publicly published information about a completed election. At the close of an election using ElectionGuard, an election record should be created and made public. ElectionGuard encourages third parties to create their own verifiers and help verify election records. A basic example of a verifier can be found within the electionguard-python repository , but verifiers should aim to be as thorough as possible. After consuming the files in an election record, verifiers can validate everything from the key ceremony to the decryption since the election is end to end verifiable.","title":"Applications"},{"location":"develop/Applications/#applications","text":"There are many different paths for creating applications that work using ElectionGuard. For many of these paths, there are reference implementations that can be forked or used as examples or used as packages. Many reference implementations include packaging or containerization for easy consumption. Below are some examples of paths a developer could take when developing using ElectionGuard. This list is by no means complete and some of these paths can be combined for different applications and use cases. If you develop an app for ElectionGuard, we suggest you utilize our badges to indicate which version of the specification your application targets.","title":"Applications"},{"location":"develop/Applications/#paths","text":"","title":"Paths"},{"location":"develop/Applications/#electionguard-core","text":"An ElectionGuard Core is an application that implements the base level features such as Ballot Encryption by implementing them according to the specification. The internal examples of this are the Python and C++ reference implementations. There is a community example of this with the Java port done by the community.","title":"ElectionGuard Core"},{"location":"develop/Applications/#ballot-marking","text":"Ballot marking is the process of recording a voter's selections on a ballot. A ballot marking app displays the contests from the manifest according to an individuals voter's ballot style and language. The voter then votes and the selections are recorded on a plaintext ballot .","title":"Ballot Marking"},{"location":"develop/Applications/#ballot-encryption","text":"Ballot encryption is the process of converting voter selections into data such that it cannot be read by unauthorized parties. A ballot encryption app provides this fundamental functionality. The app functions as a tool that encrypts a plaintext ballot into a encrypted ballot aka ciphertext ballot . Two quick ways to start are by using the ElectionGuard encryption nuget package or or python package .","title":"Ballot Encryption"},{"location":"develop/Applications/#ballot-box","text":"A ballot box app takes the encrypted ballot of a voter and allows a user to submit the ballot as cast or spoil the ballot. A submitted cast ballot is aggregated into the tally. A submitted spoiled ballot is added to the list of spoiled ballots.","title":"Ballot Box"},{"location":"develop/Applications/#administer-election","text":"Administering an election for ElectionGuard usually requires the following steps. An example of this is available in electionguard-ui repository . Setup Election - An election should be setup with a manifest and selected guardians Key Ceremony - A key ceremony should be run that results in the encryption key that can be used for the ballots. Tally Ceremony - A tally ceremony when run will decrypt the tally and any spoiled ballots Election Record - An election record should be retrievable at the end of the election for publication and verification purposes. A quick way to start is to use the electionguard api-client and the electionguard-python-api .","title":"Administer Election"},{"location":"develop/Applications/#publish-election","text":"The results of election can be displayed after an election is closed. An example of this is available in electionguard-ui repository . This application should contain three pieces. Results - Using decrypted tally and manifest, the tallied results should be displayed. Ballot Confirmation - Confirm a ballot is in the Election Record. Confirm Cast - Confirm a ballot was cast and included in tally Challenge Ballot - Confirm a ballot was spoiled and display decrypted spoiled ballot to user Download Election Record - The Election Record should be downloadable for the public.","title":"Publish Election"},{"location":"develop/Applications/#verify-election","text":"A verifier app verifies an election is true and accurate by using the publicly published information about a completed election. At the close of an election using ElectionGuard, an election record should be created and made public. ElectionGuard encourages third parties to create their own verifiers and help verify election records. A basic example of a verifier can be found within the electionguard-python repository , but verifiers should aim to be as thorough as possible. After consuming the files in an election record, verifiers can validate everything from the key ceremony to the decryption since the election is end to end verifiable.","title":"Verify Election"},{"location":"develop/Approach/","text":"Approach For the ElectionGuard repositories, these are the concepts that guide the approach for developers and writers. \u2705 Simplicity Simplicity is the first and foremost goal of the code. The intent is for others to be able to easily transliterate the code to any other programming language with little more than structures and functions. This simplicity applies to all aspects of the code design, including naming. \u2705 Transparency ElectionGuard is open source first. Our code, our issues and even our Continuous Integration (CI) is designed to be visible to the public. This is to allow others to both be able to trust the code, learn, and hopefully help improve ElectionGuard. GitHub tools have been our primary tool to maintain transparency. Our cards are all GitHub issues. Our continuous integration uses GitHub Workflows to be out in the open. \u2705 Readability Whether developing or writing for ElectionGuard, the goal is to create easy to read and understand text. We will always be improving in this area, but the goal is to make the system easy to grasp for not only developers, but for the public. This is the primary reason that Python was chosen as the primary reference implementation. Understanding the code and the written word is essential for confidence. \u2705 Testability The goal is to maximize code coverage and testing on the reference implementations. Tests are essential to the repositories for both providing proof the code functions but also to provide an understanding of how the code works. This means writing code that can be tested and writing the accompanying tests. \u2705 Extendable and Interpretable The reference implementations are intentionally general-purpose to support the different use cases of voting systems. Different projects may wish to use different pieces and parts of each repository.","title":"Approach"},{"location":"develop/Approach/#approach","text":"For the ElectionGuard repositories, these are the concepts that guide the approach for developers and writers.","title":"Approach"},{"location":"develop/Approach/#simplicity","text":"Simplicity is the first and foremost goal of the code. The intent is for others to be able to easily transliterate the code to any other programming language with little more than structures and functions. This simplicity applies to all aspects of the code design, including naming.","title":"\u2705 Simplicity"},{"location":"develop/Approach/#transparency","text":"ElectionGuard is open source first. Our code, our issues and even our Continuous Integration (CI) is designed to be visible to the public. This is to allow others to both be able to trust the code, learn, and hopefully help improve ElectionGuard. GitHub tools have been our primary tool to maintain transparency. Our cards are all GitHub issues. Our continuous integration uses GitHub Workflows to be out in the open.","title":"\u2705 Transparency"},{"location":"develop/Approach/#readability","text":"Whether developing or writing for ElectionGuard, the goal is to create easy to read and understand text. We will always be improving in this area, but the goal is to make the system easy to grasp for not only developers, but for the public. This is the primary reason that Python was chosen as the primary reference implementation. Understanding the code and the written word is essential for confidence.","title":"\u2705 Readability"},{"location":"develop/Approach/#testability","text":"The goal is to maximize code coverage and testing on the reference implementations. Tests are essential to the repositories for both providing proof the code functions but also to provide an understanding of how the code works. This means writing code that can be tested and writing the accompanying tests.","title":"\u2705 Testability"},{"location":"develop/Approach/#extendable-and-interpretable","text":"The reference implementations are intentionally general-purpose to support the different use cases of voting systems. Different projects may wish to use different pieces and parts of each repository.","title":"\u2705 Extendable and Interpretable"},{"location":"develop/Architecture/","text":"Architecture There are five official repositories in the ElectionGuard SDK . ElectionGuard Specification ElectionGuard Python ElectionGuard C++ ElectionGuard Python API ElectionGuard React UI The ElectionGuard Specification repository focuses on explaining ElectionGuard as a whole including documentation and the specification itself. The other repositories are all reference implementations. These reference implementations are designed to demonstrate to developers how to implement a system using the ElectionGuard Specification . In depth descriptions of the repositories are detailed in the repositories page. Cores An ElectionGuard Core is a code base that implements fundamental features of the ElectionGuard Specification (such as ballot encryption) to act as a core or central integration. ElectionGuard provides two official reference implementations of Cores: Python and C++. The Python Core ( electionguard-python ) is full featured including all elements of the specification to showcase ElectionGuard to its fullest. The C++ Core ( electionguard-cpp ) is designed with a focus on encrypting ballots. Its goal is to allow developers to use the ElectionGuard encryption on encryption devices. Feature electionguard-python electionguard-cpp Ballot Encryption Ballot Decryption Key Generation Key Ceremony Tally Ceremony Tally Decryption Paths The specification serves as the guide to implement any ElectionGuard Core . For the official reference implementations, there are two main paths within the reference implementations of ElectionGuard. One path starts with the Python Core ( electionguard-python ) and the other starts with C++ Core ( electionguard-cpp ). These paths can used together, but have different feature sets. flowchart TD specification[\"Specification\"] -.-> |Python|python[\"Full Featured Core\"]; specification -.-> |C++|cpp[\"Encryption Core\"]; python --> api[\"API\"]; api --> ui[\"User Interface\"]; This chart shows the relationship of the specification to the reference implementations by repository name. This paints the picture of how the repositories are related to each other. flowchart TD spec[\"electionguard\"] -.-> |Python|e-python[\"electionguard-python\"]; spec[\"electionguard\"] -.-> |C++|e-cpp[\"electionguard-cpp\"]; e-python --> web-api[\"electionguard-api-python\"]; web-api --> e-ui[\"electionguard-ui\"]; Python Path The Python path is full featured including all elements of the specification to showcase ElectionGuard to its fullest. There is a full stack provided for Python so there are many different approaches and entry points a developer could use when starting here. The following suggested approaches can be used to develop apps like those listed in the applications list. Suggested Approaches Build a custom Python app with electionguard-python package Build a custom web app and use electionguard-api-python as an API Build a custom web app with electionguard-ui 's api client and use electionguard-api-python as an API. Build a custom web app from fork of electionguard-ui 's web apps and use electionguard-api-python as an API C++ Path For the C++ path, the included reference implementation of a C++ Core and resulting packages are currently designed with a focus on encrypting ballots. Its goal is to allow developers to use ElectionGuard encryption on encryption devices. The following suggested approaches can be used to develop a ballot encryption app or integration as described in the applications list. Suggested Approaches Build custom app linking C++ library Build custom app and use NuGet Package","title":"Architecture"},{"location":"develop/Architecture/#architecture","text":"There are five official repositories in the ElectionGuard SDK . ElectionGuard Specification ElectionGuard Python ElectionGuard C++ ElectionGuard Python API ElectionGuard React UI The ElectionGuard Specification repository focuses on explaining ElectionGuard as a whole including documentation and the specification itself. The other repositories are all reference implementations. These reference implementations are designed to demonstrate to developers how to implement a system using the ElectionGuard Specification . In depth descriptions of the repositories are detailed in the repositories page.","title":"Architecture"},{"location":"develop/Architecture/#cores","text":"An ElectionGuard Core is a code base that implements fundamental features of the ElectionGuard Specification (such as ballot encryption) to act as a core or central integration. ElectionGuard provides two official reference implementations of Cores: Python and C++. The Python Core ( electionguard-python ) is full featured including all elements of the specification to showcase ElectionGuard to its fullest. The C++ Core ( electionguard-cpp ) is designed with a focus on encrypting ballots. Its goal is to allow developers to use the ElectionGuard encryption on encryption devices. Feature electionguard-python electionguard-cpp Ballot Encryption Ballot Decryption Key Generation Key Ceremony Tally Ceremony Tally Decryption","title":"Cores"},{"location":"develop/Architecture/#paths","text":"The specification serves as the guide to implement any ElectionGuard Core . For the official reference implementations, there are two main paths within the reference implementations of ElectionGuard. One path starts with the Python Core ( electionguard-python ) and the other starts with C++ Core ( electionguard-cpp ). These paths can used together, but have different feature sets. flowchart TD specification[\"Specification\"] -.-> |Python|python[\"Full Featured Core\"]; specification -.-> |C++|cpp[\"Encryption Core\"]; python --> api[\"API\"]; api --> ui[\"User Interface\"]; This chart shows the relationship of the specification to the reference implementations by repository name. This paints the picture of how the repositories are related to each other. flowchart TD spec[\"electionguard\"] -.-> |Python|e-python[\"electionguard-python\"]; spec[\"electionguard\"] -.-> |C++|e-cpp[\"electionguard-cpp\"]; e-python --> web-api[\"electionguard-api-python\"]; web-api --> e-ui[\"electionguard-ui\"];","title":"Paths"},{"location":"develop/Architecture/#python-path","text":"The Python path is full featured including all elements of the specification to showcase ElectionGuard to its fullest. There is a full stack provided for Python so there are many different approaches and entry points a developer could use when starting here. The following suggested approaches can be used to develop apps like those listed in the applications list.","title":"Python Path"},{"location":"develop/Architecture/#suggested-approaches","text":"Build a custom Python app with electionguard-python package Build a custom web app and use electionguard-api-python as an API Build a custom web app with electionguard-ui 's api client and use electionguard-api-python as an API. Build a custom web app from fork of electionguard-ui 's web apps and use electionguard-api-python as an API","title":"Suggested Approaches"},{"location":"develop/Architecture/#c-path","text":"For the C++ path, the included reference implementation of a C++ Core and resulting packages are currently designed with a focus on encrypting ballots. Its goal is to allow developers to use ElectionGuard encryption on encryption devices. The following suggested approaches can be used to develop a ballot encryption app or integration as described in the applications list.","title":"C++ Path"},{"location":"develop/Architecture/#suggested-approaches_1","text":"Build custom app linking C++ library Build custom app and use NuGet Package","title":"Suggested Approaches"},{"location":"develop/Badges/","text":"Badges For your convenience, these are some badges to add to your repository indicating the version of ElectionGuard your code supports. See versioning . [![ElectionGuard 0.85](https://img.shields.io/badge/\ud83d\uddf3%20ElectionGuard-v0.85-red)](https://www.electionguard.vote/spec) [![ElectionGuard 0.95](https://img.shields.io/badge/\ud83d\uddf3%20ElectionGuard-v0.95-green)](https://www.electionguard.vote/spec) [![ElectionGuard 1.0](https://img.shields.io/badge/\ud83d\uddf3%20ElectionGuard-v1.0-green)](https://www.electionguard.vote/spec) [![ElectionGuard 2.0](https://img.shields.io/badge/\ud83d\uddf3%20ElectionGuard-v2.0-yellow)](https://www.electionguard.vote/spec)","title":"Badges"},{"location":"develop/Badges/#badges","text":"For your convenience, these are some badges to add to your repository indicating the version of ElectionGuard your code supports. See versioning . [![ElectionGuard 0.85](https://img.shields.io/badge/\ud83d\uddf3%20ElectionGuard-v0.85-red)](https://www.electionguard.vote/spec) [![ElectionGuard 0.95](https://img.shields.io/badge/\ud83d\uddf3%20ElectionGuard-v0.95-green)](https://www.electionguard.vote/spec) [![ElectionGuard 1.0](https://img.shields.io/badge/\ud83d\uddf3%20ElectionGuard-v1.0-green)](https://www.electionguard.vote/spec) [![ElectionGuard 2.0](https://img.shields.io/badge/\ud83d\uddf3%20ElectionGuard-v2.0-yellow)](https://www.electionguard.vote/spec)","title":"Badges"},{"location":"develop/Data_Schema/","text":"Data Schema ElectionGuard expects data to be formatted in a particular way according to a set of JSON schemas . The expectation is to keep these schemas alongside the specification. The schemas will be defined here to indicate to developers what they should be expecting. Keep in mind that not all serialized files should be public. The election record includes the list of all data formats that should be public. Sample data for the election is also available for developers. This will include both what is in the Election Record, but also some private data only available for testing. Schema Currently, JSON is used as the primary serialization format of the artifacts from an election. These are JSON schema files that can be used to verify the schema of the setup files like the manifest pre-election and the election record files post-election. This represents the full list of items that can be serialized / deserialized, but not all elections will use every file type. Work in Progress This is a work in progress. Feel free to contribute. Election Manifest / Manifest - Election manifest Context / CiphertextElectionContext - Context for encryption for specific election Constants / ElectionConstants - Constants of election Encryption Device / EncryptionDevice - Encryption device information Ceremony Guardian / GuardianRecord - Single guardian's record Lagrange Coefficients / LagrangeCoefficientsRecord - Lagrange coefficients Ballot Ballot / PlaintextBallot - Plaintext ballot [Compact Ballot][compact_ballot] / CompactBallot - Compact ballot Encrypted Ballot / CiphertextBallot - Encrypted ballot Submitted Ballot / SubmittedBallot - Submitted cast or spoiled ballot Tally Tally / PlaintextTally - Plaintext tally Encrypted Tally / PublishedCiphertextTally - Encrypted tally","title":"Data Schema"},{"location":"develop/Data_Schema/#data-schema","text":"ElectionGuard expects data to be formatted in a particular way according to a set of JSON schemas . The expectation is to keep these schemas alongside the specification. The schemas will be defined here to indicate to developers what they should be expecting. Keep in mind that not all serialized files should be public. The election record includes the list of all data formats that should be public. Sample data for the election is also available for developers. This will include both what is in the Election Record, but also some private data only available for testing.","title":"Data Schema"},{"location":"develop/Data_Schema/#schema","text":"Currently, JSON is used as the primary serialization format of the artifacts from an election. These are JSON schema files that can be used to verify the schema of the setup files like the manifest pre-election and the election record files post-election. This represents the full list of items that can be serialized / deserialized, but not all elections will use every file type. Work in Progress This is a work in progress. Feel free to contribute.","title":"Schema"},{"location":"develop/Data_Schema/#election","text":"Manifest / Manifest - Election manifest Context / CiphertextElectionContext - Context for encryption for specific election Constants / ElectionConstants - Constants of election Encryption Device / EncryptionDevice - Encryption device information","title":"Election"},{"location":"develop/Data_Schema/#ceremony","text":"Guardian / GuardianRecord - Single guardian's record Lagrange Coefficients / LagrangeCoefficientsRecord - Lagrange coefficients","title":"Ceremony"},{"location":"develop/Data_Schema/#ballot","text":"Ballot / PlaintextBallot - Plaintext ballot [Compact Ballot][compact_ballot] / CompactBallot - Compact ballot Encrypted Ballot / CiphertextBallot - Encrypted ballot Submitted Ballot / SubmittedBallot - Submitted cast or spoiled ballot","title":"Ballot"},{"location":"develop/Data_Schema/#tally","text":"Tally / PlaintextTally - Plaintext tally Encrypted Tally / PublishedCiphertextTally - Encrypted tally","title":"Tally"},{"location":"develop/Election_Record/","text":"Election Record The Election Record is the group of files required at the end of the election to verify the election and is intended to be posted publicly. It should not contain any sensitive data (eg: no guardian private keys) in the record. These include the following: Encryption Devices Information Guardian Records Decrypted Spoiled Ballots Encrypted Submitted Ballots Lagrange Coefficients Record Election Constants Election Context Encrypted Tally Manifest Decrypted Tally Folder Structure The Election Record should be expected to be a zip folder containing the following information. \ud83d\udcc2 record --- \ud83d\udcc1 encryption_devices ------- \ud83d\udcc4 device_id_1.json ------- \ud83d\udcc4 device_id_2.json ------- ... --- \ud83d\udcc1 guardians ------- \ud83d\udcc4 guardian_id_1.json ------- \ud83d\udcc4 guardian_id_2.json ------- ... --- \ud83d\udcc1 spoiled_ballots ------- \ud83d\udcc4 spoiled_ballot_id_3.json ------- \ud83d\udcc4 spoiled_ballot_id_4.json ------- ... --- \ud83d\udcc1 submitted_ballots ------- \ud83d\udcc4 submitted_ballot_id_1.json ------- \ud83d\udcc4 submitted_ballot_id_2.json ------- ... --- \ud83d\udcc4 coefficients.json --- \ud83d\udcc4 constants.json --- \ud83d\udcc4 context.json --- \ud83d\udcc4 encrypted_tally.json --- \ud83d\udcc4 manifest.json --- \ud83d\udcc4 tally.json","title":"Election Record"},{"location":"develop/Election_Record/#election-record","text":"The Election Record is the group of files required at the end of the election to verify the election and is intended to be posted publicly. It should not contain any sensitive data (eg: no guardian private keys) in the record. These include the following: Encryption Devices Information Guardian Records Decrypted Spoiled Ballots Encrypted Submitted Ballots Lagrange Coefficients Record Election Constants Election Context Encrypted Tally Manifest Decrypted Tally","title":"Election Record"},{"location":"develop/Election_Record/#folder-structure","text":"The Election Record should be expected to be a zip folder containing the following information. \ud83d\udcc2 record --- \ud83d\udcc1 encryption_devices ------- \ud83d\udcc4 device_id_1.json ------- \ud83d\udcc4 device_id_2.json ------- ... --- \ud83d\udcc1 guardians ------- \ud83d\udcc4 guardian_id_1.json ------- \ud83d\udcc4 guardian_id_2.json ------- ... --- \ud83d\udcc1 spoiled_ballots ------- \ud83d\udcc4 spoiled_ballot_id_3.json ------- \ud83d\udcc4 spoiled_ballot_id_4.json ------- ... --- \ud83d\udcc1 submitted_ballots ------- \ud83d\udcc4 submitted_ballot_id_1.json ------- \ud83d\udcc4 submitted_ballot_id_2.json ------- ... --- \ud83d\udcc4 coefficients.json --- \ud83d\udcc4 constants.json --- \ud83d\udcc4 context.json --- \ud83d\udcc4 encrypted_tally.json --- \ud83d\udcc4 manifest.json --- \ud83d\udcc4 tally.json","title":"Folder Structure"},{"location":"develop/Getting_Started/","text":"Getting Started ElectionGuard as an SDK provides a specification and reference implementations with specific data format. If you're looking to develop code with ElectionGuard, you might be wondering where to start. There are two paths: Create an app using ElectionGuard Contribute to ElectionGuard's open source Tip If you're having trouble understanding where to start, the architecture and [data format][data-format] pages dive in a bit deeper. Take a look at versioning to get a good idea of what is still in progress. Create an App There are many different possible applications that can be created using ElectionGuard reference implementations or for ElectionGuard. A helpful starting list can be found within applications . Feel free to use badges to indicate which version of the specification the app was developed for. Contribute to Open Source ElectionGuard is an open source platform and depends on an active community and ecosystem. The contribute page highlights some top level ways to contribute. For those that want to jump right in, take a look at our approach and our repositories . Note Each repository houses the in-depth developer documentation for coding with the repositories.","title":"Getting Started"},{"location":"develop/Getting_Started/#getting-started","text":"ElectionGuard as an SDK provides a specification and reference implementations with specific data format. If you're looking to develop code with ElectionGuard, you might be wondering where to start. There are two paths: Create an app using ElectionGuard Contribute to ElectionGuard's open source Tip If you're having trouble understanding where to start, the architecture and [data format][data-format] pages dive in a bit deeper. Take a look at versioning to get a good idea of what is still in progress.","title":"Getting Started"},{"location":"develop/Getting_Started/#create-an-app","text":"There are many different possible applications that can be created using ElectionGuard reference implementations or for ElectionGuard. A helpful starting list can be found within applications . Feel free to use badges to indicate which version of the specification the app was developed for.","title":"Create an App"},{"location":"develop/Getting_Started/#contribute-to-open-source","text":"ElectionGuard is an open source platform and depends on an active community and ecosystem. The contribute page highlights some top level ways to contribute. For those that want to jump right in, take a look at our approach and our repositories . Note Each repository houses the in-depth developer documentation for coding with the repositories.","title":"Contribute to Open Source"},{"location":"develop/Repositories/","text":"Repositories There are 5 repositories within the ElectionGuard SDK : ElectionGuard Specification ElectionGuard Python ElectionGuard C++ ElectionGuard Python API ElectionGuard React UI If you're looking to develop for ElectionGuard, it might help if you pick something you're familiar with. The following list acts to showcase the language to assist you in finding the right place. Each repository contains information on the best way to contribute and how to setup the development environment. Take a look and see what appeals to you. ElectionGuard Specification The ElectionGuard Specification repository addresses the mathematical and conceptual underpinnings of end-to-end verifiability in a manner that comfortably accommodates post-election audits. The specification houses the core data constructs, tests, and datasets that we recommend to ensure portability and data integrity. The ElectionGuard site is also built from this repository using mkdocs. This can be a friendly place to start out for new developers trying to get started. Specification | Source ElectionGuard Python The ElectionGuard Python library is a reference implementation of the ElectionGuard SDK . It covers the entire suite of functionality and processes necessary to implement an end-to-end verifiable election as part a voting system: Key generation ceremony Ballot encryption Tally ceremony Ballot decryption It is designed to be portable over performant , universal over Pythonic (although we do try to adhere to the Zen of Python ). Any real-world voting use case will need to incorporate the capabilities of the Python library to run an end-to-end verifiable election or post-election audit . Source | Package | Documentation Community-sourced Java port Check out our community contributions for a Java port . ElectionGuard C++ The ElectionGuard C++ library performs ballot encryption. It is designed for devices that handle the user experience of voting. These devices follow the economics and performance of embedded systems: special-purpose devices designed for low cost. We assume Intel Atom class processor-level performance and Raspberry Pi 3 types of operating systems. In addition to the C++ library itself, there is some focus on target different standalone packages. This leads to the usage of other languages like C and C#. Source ElectionGuard Python API This API uses the electionguard-python package in a Python API utilizing FastAPI. This exposes the full featured Python ElectionGuard and allows users to create docker containers of the API. Source ElectionGuard UI This UI application features several TypeScript packages as a monorepo, a version-controlled code repository that holds many projects, to reduce repeated tooling. It contains two web applications. One is an application to administer an election. The other is an application to display the election results. There are two helper packages, one functions as an api client and the other is a component library. Source","title":"Repositories"},{"location":"develop/Repositories/#repositories","text":"There are 5 repositories within the ElectionGuard SDK : ElectionGuard Specification ElectionGuard Python ElectionGuard C++ ElectionGuard Python API ElectionGuard React UI If you're looking to develop for ElectionGuard, it might help if you pick something you're familiar with. The following list acts to showcase the language to assist you in finding the right place. Each repository contains information on the best way to contribute and how to setup the development environment. Take a look and see what appeals to you.","title":"Repositories"},{"location":"develop/Repositories/#electionguard-specification","text":"The ElectionGuard Specification repository addresses the mathematical and conceptual underpinnings of end-to-end verifiability in a manner that comfortably accommodates post-election audits. The specification houses the core data constructs, tests, and datasets that we recommend to ensure portability and data integrity. The ElectionGuard site is also built from this repository using mkdocs. This can be a friendly place to start out for new developers trying to get started. Specification | Source","title":"ElectionGuard Specification  "},{"location":"develop/Repositories/#electionguard-python","text":"The ElectionGuard Python library is a reference implementation of the ElectionGuard SDK . It covers the entire suite of functionality and processes necessary to implement an end-to-end verifiable election as part a voting system: Key generation ceremony Ballot encryption Tally ceremony Ballot decryption It is designed to be portable over performant , universal over Pythonic (although we do try to adhere to the Zen of Python ). Any real-world voting use case will need to incorporate the capabilities of the Python library to run an end-to-end verifiable election or post-election audit . Source | Package | Documentation Community-sourced Java port Check out our community contributions for a Java port .","title":"ElectionGuard Python  "},{"location":"develop/Repositories/#electionguard-c","text":"The ElectionGuard C++ library performs ballot encryption. It is designed for devices that handle the user experience of voting. These devices follow the economics and performance of embedded systems: special-purpose devices designed for low cost. We assume Intel Atom class processor-level performance and Raspberry Pi 3 types of operating systems. In addition to the C++ library itself, there is some focus on target different standalone packages. This leads to the usage of other languages like C and C#. Source","title":"ElectionGuard C++  "},{"location":"develop/Repositories/#electionguard-python-api","text":"This API uses the electionguard-python package in a Python API utilizing FastAPI. This exposes the full featured Python ElectionGuard and allows users to create docker containers of the API. Source","title":"ElectionGuard Python API  "},{"location":"develop/Repositories/#electionguard-ui","text":"This UI application features several TypeScript packages as a monorepo, a version-controlled code repository that holds many projects, to reduce repeated tooling. It contains two web applications. One is an application to administer an election. The other is an application to display the election results. There are two helper packages, one functions as an api client and the other is a component library. Source","title":"ElectionGuard UI  "},{"location":"develop/Sample_Data/","text":"Sample Data To better understand the data formats used by ElectionGuard, sample data is provided here to guide new developers. Four Sample Elections We have provided sample data for four different elections: Minimal - This is the most minimal election manifest file possible, designed to be easy to inspect and quick to develop against for rapid testing. All optional fields have been removed from the election manifest file. The election contains a single Yes/No referendum with a single ballot style in a single geopolitical unit. Small - This is designed to be a relatively small and simple election, but with more complexity than the minimal election. This is a good sample data set to begin understanding more complex ballot types with two or more geopolitical units or ballot styles. Three contests are listed (one of each type: Yes/No Referendum, Select One, and Select n of m), two GP units, two ballot styles, and a small number of recommended optional fields are included. Full - This is a more realistic example for a primary election for a municipality. This ballot contains several geopolitical units with multiple ballot styles and contains all optional metadata fields. This sample has multi-language support and multiple submitted ballot samples. Hamilton General - This is a complete example for a general election for a fictional municipality. This example contains many geopolitical units with multiple ballot styles and demonstrates how political districts overlap. This sample has multi-language support and multiple submitted ballot samples. The Hamilton General example also includes the election private data that includes guardian private keys. More information about the Hamilton General Example can be found in the Election Manifest Documentation . Data Election Manifests The Election Manifest contains all the details of the election (such as contests, candidates, selections, ballot styles, etc.) and is required at the start of an ElectionGuard election. Manifest Examples: [minimal][minimal-election-manifest] | [small][small-election-manifest] | [full][full-election-manifest] | hamilton Submitted Ballots Submitted Ballots are encrypted ballots that have been cast or spoiled . Cast ballots will be tallied and spoiled ballots are decrypted. Submitted Ballot Examples: [minimal][minimal-election-ballot] | [small][small-election-ballot] | [full][full-election-ballot] | hamilton Election Record The Election Record are the files required at the end of the election to verify the election and are intended to be posted publicly. There should not be any sensitive data (eg: no guardian private keys) in the record. Artifacts Examples: [minimal][minimal-election-record] | [small][small-election-record] | [full][full-election-record] | hamilton","title":"Sample Data"},{"location":"develop/Sample_Data/#sample-data","text":"To better understand the data formats used by ElectionGuard, sample data is provided here to guide new developers.","title":"Sample Data"},{"location":"develop/Sample_Data/#four-sample-elections","text":"We have provided sample data for four different elections: Minimal - This is the most minimal election manifest file possible, designed to be easy to inspect and quick to develop against for rapid testing. All optional fields have been removed from the election manifest file. The election contains a single Yes/No referendum with a single ballot style in a single geopolitical unit. Small - This is designed to be a relatively small and simple election, but with more complexity than the minimal election. This is a good sample data set to begin understanding more complex ballot types with two or more geopolitical units or ballot styles. Three contests are listed (one of each type: Yes/No Referendum, Select One, and Select n of m), two GP units, two ballot styles, and a small number of recommended optional fields are included. Full - This is a more realistic example for a primary election for a municipality. This ballot contains several geopolitical units with multiple ballot styles and contains all optional metadata fields. This sample has multi-language support and multiple submitted ballot samples. Hamilton General - This is a complete example for a general election for a fictional municipality. This example contains many geopolitical units with multiple ballot styles and demonstrates how political districts overlap. This sample has multi-language support and multiple submitted ballot samples. The Hamilton General example also includes the election private data that includes guardian private keys. More information about the Hamilton General Example can be found in the Election Manifest Documentation .","title":"Four Sample Elections"},{"location":"develop/Sample_Data/#data","text":"","title":"Data"},{"location":"develop/Sample_Data/#election-manifests","text":"The Election Manifest contains all the details of the election (such as contests, candidates, selections, ballot styles, etc.) and is required at the start of an ElectionGuard election. Manifest Examples: [minimal][minimal-election-manifest] | [small][small-election-manifest] | [full][full-election-manifest] | hamilton","title":"Election Manifests"},{"location":"develop/Sample_Data/#submitted-ballots","text":"Submitted Ballots are encrypted ballots that have been cast or spoiled . Cast ballots will be tallied and spoiled ballots are decrypted. Submitted Ballot Examples: [minimal][minimal-election-ballot] | [small][small-election-ballot] | [full][full-election-ballot] | hamilton","title":"Submitted Ballots"},{"location":"develop/Sample_Data/#election-record","text":"The Election Record are the files required at the end of the election to verify the election and are intended to be posted publicly. There should not be any sensitive data (eg: no guardian private keys) in the record. Artifacts Examples: [minimal][minimal-election-record] | [small][small-election-record] | [full][full-election-record] | hamilton","title":"Election Record"},{"location":"develop/Versioning/","text":"Versioning Versioning for ElectionGuard as the Software Development Kit (SDK) may seem complex, particularly between the Specification, the code repositories, and the serialized files in the sample data. To attempt to reduce the complexity, the versioning for ElectionGuard will be as the whole SDK including the serialization, instead of individual components. This is to help the users of ElectionGuard identify the pieces and parts that function together. As an example, a verifier will need to support the same version(s) of ElectionGuard as the election system it is verifying. How It Works SDK version will line up with a specification post 1.0. This is to allow contributors to develop following the ElectionGuard Specification of the SDK and utilize the badge system to indicate what their code supports. Major versions will indicate this top level version consistently across the repositories starting in 1.0. The goal is to keep the Election Record and other serialized files consistent outside of major versions changes. Minor and smaller versions can differ to allow freedom within the code repositories. For example, the latest version python core could be v2.1.1 while the c++ core is at v2.48.0. Current ElectionGuard 1.0 Part Link Release Specification PDF 1.0 Sample Data Unreleased 1.0 Python Core Unreleased 1.4 C++ Core Unreleased 1.0 Python API Unreleased 1.1 React UI Unreleased 1.0 Future ElectionGuard 2.0 Part Link Release Specification Unreleased 2.0 Sample Data Unreleased 2.0 Python Core Unreleased 2.0 C++ Core Unreleased 2.0 Python API Unreleased 2.0 React UI Unreleased 2.0 Previous ElectionGuard 0.95 Part Link Release Specification PDF 0.95 Sample Data Source 0.95 Python Core Source 1.2.2 C++ Core Source 0.1.6 ElectionGuard 0.85 Part Link Release Specification PDF 0.85 C Core Deprecated 1.0 C# Core Deprecated 1.0","title":"Versioning"},{"location":"develop/Versioning/#versioning","text":"Versioning for ElectionGuard as the Software Development Kit (SDK) may seem complex, particularly between the Specification, the code repositories, and the serialized files in the sample data. To attempt to reduce the complexity, the versioning for ElectionGuard will be as the whole SDK including the serialization, instead of individual components. This is to help the users of ElectionGuard identify the pieces and parts that function together. As an example, a verifier will need to support the same version(s) of ElectionGuard as the election system it is verifying.","title":"Versioning"},{"location":"develop/Versioning/#how-it-works","text":"SDK version will line up with a specification post 1.0. This is to allow contributors to develop following the ElectionGuard Specification of the SDK and utilize the badge system to indicate what their code supports. Major versions will indicate this top level version consistently across the repositories starting in 1.0. The goal is to keep the Election Record and other serialized files consistent outside of major versions changes. Minor and smaller versions can differ to allow freedom within the code repositories. For example, the latest version python core could be v2.1.1 while the c++ core is at v2.48.0.","title":"How It Works"},{"location":"develop/Versioning/#current","text":"","title":"Current"},{"location":"develop/Versioning/#electionguard-10","text":"Part Link Release Specification PDF 1.0 Sample Data Unreleased 1.0 Python Core Unreleased 1.4 C++ Core Unreleased 1.0 Python API Unreleased 1.1 React UI Unreleased 1.0","title":"ElectionGuard 1.0"},{"location":"develop/Versioning/#future","text":"","title":"Future"},{"location":"develop/Versioning/#electionguard-20","text":"Part Link Release Specification Unreleased 2.0 Sample Data Unreleased 2.0 Python Core Unreleased 2.0 C++ Core Unreleased 2.0 Python API Unreleased 2.0 React UI Unreleased 2.0","title":"ElectionGuard 2.0"},{"location":"develop/Versioning/#previous","text":"","title":"Previous"},{"location":"develop/Versioning/#electionguard-095","text":"Part Link Release Specification PDF 0.95 Sample Data Source 0.95 Python Core Source 1.2.2 C++ Core Source 0.1.6","title":"ElectionGuard 0.95"},{"location":"develop/Versioning/#electionguard-085","text":"Part Link Release Specification PDF 0.85 C Core Deprecated 1.0 C# Core Deprecated 1.0","title":"ElectionGuard 0.85"},{"location":"events/Office_hours/","text":"ElectionGuard Monthly Office Hours The ElectionGuard project leadership hosts monthly videoconference meetings using Microsoft Teams . They take place the first Wednesday of every month from 12:00-1:00 PM Pacific Time .","title":"Monthly Office Hours"},{"location":"events/Office_hours/#electionguard-monthly-office-hours","text":"The ElectionGuard project leadership hosts monthly videoconference meetings using Microsoft Teams . They take place the first Wednesday of every month from 12:00-1:00 PM Pacific Time .","title":"ElectionGuard Monthly Office Hours"},{"location":"events/eg_usability_aug_2022/","text":"ElectionGuard Hart Verity Scanner and Usability Convening August 3-5, 2022 Overview This convening is a hybrid event that will be held both virtually on Microsoft Teams and in-person at the Microsoft campus in Redmond, Washington. If you would like to join us, please register via this form . All times Pacific Daylight Time (PDT). Agenda Wednesday, August 3 9:00-9:30 Coffee and breakfast nosh 9:30-9:45 Introductions and Agenda [RC Carter, Microsoft] ElectionGuard Hart Verity Precinct Scan Implementation and Ecosystem 9:45-10:15 What is ElectionGuard and How Does It Work? [RC Carter, Microsoft] 10:15-11:00 An Overview of the ElectionGuard Ecosystem [Josh Benaloh, Microsoft] 11:00-11:10 Break 11:10-11:30 ElectionGuard Integrated Election Setup (Demonstration) [Lee Richardson and Steve Maier, InfernoRed; RC Carter, Microsoft] 11:30-12:30 Implementing End-to-End Verifiability in the Verity Voting System: Lessons in ElectionGuard Integration and the Voting Experience (includes demonstration) [Jim Canter, Eugene Konovalenko, and Drew Tinney, Hart] 12:30-1:30 Lunch and Voting 1:30-1:45 Generating the Election Record (Demonstration) [Lee Richardson and Steve Maier, InfernoRed; RC Carter, Microsoft] 1:45-2:00 Confirmation Code Lookup Site (Demonstration) [Aaron Wilson, Enhanced Voting] 2:00-2:45 Practical ElectionGuard Verifier Implementation (includes Demonstration)[Moses Liskov and Dr. John Ramsdell, MITRE] Dinner in Seattle Thursday, August 4 9:00-9:30 Coffee and breakfast nosh Usability and Accessibility in US Elections 9:30-10:15 Ballot Marking Device Verification: Can vs. Do [Mike Byrne, Rice University] Related publication: \"Can Voters Detect Errors on Their Printed Ballots? Absolutely\" Philip Kortum, Michael D. Byrne, Chidera O. Azubike, Laura E. Roty 10:15-11:00 Opportunities for Accessibility Innovation with VVSG 2.0 [Whitney Quesenberry, Center for Civic Design] 11:00-11:10 Break 11:10-12:00 EAC Perspectives on Accessibility, End-to-End Verifiability, and VVSG 2.0 [Thomas Hicks, Election Assistance Commission] 12:00-12:15 Grab lunch and prepare for panel 12:15-1:30 Panel Discussion: Usability Considerations that Can Improve Security and Independence [Tyler Schrenk, the Tyler Schrenk Foundation; Clark Rachfal, American Council of the Blind; Michelle Bishop, MSW, National Disability Rights Network; Diana Mairose, Self Advocates Becoming Empowered; moderated by Rylin Rodgers, Microsoft] View the SABE GoVoter Project Report 1:30-1:45 Break 12:15-1:30 Panel Discussion: Usability Considerations that Can Improve Security and Independence [Tyler Schrenk, the Tyler Schrenk Foundation; Clark Rachfal, American Council of the Blind; Michelle Bishop, MSW, National Disability Rights Network; moderated by Rylin Rodgers, Microsoft] 1:30-1:45 Break Voting Method, Accessibility, and Security Innovations 1:30-2:15 Secure Accessible Voting with ElectionGuard [Aaron Wilson, Enhanced Voting] 2:15-3:00 Implementing End-to-end Verifiability for Vote by Mail [Braden Crimmins, University of Michigan] 3:00-3:45 What's Next? ElectionGuard 2.0 [Michael Naehrig, Microsoft] Friday, August 5: Nerd Day 10:00-2:00 Technical discussions focusing on ElectionGuard 2.0 innovations, implementation options, roadmap, and opensource community View the current agenda for Nerd Day","title":"August 2022 ElectionGuard Hart Verity Scanner and Accessibility Convening"},{"location":"events/eg_usability_aug_2022/#electionguard-hart-verity-scanner-and-usability-convening-august-3-5-2022","text":"","title":"ElectionGuard Hart Verity Scanner and Usability Convening August 3-5, 2022"},{"location":"events/eg_usability_aug_2022/#overview","text":"This convening is a hybrid event that will be held both virtually on Microsoft Teams and in-person at the Microsoft campus in Redmond, Washington. If you would like to join us, please register via this form . All times Pacific Daylight Time (PDT).","title":"Overview"},{"location":"events/eg_usability_aug_2022/#agenda","text":"","title":"Agenda"},{"location":"events/eg_usability_aug_2022/#wednesday-august-3","text":"9:00-9:30 Coffee and breakfast nosh 9:30-9:45 Introductions and Agenda [RC Carter, Microsoft]","title":"Wednesday, August 3"},{"location":"events/eg_usability_aug_2022/#electionguard-hart-verity-precinct-scan-implementation-and-ecosystem","text":"9:45-10:15 What is ElectionGuard and How Does It Work? [RC Carter, Microsoft] 10:15-11:00 An Overview of the ElectionGuard Ecosystem [Josh Benaloh, Microsoft] 11:00-11:10 Break 11:10-11:30 ElectionGuard Integrated Election Setup (Demonstration) [Lee Richardson and Steve Maier, InfernoRed; RC Carter, Microsoft] 11:30-12:30 Implementing End-to-End Verifiability in the Verity Voting System: Lessons in ElectionGuard Integration and the Voting Experience (includes demonstration) [Jim Canter, Eugene Konovalenko, and Drew Tinney, Hart] 12:30-1:30 Lunch and Voting 1:30-1:45 Generating the Election Record (Demonstration) [Lee Richardson and Steve Maier, InfernoRed; RC Carter, Microsoft] 1:45-2:00 Confirmation Code Lookup Site (Demonstration) [Aaron Wilson, Enhanced Voting] 2:00-2:45 Practical ElectionGuard Verifier Implementation (includes Demonstration)[Moses Liskov and Dr. John Ramsdell, MITRE] Dinner in Seattle","title":"ElectionGuard Hart Verity Precinct Scan Implementation and Ecosystem"},{"location":"events/eg_usability_aug_2022/#thursday-august-4","text":"9:00-9:30 Coffee and breakfast nosh","title":"Thursday, August 4"},{"location":"events/eg_usability_aug_2022/#usability-and-accessibility-in-us-elections","text":"9:30-10:15 Ballot Marking Device Verification: Can vs. Do [Mike Byrne, Rice University] Related publication: \"Can Voters Detect Errors on Their Printed Ballots? Absolutely\" Philip Kortum, Michael D. Byrne, Chidera O. Azubike, Laura E. Roty 10:15-11:00 Opportunities for Accessibility Innovation with VVSG 2.0 [Whitney Quesenberry, Center for Civic Design] 11:00-11:10 Break 11:10-12:00 EAC Perspectives on Accessibility, End-to-End Verifiability, and VVSG 2.0 [Thomas Hicks, Election Assistance Commission] 12:00-12:15 Grab lunch and prepare for panel 12:15-1:30 Panel Discussion: Usability Considerations that Can Improve Security and Independence [Tyler Schrenk, the Tyler Schrenk Foundation; Clark Rachfal, American Council of the Blind; Michelle Bishop, MSW, National Disability Rights Network; Diana Mairose, Self Advocates Becoming Empowered; moderated by Rylin Rodgers, Microsoft] View the SABE GoVoter Project Report 1:30-1:45 Break 12:15-1:30 Panel Discussion: Usability Considerations that Can Improve Security and Independence [Tyler Schrenk, the Tyler Schrenk Foundation; Clark Rachfal, American Council of the Blind; Michelle Bishop, MSW, National Disability Rights Network; moderated by Rylin Rodgers, Microsoft] 1:30-1:45 Break","title":"Usability and Accessibility in US Elections"},{"location":"events/eg_usability_aug_2022/#voting-method-accessibility-and-security-innovations","text":"1:30-2:15 Secure Accessible Voting with ElectionGuard [Aaron Wilson, Enhanced Voting] 2:15-3:00 Implementing End-to-end Verifiability for Vote by Mail [Braden Crimmins, University of Michigan] 3:00-3:45 What's Next? ElectionGuard 2.0 [Michael Naehrig, Microsoft]","title":"Voting Method, Accessibility, and Security Innovations"},{"location":"events/eg_usability_aug_2022/#friday-august-5-nerd-day","text":"10:00-2:00 Technical discussions focusing on ElectionGuard 2.0 innovations, implementation options, roadmap, and opensource community View the current agenda for Nerd Day","title":"Friday, August 5: Nerd Day"},{"location":"overview/Features/","text":"Features This serves as a list of features included within the ElectionGuard reference implementations. \ud83d\udee1 End-to-End Verifiability ElectionGuard uses end-to-end verifiable election techniques to enable individual voters to check crucial ingredients of election results. \ud83d\udd10 Ballot Encryption Ballot encryption uses ElGamal encryption to securely encrypt a voter's plaintext ballot. These ballots are then homomorphically added to maintain encryption while creating an aggregate ballot or tally. \u2705 Ballot Confirmation Ballot confirmation allows voters to confirm their ballots were counted. Encrypted ballots provide a ballot code that can be used to verify a vote was submitted and whether it was cast or spoiled. \ud83d\udcdd Challenge Ballots To allow for challenging the system, a spoiled ballot can be submitted for decryption along with the tally. Post election, this allows a voter to both confirm their ballot was not included in the tally and view the plaintext decryption of said ballot. \ud83e\udd0f Compact Ballots Compact ballots assist with smaller machines and ballot encryption by providing a compact format for ballots. This format can be expanded to include all verifiable proofs. \ud83d\udd11 Key Ceremony The key ceremony is provided as a toolset to be perform a ceremony between multiple guardians to generate an encryption key. This key can then be used to encrypt the ballots. \ud83d\udd13 Tally Ceremony The tally ceremony is provided as a toolset to perform a ceremony between multiple guardians to decrypt the tally or election results from an election. This includes quorum decryption when guardians from the key ceremony may be missing.","title":"Features"},{"location":"overview/Features/#features","text":"This serves as a list of features included within the ElectionGuard reference implementations.","title":"Features"},{"location":"overview/Features/#end-to-end-verifiability","text":"ElectionGuard uses end-to-end verifiable election techniques to enable individual voters to check crucial ingredients of election results.","title":"\ud83d\udee1 End-to-End Verifiability"},{"location":"overview/Features/#ballot-encryption","text":"Ballot encryption uses ElGamal encryption to securely encrypt a voter's plaintext ballot. These ballots are then homomorphically added to maintain encryption while creating an aggregate ballot or tally.","title":"\ud83d\udd10 Ballot Encryption"},{"location":"overview/Features/#ballot-confirmation","text":"Ballot confirmation allows voters to confirm their ballots were counted. Encrypted ballots provide a ballot code that can be used to verify a vote was submitted and whether it was cast or spoiled.","title":"\u2705 Ballot Confirmation"},{"location":"overview/Features/#challenge-ballots","text":"To allow for challenging the system, a spoiled ballot can be submitted for decryption along with the tally. Post election, this allows a voter to both confirm their ballot was not included in the tally and view the plaintext decryption of said ballot.","title":"\ud83d\udcdd Challenge Ballots"},{"location":"overview/Features/#compact-ballots","text":"Compact ballots assist with smaller machines and ballot encryption by providing a compact format for ballots. This format can be expanded to include all verifiable proofs.","title":"\ud83e\udd0f Compact Ballots"},{"location":"overview/Features/#key-ceremony","text":"The key ceremony is provided as a toolset to be perform a ceremony between multiple guardians to generate an encryption key. This key can then be used to encrypt the ballots.","title":"\ud83d\udd11 Key Ceremony"},{"location":"overview/Features/#tally-ceremony","text":"The tally ceremony is provided as a toolset to perform a ceremony between multiple guardians to decrypt the tally or election results from an election. This includes quorum decryption when guardians from the key ceremony may be missing.","title":"\ud83d\udd13 Tally Ceremony"},{"location":"overview/Glossary/","text":"ElectionGuard Glossary Overview This glossary is intended to provide terms that are applicable to a variety of audiences: Election administrators - Terms that map to their conception of the voting process and user experience Developers - Provides entities, constructs, and a detailed grammar that allows them to solve problems quickly Cryptographers & election technology contributors - Consistency of usage between the specification and programming code, and sufficiently clear descriptions of the techniques and terms necessary for proper treatment and interpretation of the election record and all processes General public - Clear articulation of the meaning and rationale for the different facets of end-to-end verifiability Info ElectionGuard seeks to keep most terms and meanings consistent the NIST Election Results Common Data Format Specification and the Civics Common Standard Data Specification . These can be helpful additions to this glossary. Terms Utilize the search bar to ease searching for a particular terms. There are \"other terms\" sections to reduce the difficulty to search possible outdated or deprecated terms. approval voting Approval voting is a single-winner electoral system where each voter may choose or approve any number of candidates , and the winner is the single candidate approved by the largest number of voters. Approval voting can be achieved by setting the selection limit to the total number of options in a contest . auxiliary key pair A key pair owned by a specific guardian for encryption to securely send information to other guardians. Other terms: auxiliary keys ballot box A term used to represent collection of submitted ballots in programming code mimicking the physical item. ballot chain If the ballots are encrypted in a particular order by an encryption device , this creates a ballot chain. This can be useful for verification purposes because an inserted or removed ballot can be easily detected as a break in the chain. ballot code A unique hash value generated by an encryption device to anonymously identify a ballot and allow the voter to confirm the ballot has been submitted. code is not to be confused with programming code , but is rather a code to confirm the ballot. Other terms: code, confirmation code, ballot confirmation code, verification code (deprecated) ballot decryption Decrypting a secure encrypted ciphertext ballot to a readable plaintext ballot . graph LR a1(ciphertext ballot) -->|decrypt| a2(plaintext ballot) ballot encryption Encrypting a readable plaintext ballot to a secure encrypted ciphertext ballot . graph LR a1(plaintext ballot) -->|encrypt| a2(cipertext ballot) ballot lifecycle The lifecycle the ballot goes through. For ElectionGuard, the ballot goes from a plaintext ballot to a ciphertext ballot to a submitted ballot and then it is either (1) cast, added to tally or (2) spoiled and decrypted during tally ceremony. candidate A candidate is a choice or option on a contest . This can represent a named a named candidate but also word choices like yes or no. Other terms: choice, option cast ballot A ballot which a voter has submitted as cast to be included in the official election tally . Other terms: cast, casting ciphertext ballot An encrypted representation of a voter's filled-in ballot . Other terms: encrypted ballot ciphertext election context The cryptographic context of an election constructed following the key ceremony . This is a programming concept to coordinate the cryptographic information about the election such as the number of guardians and quorum , and joint key . Other terms: election context, context ciphertext tally A ciphertext tally is the homomorphically-combined and encrypted representation of all selections made for each option on every contest in the election. It is an aggregate of all the encrypted cast ballots in the election. The ciphertext tally is the tally while it is is still in the encrypted state. Other terms: aggregate ciphertext ballot compact ballot A compact ballot is an ElectionGuard term for an encrypted or plaintext ballot that contains only the basic information for a ballot to allow for faster performance and smaller data size. The compact ballot saves space by removing information that can be reconstituted like contest info from the manifest or mathematical proofs. compensated decryption share A partial decryption share value computed by an available guardian to compensate for a missing guardian so that the missing guardian's share can be generated and the tally can be successfully decrypted. contest A contest in an manifest consists of a set of candidates or options together with a selection limit . Contests can be customized to suit the voting experience with options like approval voting , ranked-choice voting and write-ins . Contests can have special rules around selection limits to handle undervotes , overvotes , and null votes . decryption share A guardian's partial share of a ballot decryption or tally decryption . election An election in ElectionGuard is an election as described by a manifest . An election will have one encryption key to encrypt ballots and after tally, will result in an election record . election key pair A key pair owned by a specific guardian for joint encryption in combination with the other guardians to secure the election. Other terms: election keys, guardian key pair, guardian keys election partial key backup A point on a secret election polynomial and commitments to verify this point for a designated guardian. Other terms: backup election partial key verification A guardian's verification that a received election partial key backup is valid to ensure decryption can occur with missing guardians in the tally ceremony. Other terms: backup verification election polynomial The election polynomial is the mathematical expression that each guardian uses for encryption. Each guardian has a polynomial where the first coefficient is used to generate their election key pair . A different point associated with the polynomial is shared with each of the other guardians in the key ceremony so that the guardians can come together and decrypt in the tally ceremony . election record A verifiable record of the public artifacts or files of the election. This includes items like the manifest and the encrypted ballots so an individual or third party can verify the election end-to-end. Other terms: record, election artifacts (deprecated) ElectionGuard Core A programming code base that implements fundamental features of the ElectionGuard Specification (such as ballot encryption) to act as a core or central integration. ElectionGuard Specification The specification indicating how ElectionGuard creates end-to-end verifiable elections. See Specification . ElectionGuard SDK The entire set of repositories associated with ElectionGuard. See Repositories . encryption device A device loaded with the election context that performs ballot encryption . encryption seed The encryption seed is the starting number or point for the encryption. The seed is usually a hash either the starting hash from the encryption device or with a ballot chain the hash from the previous ballot. Other terms: seed hash end-to-end-verifiable election End-to-end verifiable election techniques enable individual voters to check crucial ingredients of election results \u2013 without requiring voters to trust election software, hardware, election officials, procedures, or even observers. Voters may check these ingredients themselves, place their trust in others of their choice (e.g. their preferred candidates, news media, and/or interest groups), or accept the outcome produced with the usual administrative safeguards. 1 An end-to-end verifiable election must include two principle components: Cast as intended - Voters can verify that their own selections have been correctly recorded. Counted as cast - Anyone can verify that the recorded votes have been correctly tallied. guardian One of a number of independent, trustworthy individuals who serve guardians in the election. All guardians must participate in a key ceremony to create a key to encrypt the election and may participate in the accompanying tally ceremony(s) to decrypt the tally(s) . A guardian is available if they are available for the tally ceremony. A guardian is missing if they cannot attend the tally ceremony. Other terms: election guardian, missing guardian, available guardian hash Hashing is a common practice in computing as a mechanism to map data of an arbitrary size into a fixed-size equivalent. ElectionGuard uses hashing in its cryptographic context , This is done for a variety of reasons, including preventing discovery of election ballot contents, but also to verify certain information. For example, a hash of the manifest is added to the ballot which can verify the ballot is using the correct manifest. joint key A public encryption key which is the combination the public key of the election key pair of each of the guardians . This key is created as the last step in the key ceremony . Creating a joint public key as part of the key ceremony graph LR a2 & b2 & c2 --> jk1[key ceremony] --> jk2(joint public key) subgraph eg1[guardian 1] a1(private key) -.- a2(public key) end subgraph eg2[guardian 2] b1(private key) -.- b2(public key) end subgraph eg3[guardian n] c1(private key) -.- c2(public key) end Other terms: joint public key, encryption key, ballot encryption key, elgamal key key ceremony The process conducted at the beginning of the election to create the joint key for ballot encryption during the election. In ElectionGuard, each guardian creates an election key pair and shares a recovery method for their decryption with the other election guardians as part of the key ceremony in case that particular guardian cannot attend the tally ceremony . key pair A key pair consists of a linked private key and public key . Key pairs are used in public key cryptography , in which public keys are distributed to others to encrypt messages that only the private key can decrypt . graph LR subgraph kp[key pair] a1(private key) -.- a2(public key) end manifest The manifest is the information that uniquely specifies and describes the structure and type of the election, including geopolitical units, contests, candidates, ballot styles, etc. In ElectionGuard, it is a file that is created before running an election . The internal manifest is a wrapper around the manifest used in programming code to simplify and avoid processing the same information twice. Unlike the manifest, the internal manifest is not meant for serialization. Other terms: election manifest, election description (deprecated) , internal election description (deprecated) mediator A mediator is used to mediate communication (if needed) of information such as keys between the guardians. This can be a person but in ElectionGuard this often refers to the server mediating / coordinating between the guardian machines that maintains all the public information between the key and tally ceremonies. Other terms: key ceremony mediator, tally mediator nonce An arbitrary number used for cryptographic applications particularly encryption. non-interactive-zero-knowledge proof (NIZK) A non-interactive-zero-knowledge proof (NIZK) is a zero-knowledge proof that can be performed without interaction or intervention by the prover. null vote An null vote occurs when no candidate is selected for a contest . Example: A contest where 2 candidate must be selected and 0 are chosen. overvote An overvote occurs when too many candidates are selected for a contest . Example: A contest where 2 candidate must be selected and 3 are chosen. placeholder A legitimate vote in a contest consists of a set of selections with cardinality not exceeding the selection limit of that contest . To accommodate legitimate undervotes or null votes , the internal representation of a contest in programming code is augmented with \u201cplaceholder\u201d options equal in number to the selection limit. Placeholder options are selected as necessary to force the total number of selections made in a contest to be equal to the selection limit. When the selection limit is one, for example, the single placeholder option can be thought of as a \u201cnone of the above\u201d option. With larger selection limits, the number of placeholder options selected corresponds to the number of additional options that a voter could have selected in a contest. plaintext ballot The plaintext representation of a voter's selections. Other terms: ballot plaintext tally A plaintext tally is the summation of votes for each candidate for each contest in the election. The plaintext tally, or just tally, is the decrypted ciphertext tally or decrypted aggregate ballot which contains the election results. Other terms: aggregate ballot, tally, election results post-election audit A post-election audit verifies that the voting equipment used to count ballots during an election properly counts a sample of voted ballots after an election quorum The minimum count of guardians that must be present in order to successfully decrypt the tally . Other terms: threshold ranked-choice voting (RCV) A ranked-choice voting is an electoral system in which voters rank candidates by preference on their ballots. ElectionGuard does not currently support this. risk-limiting audit (RLA) A risk-limiting audit is a post-election audit that provides strong statistical evidence that the election outcome is correct. RLA has a high probability of correcting a wrong outcome. selection A selection or vote is the selected candidate(s) or option(s) in a contest on a voter's ballot. Other terms: ballot selection, candidate selection, vote selection limit The limit of selections that indicates the number of selections that are allowed to be made in that contest . Most contests have a selection limit of one, but a larger selection limit (e.g., select up to three) is not uncommon in certain elections. sequence order The sequence order is a field used to ensure items such as contests, selections, or guardians are in order for functions that require specific ordering. \"In sequence order\" means ordered by increasing sequence order number. spoiled ballot Spoiling allows a voter to turn in their ballot without their ballot being included in the election tally. A spoiled ballot is a ballot the voter has submitted as spoiled . The voter must submit a replacement ballot as their official cast ballot . In ElectionGuard, ballot spoiling is used as a means for voters to challenge the voting machine and force it to reveal the contents of spoiled ballots for public scrutiny. In this way, a spoiled ballot challenges the system and the term challenge ballot is used. The ballot is spoiled after encryption where the machine cannot modify the ballot. Since the ballot will not be used in the official tally, the content of the ballot can be revealed at the same time as the tally allowing a voter to verify the encryption and decryption process. Other terms: spoil, spoiling, challenge ballot submitted ballot A ballot that is submitted for inclusion in the election and is either: cast or spoiled . graph LR a1(encrypted ballot) -->|cast| a2(submitted ballot) a1 --> |spoiled| a2 Other terms: accepted ballot (deprecated) tally ceremony The process of decrypting the encrypted tally to the decrypted tally . The guardians from the key ceremony who are available attend this ceremony. There must be at least enough guardians to meet the quorum . Each guardian will decrypt their decryption shares and their share for each missing guardian. These shares will then be combined to create the decrypted spoiled ballots and decrypted tally . tally decryption Decrypting an encrypted ciphertext tally to a readable plaintext tally to view results. This is essentially the same concept as ballot decryption . graph LR a1(ciphertext tally) -->|decrypt| a2(plaintext tally) undervote An undervote occurs when too little candidates are selected for a contest . Example: A contest where 2 candidate must be selected and 1 is chosen. Selecting no candidates at all will result in a null vote . unknown ballot An unknown ballot is a submitted ballot which has not been determined to be cast or spoiled , or that may have been spoiled but is otherwise not published in the election results. write-in A write-in is a candidate or option which does not appear on the manifest 's contest . For ElectionGuard, write-ins are assumed to be explicitly registered or allowed to be lumped into a single \"write-ins\" category for the purpose of verifiable tallying. zero-knowledge proof A zero-knowledge proof is a method by which one party (the prover) can prove to another party (the verifier) that they know a value x , without conveying any information apart from the fact that they know the value x . The essence of zero-knowledge proofs is that it is trivial to prove that one possesses knowledge of certain information by simply revealing it; the challenge is to prove such possession without revealing the information itself or any additional information. 2 End-to-end verifiability \u21a9 Zero-Knowledge Proof from Wikipedia \u21a9","title":"Glossary"},{"location":"overview/Glossary/#electionguard-glossary","text":"","title":"ElectionGuard Glossary"},{"location":"overview/Glossary/#overview","text":"This glossary is intended to provide terms that are applicable to a variety of audiences: Election administrators - Terms that map to their conception of the voting process and user experience Developers - Provides entities, constructs, and a detailed grammar that allows them to solve problems quickly Cryptographers & election technology contributors - Consistency of usage between the specification and programming code, and sufficiently clear descriptions of the techniques and terms necessary for proper treatment and interpretation of the election record and all processes General public - Clear articulation of the meaning and rationale for the different facets of end-to-end verifiability Info ElectionGuard seeks to keep most terms and meanings consistent the NIST Election Results Common Data Format Specification and the Civics Common Standard Data Specification . These can be helpful additions to this glossary.","title":"Overview"},{"location":"overview/Glossary/#terms","text":"Utilize the search bar to ease searching for a particular terms. There are \"other terms\" sections to reduce the difficulty to search possible outdated or deprecated terms.","title":"Terms"},{"location":"overview/Glossary/#approval-voting","text":"Approval voting is a single-winner electoral system where each voter may choose or approve any number of candidates , and the winner is the single candidate approved by the largest number of voters. Approval voting can be achieved by setting the selection limit to the total number of options in a contest .","title":"approval voting"},{"location":"overview/Glossary/#auxiliary-key-pair","text":"A key pair owned by a specific guardian for encryption to securely send information to other guardians.","title":"auxiliary key pair"},{"location":"overview/Glossary/#other-terms-auxiliary-keys","text":"","title":"Other terms: auxiliary keys"},{"location":"overview/Glossary/#ballot-box","text":"A term used to represent collection of submitted ballots in programming code mimicking the physical item.","title":"ballot box"},{"location":"overview/Glossary/#ballot-chain","text":"If the ballots are encrypted in a particular order by an encryption device , this creates a ballot chain. This can be useful for verification purposes because an inserted or removed ballot can be easily detected as a break in the chain.","title":"ballot chain"},{"location":"overview/Glossary/#ballot-code","text":"A unique hash value generated by an encryption device to anonymously identify a ballot and allow the voter to confirm the ballot has been submitted. code is not to be confused with programming code , but is rather a code to confirm the ballot.","title":"ballot code"},{"location":"overview/Glossary/#other-terms-code-confirmation-code-ballot-confirmation-code-verification-code-deprecated","text":"","title":"Other terms: code, confirmation code, ballot confirmation code, verification code (deprecated)"},{"location":"overview/Glossary/#ballot-decryption","text":"Decrypting a secure encrypted ciphertext ballot to a readable plaintext ballot . graph LR a1(ciphertext ballot) -->|decrypt| a2(plaintext ballot)","title":"ballot decryption"},{"location":"overview/Glossary/#ballot-encryption","text":"Encrypting a readable plaintext ballot to a secure encrypted ciphertext ballot . graph LR a1(plaintext ballot) -->|encrypt| a2(cipertext ballot)","title":"ballot encryption"},{"location":"overview/Glossary/#ballot-lifecycle","text":"The lifecycle the ballot goes through. For ElectionGuard, the ballot goes from a plaintext ballot to a ciphertext ballot to a submitted ballot and then it is either (1) cast, added to tally or (2) spoiled and decrypted during tally ceremony.","title":"ballot lifecycle"},{"location":"overview/Glossary/#candidate","text":"A candidate is a choice or option on a contest . This can represent a named a named candidate but also word choices like yes or no.","title":"candidate"},{"location":"overview/Glossary/#other-terms-choice-option","text":"","title":"Other terms: choice, option"},{"location":"overview/Glossary/#cast-ballot","text":"A ballot which a voter has submitted as cast to be included in the official election tally .","title":"cast ballot"},{"location":"overview/Glossary/#other-terms-cast-casting","text":"","title":"Other terms: cast, casting"},{"location":"overview/Glossary/#ciphertext-ballot","text":"An encrypted representation of a voter's filled-in ballot .","title":"ciphertext ballot"},{"location":"overview/Glossary/#other-terms-encrypted-ballot","text":"","title":"Other terms: encrypted ballot"},{"location":"overview/Glossary/#ciphertext-election-context","text":"The cryptographic context of an election constructed following the key ceremony . This is a programming concept to coordinate the cryptographic information about the election such as the number of guardians and quorum , and joint key .","title":"ciphertext election context"},{"location":"overview/Glossary/#other-terms-election-context-context","text":"","title":"Other terms: election context, context"},{"location":"overview/Glossary/#ciphertext-tally","text":"A ciphertext tally is the homomorphically-combined and encrypted representation of all selections made for each option on every contest in the election. It is an aggregate of all the encrypted cast ballots in the election. The ciphertext tally is the tally while it is is still in the encrypted state.","title":"ciphertext tally"},{"location":"overview/Glossary/#other-terms-aggregate-ciphertext-ballot","text":"","title":"Other terms: aggregate ciphertext ballot"},{"location":"overview/Glossary/#compact-ballot","text":"A compact ballot is an ElectionGuard term for an encrypted or plaintext ballot that contains only the basic information for a ballot to allow for faster performance and smaller data size. The compact ballot saves space by removing information that can be reconstituted like contest info from the manifest or mathematical proofs.","title":"compact ballot"},{"location":"overview/Glossary/#compensated-decryption-share","text":"A partial decryption share value computed by an available guardian to compensate for a missing guardian so that the missing guardian's share can be generated and the tally can be successfully decrypted.","title":"compensated decryption share"},{"location":"overview/Glossary/#contest","text":"A contest in an manifest consists of a set of candidates or options together with a selection limit . Contests can be customized to suit the voting experience with options like approval voting , ranked-choice voting and write-ins . Contests can have special rules around selection limits to handle undervotes , overvotes , and null votes .","title":"contest"},{"location":"overview/Glossary/#decryption-share","text":"A guardian's partial share of a ballot decryption or tally decryption .","title":"decryption share"},{"location":"overview/Glossary/#election","text":"An election in ElectionGuard is an election as described by a manifest . An election will have one encryption key to encrypt ballots and after tally, will result in an election record .","title":"election"},{"location":"overview/Glossary/#election-key-pair","text":"A key pair owned by a specific guardian for joint encryption in combination with the other guardians to secure the election.","title":"election key pair"},{"location":"overview/Glossary/#other-terms-election-keys-guardian-key-pair-guardian-keys","text":"","title":"Other terms: election keys, guardian key pair, guardian keys"},{"location":"overview/Glossary/#election-partial-key-backup","text":"A point on a secret election polynomial and commitments to verify this point for a designated guardian.","title":"election partial key backup"},{"location":"overview/Glossary/#other-terms-backup","text":"","title":"Other terms: backup"},{"location":"overview/Glossary/#election-partial-key-verification","text":"A guardian's verification that a received election partial key backup is valid to ensure decryption can occur with missing guardians in the tally ceremony.","title":"election partial key verification"},{"location":"overview/Glossary/#other-terms-backup-verification","text":"","title":"Other terms: backup verification"},{"location":"overview/Glossary/#election-polynomial","text":"The election polynomial is the mathematical expression that each guardian uses for encryption. Each guardian has a polynomial where the first coefficient is used to generate their election key pair . A different point associated with the polynomial is shared with each of the other guardians in the key ceremony so that the guardians can come together and decrypt in the tally ceremony .","title":"election polynomial"},{"location":"overview/Glossary/#election-record","text":"A verifiable record of the public artifacts or files of the election. This includes items like the manifest and the encrypted ballots so an individual or third party can verify the election end-to-end.","title":"election record"},{"location":"overview/Glossary/#other-terms-record-election-artifacts-deprecated","text":"","title":"Other terms: record, election artifacts (deprecated)"},{"location":"overview/Glossary/#electionguard-core","text":"A programming code base that implements fundamental features of the ElectionGuard Specification (such as ballot encryption) to act as a core or central integration.","title":"ElectionGuard Core"},{"location":"overview/Glossary/#electionguard-specification","text":"The specification indicating how ElectionGuard creates end-to-end verifiable elections. See Specification .","title":"ElectionGuard Specification"},{"location":"overview/Glossary/#electionguard-sdk","text":"The entire set of repositories associated with ElectionGuard. See Repositories .","title":"ElectionGuard SDK"},{"location":"overview/Glossary/#encryption-device","text":"A device loaded with the election context that performs ballot encryption .","title":"encryption device"},{"location":"overview/Glossary/#encryption-seed","text":"The encryption seed is the starting number or point for the encryption. The seed is usually a hash either the starting hash from the encryption device or with a ballot chain the hash from the previous ballot.","title":"encryption seed"},{"location":"overview/Glossary/#other-terms-seed-hash","text":"","title":"Other terms: seed hash"},{"location":"overview/Glossary/#end-to-end-verifiable-election","text":"End-to-end verifiable election techniques enable individual voters to check crucial ingredients of election results \u2013 without requiring voters to trust election software, hardware, election officials, procedures, or even observers. Voters may check these ingredients themselves, place their trust in others of their choice (e.g. their preferred candidates, news media, and/or interest groups), or accept the outcome produced with the usual administrative safeguards. 1 An end-to-end verifiable election must include two principle components: Cast as intended - Voters can verify that their own selections have been correctly recorded. Counted as cast - Anyone can verify that the recorded votes have been correctly tallied.","title":"end-to-end-verifiable election"},{"location":"overview/Glossary/#guardian","text":"One of a number of independent, trustworthy individuals who serve guardians in the election. All guardians must participate in a key ceremony to create a key to encrypt the election and may participate in the accompanying tally ceremony(s) to decrypt the tally(s) . A guardian is available if they are available for the tally ceremony. A guardian is missing if they cannot attend the tally ceremony.","title":"guardian"},{"location":"overview/Glossary/#other-terms-election-guardian-missing-guardian-available-guardian","text":"","title":"Other terms: election guardian, missing guardian, available guardian"},{"location":"overview/Glossary/#hash","text":"Hashing is a common practice in computing as a mechanism to map data of an arbitrary size into a fixed-size equivalent. ElectionGuard uses hashing in its cryptographic context , This is done for a variety of reasons, including preventing discovery of election ballot contents, but also to verify certain information. For example, a hash of the manifest is added to the ballot which can verify the ballot is using the correct manifest.","title":"hash"},{"location":"overview/Glossary/#joint-key","text":"A public encryption key which is the combination the public key of the election key pair of each of the guardians . This key is created as the last step in the key ceremony . Creating a joint public key as part of the key ceremony graph LR a2 & b2 & c2 --> jk1[key ceremony] --> jk2(joint public key) subgraph eg1[guardian 1] a1(private key) -.- a2(public key) end subgraph eg2[guardian 2] b1(private key) -.- b2(public key) end subgraph eg3[guardian n] c1(private key) -.- c2(public key) end","title":"joint key"},{"location":"overview/Glossary/#other-terms-joint-public-key-encryption-key-ballot-encryption-key-elgamal-key","text":"","title":"Other terms: joint public key, encryption key, ballot encryption key, elgamal key"},{"location":"overview/Glossary/#key-ceremony","text":"The process conducted at the beginning of the election to create the joint key for ballot encryption during the election. In ElectionGuard, each guardian creates an election key pair and shares a recovery method for their decryption with the other election guardians as part of the key ceremony in case that particular guardian cannot attend the tally ceremony .","title":"key ceremony"},{"location":"overview/Glossary/#key-pair","text":"A key pair consists of a linked private key and public key . Key pairs are used in public key cryptography , in which public keys are distributed to others to encrypt messages that only the private key can decrypt . graph LR subgraph kp[key pair] a1(private key) -.- a2(public key) end","title":"key pair"},{"location":"overview/Glossary/#manifest","text":"The manifest is the information that uniquely specifies and describes the structure and type of the election, including geopolitical units, contests, candidates, ballot styles, etc. In ElectionGuard, it is a file that is created before running an election . The internal manifest is a wrapper around the manifest used in programming code to simplify and avoid processing the same information twice. Unlike the manifest, the internal manifest is not meant for serialization.","title":"manifest"},{"location":"overview/Glossary/#other-terms-election-manifest-election-description-deprecated-internal-election-description-deprecated","text":"","title":"Other terms: election manifest, election description (deprecated), internal election description (deprecated)"},{"location":"overview/Glossary/#mediator","text":"A mediator is used to mediate communication (if needed) of information such as keys between the guardians. This can be a person but in ElectionGuard this often refers to the server mediating / coordinating between the guardian machines that maintains all the public information between the key and tally ceremonies.","title":"mediator"},{"location":"overview/Glossary/#other-terms-key-ceremony-mediator-tally-mediator","text":"","title":"Other terms: key ceremony mediator, tally mediator"},{"location":"overview/Glossary/#nonce","text":"An arbitrary number used for cryptographic applications particularly encryption.","title":"nonce"},{"location":"overview/Glossary/#non-interactive-zero-knowledge-proof-nizk","text":"A non-interactive-zero-knowledge proof (NIZK) is a zero-knowledge proof that can be performed without interaction or intervention by the prover.","title":"non-interactive-zero-knowledge proof (NIZK)"},{"location":"overview/Glossary/#null-vote","text":"An null vote occurs when no candidate is selected for a contest . Example: A contest where 2 candidate must be selected and 0 are chosen.","title":"null vote"},{"location":"overview/Glossary/#overvote","text":"An overvote occurs when too many candidates are selected for a contest . Example: A contest where 2 candidate must be selected and 3 are chosen.","title":"overvote"},{"location":"overview/Glossary/#placeholder","text":"A legitimate vote in a contest consists of a set of selections with cardinality not exceeding the selection limit of that contest . To accommodate legitimate undervotes or null votes , the internal representation of a contest in programming code is augmented with \u201cplaceholder\u201d options equal in number to the selection limit. Placeholder options are selected as necessary to force the total number of selections made in a contest to be equal to the selection limit. When the selection limit is one, for example, the single placeholder option can be thought of as a \u201cnone of the above\u201d option. With larger selection limits, the number of placeholder options selected corresponds to the number of additional options that a voter could have selected in a contest.","title":"placeholder"},{"location":"overview/Glossary/#plaintext-ballot","text":"The plaintext representation of a voter's selections.","title":"plaintext ballot"},{"location":"overview/Glossary/#other-terms-ballot","text":"","title":"Other terms: ballot"},{"location":"overview/Glossary/#plaintext-tally","text":"A plaintext tally is the summation of votes for each candidate for each contest in the election. The plaintext tally, or just tally, is the decrypted ciphertext tally or decrypted aggregate ballot which contains the election results.","title":"plaintext tally"},{"location":"overview/Glossary/#other-terms-aggregate-ballot-tally-election-results","text":"","title":"Other terms: aggregate ballot, tally, election results"},{"location":"overview/Glossary/#post-election-audit","text":"A post-election audit verifies that the voting equipment used to count ballots during an election properly counts a sample of voted ballots after an election","title":"post-election audit"},{"location":"overview/Glossary/#quorum","text":"The minimum count of guardians that must be present in order to successfully decrypt the tally .","title":"quorum"},{"location":"overview/Glossary/#other-terms-threshold","text":"","title":"Other terms: threshold"},{"location":"overview/Glossary/#ranked-choice-voting-rcv","text":"A ranked-choice voting is an electoral system in which voters rank candidates by preference on their ballots. ElectionGuard does not currently support this.","title":"ranked-choice voting (RCV)"},{"location":"overview/Glossary/#risk-limiting-audit-rla","text":"A risk-limiting audit is a post-election audit that provides strong statistical evidence that the election outcome is correct. RLA has a high probability of correcting a wrong outcome.","title":"risk-limiting audit (RLA)"},{"location":"overview/Glossary/#selection","text":"A selection or vote is the selected candidate(s) or option(s) in a contest on a voter's ballot.","title":"selection"},{"location":"overview/Glossary/#other-terms-ballot-selection-candidate-selection-vote","text":"","title":"Other terms: ballot selection, candidate selection, vote"},{"location":"overview/Glossary/#selection-limit","text":"The limit of selections that indicates the number of selections that are allowed to be made in that contest . Most contests have a selection limit of one, but a larger selection limit (e.g., select up to three) is not uncommon in certain elections.","title":"selection limit"},{"location":"overview/Glossary/#sequence-order","text":"The sequence order is a field used to ensure items such as contests, selections, or guardians are in order for functions that require specific ordering. \"In sequence order\" means ordered by increasing sequence order number.","title":"sequence order"},{"location":"overview/Glossary/#spoiled-ballot","text":"Spoiling allows a voter to turn in their ballot without their ballot being included in the election tally. A spoiled ballot is a ballot the voter has submitted as spoiled . The voter must submit a replacement ballot as their official cast ballot . In ElectionGuard, ballot spoiling is used as a means for voters to challenge the voting machine and force it to reveal the contents of spoiled ballots for public scrutiny. In this way, a spoiled ballot challenges the system and the term challenge ballot is used. The ballot is spoiled after encryption where the machine cannot modify the ballot. Since the ballot will not be used in the official tally, the content of the ballot can be revealed at the same time as the tally allowing a voter to verify the encryption and decryption process.","title":"spoiled ballot"},{"location":"overview/Glossary/#other-terms-spoil-spoiling-challenge-ballot","text":"","title":"Other terms: spoil, spoiling, challenge ballot"},{"location":"overview/Glossary/#submitted-ballot","text":"A ballot that is submitted for inclusion in the election and is either: cast or spoiled . graph LR a1(encrypted ballot) -->|cast| a2(submitted ballot) a1 --> |spoiled| a2","title":"submitted ballot"},{"location":"overview/Glossary/#other-terms-accepted-ballot-deprecated","text":"","title":"Other terms: accepted ballot (deprecated)"},{"location":"overview/Glossary/#tally-ceremony","text":"The process of decrypting the encrypted tally to the decrypted tally . The guardians from the key ceremony who are available attend this ceremony. There must be at least enough guardians to meet the quorum . Each guardian will decrypt their decryption shares and their share for each missing guardian. These shares will then be combined to create the decrypted spoiled ballots and decrypted tally .","title":"tally ceremony"},{"location":"overview/Glossary/#tally-decryption","text":"Decrypting an encrypted ciphertext tally to a readable plaintext tally to view results. This is essentially the same concept as ballot decryption . graph LR a1(ciphertext tally) -->|decrypt| a2(plaintext tally)","title":"tally decryption"},{"location":"overview/Glossary/#undervote","text":"An undervote occurs when too little candidates are selected for a contest . Example: A contest where 2 candidate must be selected and 1 is chosen. Selecting no candidates at all will result in a null vote .","title":"undervote"},{"location":"overview/Glossary/#unknown-ballot","text":"An unknown ballot is a submitted ballot which has not been determined to be cast or spoiled , or that may have been spoiled but is otherwise not published in the election results.","title":"unknown ballot"},{"location":"overview/Glossary/#write-in","text":"A write-in is a candidate or option which does not appear on the manifest 's contest . For ElectionGuard, write-ins are assumed to be explicitly registered or allowed to be lumped into a single \"write-ins\" category for the purpose of verifiable tallying.","title":"write-in"},{"location":"overview/Glossary/#zero-knowledge-proof","text":"A zero-knowledge proof is a method by which one party (the prover) can prove to another party (the verifier) that they know a value x , without conveying any information apart from the fact that they know the value x . The essence of zero-knowledge proofs is that it is trivial to prove that one possesses knowledge of certain information by simply revealing it; the challenge is to prove such possession without revealing the information itself or any additional information. 2 End-to-end verifiability \u21a9 Zero-Knowledge Proof from Wikipedia \u21a9","title":"zero-knowledge proof"},{"location":"overview/Roadmap/","text":"ElectionGuard Roadmap 2021 Roadmap The 2021 roadmap takes lessons learned from the deployment of applications during 2020 and rationalizes them into a practice to establish with the community in 2021. The goal is to grow a community of participants and contributors within which Microsoft takes part and provides architectural and implementation guidance, but is fundamentally driven by the needs of the community in establishing the best ways to implement end-to-end verifiable elections and post-election audits. A big step toward this new vision occurred with the release of the electionguard-cpp ballot-encryption repo. The electionguard-python repo implements the full suite of ElectionGuard SDK functionality and the base electionguard specification and documentation repo provides the foundation for future development. The goal for the first half of 2021 is to have a full suite of code, tests, workflows, and package deployments more directly associated with the conventions and requirements indicated by the specification. The goal is also to publish and generate more comprehensive and also more granular examples and use cases to enable easier and more focused contributions by the community. 1.0 Specification a final, fully-developed specification integrated directly into the SDK; updates to election manifest and election artifact descriptions and specifications a more modular approach to documentation and contribution to lessen the learning curve and overhead necessary to participate and contribute more prescriptive guidance on verifier construction C++ ballot encryption library repo that performs encryption exclusively (for embedded encryption applications such as precinct scanners) standalone source that uses a version of HACL* packaged up by EverCrypt for high assurance (thank you EverCrypt team!) enables ElectionGuard to eliminate GMP as a dependency Release an ElectionGuard.Encryption nuget package built from electionguard-cpp as a ballot encrypter for low performance devices Establish publishing pattern First target will be Windows 10 / UWP A consistent, efficient set of data interfaces across the ElectionGuard, C++, and Python repos Data serialization using Protobuf for input/output/data consistency across electionguard-cpp and electionguard-python Restructuring ballot and device aggregation to better support audits and scalability in general Renaming and refactoring all repos for more descriptive and specific naming patterns Compose community changes into electionguard-python release v1.1.16 Optimization changes for service implementations of electionguard-python release v1.4.0 Introduce service docker containers in electionguard-api 2020 In Review 2020 provided many lessons. During the first half of the year ElectionGuard was used successfully as a Pilot in Fulton, WI with the help of VotingWorks and InfernoRed . Subsequent to the pilot ElectionGuard released the Python repo as a new reference implementation. In the second half of the year , responding to COVID, led to the development of a remote voting app with InfernoRed , Markup , and the US House Democratic Caucus to enable representatives to vote by secret ballot safely, securely, and remotely for Caucus leadership positions . In a further collaborate with VotingWorks, Rice University professor Dan Wallach contributed an integration with Arlo to enable ElectionGuard to provide the \"back end\" for Inyo County's Risk-limiting Audit of the November 3 election . Last, and definitely not least, ElectionGuard developed and published its first independent verifiers . 2020 Roadmap Use ElectionGuard in a real-world end-to-end verifiable election Run a verifiable election Fulton, Wisconsin with VotingWorks using smart cards, a ballot box, an admin device, and a ballot tracking site. Integrate ElectionGuard with the VotingWorks print station and user flow Build ballot box functionality to capture and seal ballots Build admin device to enable tallies and key ceremonies Build tracking site to enable verification code lookup and tally/results download Use ElectionGuard in a real-world post-election audit Run a post-election election audit with Inyo, California using VotingWorks Arlo using ElectionGuard as a back end Identify learnings and code refactoring necessary to reflect the different data structures and scalability considerations of audits Update the ElectionGuard Specification to 1.0.0-preview-1 Support building ElectionGuard into additional voting systems Enable remote, secret-ballot voting for Democratic Caucus of the US House of Representatives Work with InfernoRed and Markup to enable House-distributed iPhones to perform ballot encryption and House Democratic leadership to schedule and tally secret-ballot elections for leadership and committee positions Release and iterate on electionguard-python as a core implementation that meets specification 1.0.0-preview-1 Implement a canonical library addressing all ElectionGuard SDK functionality: Key generation Ballot encryption Ballot sealing Tally generation Verifier specification Build library with an eye to extensibility rather than performance and local language optimization (i.e., we'll be less Pythonic than some might prefer for the base implementation) Integrate ElectionGuard into a set of election tools 2019 Roadmap Initial specification and electionguard-c release Demonstrate ElectionGuard Reference Implementation at Aspen Security Conference","title":"Roadmap"},{"location":"overview/Roadmap/#electionguard-roadmap","text":"","title":"ElectionGuard Roadmap"},{"location":"overview/Roadmap/#2021-roadmap","text":"The 2021 roadmap takes lessons learned from the deployment of applications during 2020 and rationalizes them into a practice to establish with the community in 2021. The goal is to grow a community of participants and contributors within which Microsoft takes part and provides architectural and implementation guidance, but is fundamentally driven by the needs of the community in establishing the best ways to implement end-to-end verifiable elections and post-election audits. A big step toward this new vision occurred with the release of the electionguard-cpp ballot-encryption repo. The electionguard-python repo implements the full suite of ElectionGuard SDK functionality and the base electionguard specification and documentation repo provides the foundation for future development. The goal for the first half of 2021 is to have a full suite of code, tests, workflows, and package deployments more directly associated with the conventions and requirements indicated by the specification. The goal is also to publish and generate more comprehensive and also more granular examples and use cases to enable easier and more focused contributions by the community. 1.0 Specification a final, fully-developed specification integrated directly into the SDK; updates to election manifest and election artifact descriptions and specifications a more modular approach to documentation and contribution to lessen the learning curve and overhead necessary to participate and contribute more prescriptive guidance on verifier construction C++ ballot encryption library repo that performs encryption exclusively (for embedded encryption applications such as precinct scanners) standalone source that uses a version of HACL* packaged up by EverCrypt for high assurance (thank you EverCrypt team!) enables ElectionGuard to eliminate GMP as a dependency Release an ElectionGuard.Encryption nuget package built from electionguard-cpp as a ballot encrypter for low performance devices Establish publishing pattern First target will be Windows 10 / UWP A consistent, efficient set of data interfaces across the ElectionGuard, C++, and Python repos Data serialization using Protobuf for input/output/data consistency across electionguard-cpp and electionguard-python Restructuring ballot and device aggregation to better support audits and scalability in general Renaming and refactoring all repos for more descriptive and specific naming patterns Compose community changes into electionguard-python release v1.1.16 Optimization changes for service implementations of electionguard-python release v1.4.0 Introduce service docker containers in electionguard-api","title":"2021 Roadmap"},{"location":"overview/Roadmap/#2020-in-review","text":"2020 provided many lessons. During the first half of the year ElectionGuard was used successfully as a Pilot in Fulton, WI with the help of VotingWorks and InfernoRed . Subsequent to the pilot ElectionGuard released the Python repo as a new reference implementation. In the second half of the year , responding to COVID, led to the development of a remote voting app with InfernoRed , Markup , and the US House Democratic Caucus to enable representatives to vote by secret ballot safely, securely, and remotely for Caucus leadership positions . In a further collaborate with VotingWorks, Rice University professor Dan Wallach contributed an integration with Arlo to enable ElectionGuard to provide the \"back end\" for Inyo County's Risk-limiting Audit of the November 3 election . Last, and definitely not least, ElectionGuard developed and published its first independent verifiers .","title":"2020 In Review"},{"location":"overview/Roadmap/#2020-roadmap","text":"Use ElectionGuard in a real-world end-to-end verifiable election Run a verifiable election Fulton, Wisconsin with VotingWorks using smart cards, a ballot box, an admin device, and a ballot tracking site. Integrate ElectionGuard with the VotingWorks print station and user flow Build ballot box functionality to capture and seal ballots Build admin device to enable tallies and key ceremonies Build tracking site to enable verification code lookup and tally/results download Use ElectionGuard in a real-world post-election audit Run a post-election election audit with Inyo, California using VotingWorks Arlo using ElectionGuard as a back end Identify learnings and code refactoring necessary to reflect the different data structures and scalability considerations of audits Update the ElectionGuard Specification to 1.0.0-preview-1 Support building ElectionGuard into additional voting systems Enable remote, secret-ballot voting for Democratic Caucus of the US House of Representatives Work with InfernoRed and Markup to enable House-distributed iPhones to perform ballot encryption and House Democratic leadership to schedule and tally secret-ballot elections for leadership and committee positions Release and iterate on electionguard-python as a core implementation that meets specification 1.0.0-preview-1 Implement a canonical library addressing all ElectionGuard SDK functionality: Key generation Ballot encryption Ballot sealing Tally generation Verifier specification Build library with an eye to extensibility rather than performance and local language optimization (i.e., we'll be less Pythonic than some might prefer for the base implementation) Integrate ElectionGuard into a set of election tools","title":"2020 Roadmap"},{"location":"overview/Roadmap/#2019-roadmap","text":"Initial specification and electionguard-c release Demonstrate ElectionGuard Reference Implementation at Aspen Security Conference","title":"2019 Roadmap"},{"location":"spec/","text":"ElectionGuard Official Specifications The official versions of the ElectionGuard Specifications are listed below and stand as the primary source of reference when discussing the ElectionGuard Specification . Each version includes a badge that can be used to quickly display which versions are supported or used by products following the specification. To follow along with the code versioning, see the versioning . Version Specification Recommended Badge 2.0 Unreleased 1.0 Download 0.95 Download 0.85 Download Release Notes v1.0 Updates from previous version The large prime p and corresponding cofactor r were changed to correctly match the result of the process for the derivation of the prime. The equations for generating proofs of ballot correctness have been optimized. Auxiliary keys have been eliminated in favor of using the existing keys for both ordinary and exponential ElGamal encryption. A more flexible structure of ballot chaining has been introduced to allow for non-linear chaining or no chaining at all. Smaller parameters suitable for testing are included. The election record of this version should match that of the prior v0.95 and therefore require no verifier changes (with the exception of using the corrected prime). v0.95 Updates from previous version The large prime p and corresponding cofactor r were changed to move the prime p further from 2^4096. A section specifically about writing verifiers was added. Various small clarifications and corrections were included. v0.85 Initial public release of specification for ElectionGuard ElectionGuard Web Specification The web version is being constructed by the open source community for the convenience of web viewing. However, it is incomplete at this time and should not be used for reference purposes. If you need a complete reference, refer to the official specifications.","title":"Official"},{"location":"spec/#electionguard-official-specifications","text":"The official versions of the ElectionGuard Specifications are listed below and stand as the primary source of reference when discussing the ElectionGuard Specification . Each version includes a badge that can be used to quickly display which versions are supported or used by products following the specification. To follow along with the code versioning, see the versioning . Version Specification Recommended Badge 2.0 Unreleased 1.0 Download 0.95 Download 0.85 Download","title":"ElectionGuard Official Specifications"},{"location":"spec/#release-notes","text":"","title":"Release Notes"},{"location":"spec/#v10","text":"Updates from previous version The large prime p and corresponding cofactor r were changed to correctly match the result of the process for the derivation of the prime. The equations for generating proofs of ballot correctness have been optimized. Auxiliary keys have been eliminated in favor of using the existing keys for both ordinary and exponential ElGamal encryption. A more flexible structure of ballot chaining has been introduced to allow for non-linear chaining or no chaining at all. Smaller parameters suitable for testing are included. The election record of this version should match that of the prior v0.95 and therefore require no verifier changes (with the exception of using the corrected prime).","title":"v1.0"},{"location":"spec/#v095","text":"Updates from previous version The large prime p and corresponding cofactor r were changed to move the prime p further from 2^4096. A section specifically about writing verifiers was added. Various small clarifications and corrections were included.","title":"v0.95"},{"location":"spec/#v085","text":"Initial public release of specification for ElectionGuard ElectionGuard Web Specification The web version is being constructed by the open source community for the convenience of web viewing. However, it is incomplete at this time and should not be used for reference purposes. If you need a complete reference, refer to the official specifications.","title":"v0.85"},{"location":"spec/web/11_Applications/","text":"Applications to end-to-end verifiability and risk-limiting audits The methods described in this specification can be used to enable either end-to-end (E2E) verifiability or enhanced risk-limiting audits (RLAs). In both cases, the ballots are individually encrypted and proofs are provided to allow observers to verify that the set of encrypted ballots is consistent with the announced tallies in an election. In the case of E2E-verifiability, voters are given tracking codes to enable them to confirm that their individual ballots are correctly recorded amongst the set of encrypted ballots. In the case of RLAs, encrypted ballots are randomly selected and compared against physical ballots to obtain confidence that the physical records match the electronic records. To support enhanced risk-limiting audits (RLAs), it may be desirable to encrypt the master nonce of each ballot with a simple administrative key rather than the \u201cheavyweight\u201d election encryption key. This streamlines the process for decrypting an encrypted ballot that has been selected for audit. It should be noted that the privacy risks of revealing decrypted ballots are substantially reduced in the RLA case since voters are not given tracking codes that could be used to associate them with individual ballots. The primary risk is a coercion threat (e.g., via pattern voting) that only manifests if the full set of ballots were to be decrypted. While the administratively encrypted nonce can be stored in an electronic record alongside each encrypted ballot, one appealing RLA instantiation is for the administrative encryption of a ballot\u2019s nonce to be printed directly onto the physical ballot. This allows an RLA to proceed by randomly selecting an encrypted ballot, fetching the associated physical ballot, extracting the nonce from its encryption on the physical ballot, using the nonce to decrypt the electronic record, and then comparing the physical ballot contents with those of the electronic record. A malicious actor with an administrative decryption key would need to go to each individual physical ballot to obtain the nonces necessary to decrypt all of the encrypted ballots, and the access to do so would enable this malicious actor to obtain all of the open ballots without necessitating the administrative decryption key. If E2E-verifiability and enhanced RLAs are both provided in the same election, there must be separate ballot encryptions (ideally, but not necessary, using separate election encryption keys) of each ballot. The E2E-verifiable data set must be distinguished from the enhanced RLA data set. Using the same data set for both applications would compromise voter privacy for voters whose ballots are selected for auditing.","title":"Applications"},{"location":"spec/web/11_Applications/#applications-to-end-to-end-verifiability-and-risk-limiting-audits","text":"The methods described in this specification can be used to enable either end-to-end (E2E) verifiability or enhanced risk-limiting audits (RLAs). In both cases, the ballots are individually encrypted and proofs are provided to allow observers to verify that the set of encrypted ballots is consistent with the announced tallies in an election. In the case of E2E-verifiability, voters are given tracking codes to enable them to confirm that their individual ballots are correctly recorded amongst the set of encrypted ballots. In the case of RLAs, encrypted ballots are randomly selected and compared against physical ballots to obtain confidence that the physical records match the electronic records. To support enhanced risk-limiting audits (RLAs), it may be desirable to encrypt the master nonce of each ballot with a simple administrative key rather than the \u201cheavyweight\u201d election encryption key. This streamlines the process for decrypting an encrypted ballot that has been selected for audit. It should be noted that the privacy risks of revealing decrypted ballots are substantially reduced in the RLA case since voters are not given tracking codes that could be used to associate them with individual ballots. The primary risk is a coercion threat (e.g., via pattern voting) that only manifests if the full set of ballots were to be decrypted. While the administratively encrypted nonce can be stored in an electronic record alongside each encrypted ballot, one appealing RLA instantiation is for the administrative encryption of a ballot\u2019s nonce to be printed directly onto the physical ballot. This allows an RLA to proceed by randomly selecting an encrypted ballot, fetching the associated physical ballot, extracting the nonce from its encryption on the physical ballot, using the nonce to decrypt the electronic record, and then comparing the physical ballot contents with those of the electronic record. A malicious actor with an administrative decryption key would need to go to each individual physical ballot to obtain the nonces necessary to decrypt all of the encrypted ballots, and the access to do so would enable this malicious actor to obtain all of the open ballots without necessitating the administrative decryption key. If E2E-verifiability and enhanced RLAs are both provided in the same election, there must be separate ballot encryptions (ideally, but not necessary, using separate election encryption keys) of each ballot. The E2E-verifiable data set must be distinguished from the enhanced RLA data set. Using the same data set for both applications would compromise voter privacy for voters whose ballots are selected for auditing.","title":"Applications to end-to-end verifiability and risk-limiting audits"},{"location":"spec/web/12_Acknowledgements/","text":"Acknowledgements The author is happy to thank Nicholas Boucher, Joey Dodds, Gerald Doussot, Aleks Essex, Rainbow Huang, Chris Jeuell, Luke Myers, Dan Shumow, Vanessa Teague, Aaron Tomb, Daniel Wagner, Jake Waksbaum, Matt Wilhelm, and Greg Zaverucha for many helpful comments and suggestions on earlier versions of this specification.","title":"Acknowledgements"},{"location":"spec/web/12_Acknowledgements/#acknowledgements","text":"The author is happy to thank Nicholas Boucher, Joey Dodds, Gerald Doussot, Aleks Essex, Rainbow Huang, Chris Jeuell, Luke Myers, Dan Shumow, Vanessa Teague, Aaron Tomb, Daniel Wagner, Jake Waksbaum, Matt Wilhelm, and Greg Zaverucha for many helpful comments and suggestions on earlier versions of this specification.","title":"Acknowledgements"},{"location":"spec/web/1_Overview/","text":"ElectionGuard Web Specification Incomplete The web version is being constructed by the open source community for the convenience of web viewing. However, it is incomplete at this time and should not be used for reference purposes. If you need a complete reference, refer to the official specifications . Overview This document describes the technical details of the ElectionGuard toolkit which can be used in conjunction with many new and existing voting systems to enable both end-to-end (E2E) verifiability and privacy-enhanced risk-limiting audits (RLAs). ElectionGuard is not a complete election system. It instead provides components that are designed to be flexible and to promote innovation by election officials and system developers. When properly used, it can promote voter confidence by empowering voters to independently verify the accuracy of election results. End-to-end (E2E) verifiability An E2E-verifiable election provides artifacts which allow voters to confirm that their votes have been accurately recorded and counted. Specifically, an election is End-to-end (E2E) verifiable if two properties are achieved. Individual voters can verify that their votes have been accurately recorded. Voters and observers can verify that the recorded votes have been accurately counted. An E2E-verifiable tally can be used as the primary tally in an election or as a verifiable secondary tally alongside traditional methods. ElectionGuard is compatible with in-person voting \u2013 either using an electronic ballot-marking device or an optical scanner capable of reading hand-marked or machine-marked ballots, with voting by mail, and even with Internet voting. Risk-limiting audits (RLAs) RLAs offer election administrators efficient methods to validate reported election tallies against physical ballot records. There are several varieties of RLAs, but the most efficient and practical are ballot-comparison audits in which electronic cast-vote records (CVRs) are individually compared against physical ballots. The challenge with ballot-comparison audits is that public release of the full set of CVRs can compromise voter privacy while an audit without public disclosure of CVRs offers no basis for public confidence in the outcome. ElectionGuard can bridge this gap by enabling public disclosure of encrypted ballots that can matched directly to physical ballots selected for auditing and can also be proven to match the reported tallies. About this specification This specification can be used by expert reviewers to evaluate the details of the ElectionGuard process and by independent parties to write ElectionGuard verifiers to confirm the consistency of election artifacts with announced election results. The details of the ElectionGuard Application Programming Interface (API) are provided in a separate document.","title":"Overview"},{"location":"spec/web/1_Overview/#electionguard-web-specification","text":"Incomplete The web version is being constructed by the open source community for the convenience of web viewing. However, it is incomplete at this time and should not be used for reference purposes. If you need a complete reference, refer to the official specifications .","title":"ElectionGuard Web Specification"},{"location":"spec/web/1_Overview/#overview","text":"This document describes the technical details of the ElectionGuard toolkit which can be used in conjunction with many new and existing voting systems to enable both end-to-end (E2E) verifiability and privacy-enhanced risk-limiting audits (RLAs). ElectionGuard is not a complete election system. It instead provides components that are designed to be flexible and to promote innovation by election officials and system developers. When properly used, it can promote voter confidence by empowering voters to independently verify the accuracy of election results.","title":"Overview"},{"location":"spec/web/1_Overview/#end-to-end-e2e-verifiability","text":"An E2E-verifiable election provides artifacts which allow voters to confirm that their votes have been accurately recorded and counted. Specifically, an election is End-to-end (E2E) verifiable if two properties are achieved. Individual voters can verify that their votes have been accurately recorded. Voters and observers can verify that the recorded votes have been accurately counted. An E2E-verifiable tally can be used as the primary tally in an election or as a verifiable secondary tally alongside traditional methods. ElectionGuard is compatible with in-person voting \u2013 either using an electronic ballot-marking device or an optical scanner capable of reading hand-marked or machine-marked ballots, with voting by mail, and even with Internet voting.","title":"End-to-end (E2E) verifiability"},{"location":"spec/web/1_Overview/#risk-limiting-audits-rlas","text":"RLAs offer election administrators efficient methods to validate reported election tallies against physical ballot records. There are several varieties of RLAs, but the most efficient and practical are ballot-comparison audits in which electronic cast-vote records (CVRs) are individually compared against physical ballots. The challenge with ballot-comparison audits is that public release of the full set of CVRs can compromise voter privacy while an audit without public disclosure of CVRs offers no basis for public confidence in the outcome. ElectionGuard can bridge this gap by enabling public disclosure of encrypted ballots that can matched directly to physical ballots selected for auditing and can also be proven to match the reported tallies.","title":"Risk-limiting audits (RLAs)"},{"location":"spec/web/1_Overview/#about-this-specification","text":"This specification can be used by expert reviewers to evaluate the details of the ElectionGuard process and by independent parties to write ElectionGuard verifiers to confirm the consistency of election artifacts with announced election results. The details of the ElectionGuard Application Programming Interface (API) are provided in a separate document.","title":"About this specification"},{"location":"spec/web/2_ElectionGuard_Structure/","text":"ElectionGuard Structure In an election, a set of guardians is enlisted to serve as trustees who manage cryptographic keys. The members of a canvassing board can serve as guardians. Prior to the commencement of voting or auditing, the guardians work together to form a public encryption key that will be used to encrypt individual ballots. After the conclusion of voting or auditing, a quorum of guardians is necessary to produce the artifacts required to enable public verification of the tally. Key Generation Prior to the start of voting (for an E2E-verifiable election) or auditing (for an RLA), the election guardians participate in a process wherein they generate public keys to be used in the election. Each guardian generates an election key \u2013 for use in encrypting votes \u2013 and an auxiliary key \u2013 for use in encrypting other data. 1 Additional keys are generated to facilitate sharing of private keys so that the election verifiable data can be produced after voting or auditing is complete \u2013 even if not all guardians are available at that time. The key generation ceremony begins with each guardian publishing its public keys together with proofs of knowledge of the associated private keys. Once all of the public keys are published, each guardian uses each other guardian\u2019s public auxiliary key to encrypt shares of its own private keys. Finally, each guardian decrypts the shares it receives from other guardians and checks them for consistency. If the received shares verify, the receiving guardian announces its completion. If any shares fail to verify, the receiving guardian challenges the sender. In this case, the sender is obliged to reveal the shares it sent. If it does so and the shares verify, the ceremony concludes and the election proceeds. If a challenged guardian fails to produce key shares that verify, that guardian is removed and the key generation ceremony restarts with a replacement guardian. Ballot Encryption In most uses, the election system makes a single call to the ElectionGuard API after each voter completes the process of making selections or with each ballot to be encrypted for an RLA. ElectionGuard will encrypt the selections made by the voter and return a verification code which the system should give to the voter. 2 This is the only point where an existing election system must interface with ElectionGuard . In certain vote-by-mail scenarios and when ElectionGuard is used within an RLA, cast-vote records can be provided in batch without any interface between the voting equipment and ElectionGuard . There is no need to provide verification codes in the RLA scenario. The encrypted ballots are published along with non-interactive zero-knowledge proof of their integrity. The encrypted method used herein has a homomorphic property which allows the encrypted ballots to be combined into a single aggregate ballot which consists of encryptions of the election tallies. Verifiable Decryption In the final step, election guardians independently use their secret keys to decrypt the election tallies and associated verification data. It is not necessary for all guardians to be available to complete this step. If some guardians are missing, a quorum of guardians can use the previously shared key fragments to reconstruct the missing verification data. Observers can use this open specification and/or accompanying materials to write election verifiers that can confirm the integrity of each encrypted ballot, the correct aggregation of these ballots, and the accurate decryption of election tallies. The details of the ElectionGuard Application Programming Interface (API) are included in a separate document. The principal purposes of this document are to specify the functionality of the ElectionGuard toolkit and to provide details necessary for independent parties to write election verifiers that consume the artifacts produced by the toolkit. While the format of the election keys is critical to the process and carefully delineated in this document, the auxiliary keys are for internal use only and their format is left up to individual implementations. \u21a9 The verification code is not necessary for RLA usage. \u21a9","title":"Structure"},{"location":"spec/web/2_ElectionGuard_Structure/#electionguard-structure","text":"In an election, a set of guardians is enlisted to serve as trustees who manage cryptographic keys. The members of a canvassing board can serve as guardians. Prior to the commencement of voting or auditing, the guardians work together to form a public encryption key that will be used to encrypt individual ballots. After the conclusion of voting or auditing, a quorum of guardians is necessary to produce the artifacts required to enable public verification of the tally.","title":"ElectionGuard Structure"},{"location":"spec/web/2_ElectionGuard_Structure/#key-generation","text":"Prior to the start of voting (for an E2E-verifiable election) or auditing (for an RLA), the election guardians participate in a process wherein they generate public keys to be used in the election. Each guardian generates an election key \u2013 for use in encrypting votes \u2013 and an auxiliary key \u2013 for use in encrypting other data. 1 Additional keys are generated to facilitate sharing of private keys so that the election verifiable data can be produced after voting or auditing is complete \u2013 even if not all guardians are available at that time. The key generation ceremony begins with each guardian publishing its public keys together with proofs of knowledge of the associated private keys. Once all of the public keys are published, each guardian uses each other guardian\u2019s public auxiliary key to encrypt shares of its own private keys. Finally, each guardian decrypts the shares it receives from other guardians and checks them for consistency. If the received shares verify, the receiving guardian announces its completion. If any shares fail to verify, the receiving guardian challenges the sender. In this case, the sender is obliged to reveal the shares it sent. If it does so and the shares verify, the ceremony concludes and the election proceeds. If a challenged guardian fails to produce key shares that verify, that guardian is removed and the key generation ceremony restarts with a replacement guardian.","title":"Key Generation"},{"location":"spec/web/2_ElectionGuard_Structure/#ballot-encryption","text":"In most uses, the election system makes a single call to the ElectionGuard API after each voter completes the process of making selections or with each ballot to be encrypted for an RLA. ElectionGuard will encrypt the selections made by the voter and return a verification code which the system should give to the voter. 2 This is the only point where an existing election system must interface with ElectionGuard . In certain vote-by-mail scenarios and when ElectionGuard is used within an RLA, cast-vote records can be provided in batch without any interface between the voting equipment and ElectionGuard . There is no need to provide verification codes in the RLA scenario. The encrypted ballots are published along with non-interactive zero-knowledge proof of their integrity. The encrypted method used herein has a homomorphic property which allows the encrypted ballots to be combined into a single aggregate ballot which consists of encryptions of the election tallies.","title":"Ballot Encryption"},{"location":"spec/web/2_ElectionGuard_Structure/#verifiable-decryption","text":"In the final step, election guardians independently use their secret keys to decrypt the election tallies and associated verification data. It is not necessary for all guardians to be available to complete this step. If some guardians are missing, a quorum of guardians can use the previously shared key fragments to reconstruct the missing verification data. Observers can use this open specification and/or accompanying materials to write election verifiers that can confirm the integrity of each encrypted ballot, the correct aggregation of these ballots, and the accurate decryption of election tallies. The details of the ElectionGuard Application Programming Interface (API) are included in a separate document. The principal purposes of this document are to specify the functionality of the ElectionGuard toolkit and to provide details necessary for independent parties to write election verifiers that consume the artifacts produced by the toolkit. While the format of the election keys is critical to the process and carefully delineated in this document, the auxiliary keys are for internal use only and their format is left up to individual implementations. \u21a9 The verification code is not necessary for RLA usage. \u21a9","title":"Verifiable Decryption"},{"location":"spec/web/3_ElectionGuard_Components/","text":"ElectionGuard Components This document describes the four principal components of ElectionGuard. Baseline Parameters \u2013 These are general parameters that are standard in every election. An alternate means for generating parameters is described, but the burden of verifying an election is increased if alternate parameters are used because a verifier would need to verify the proper construction of any alternate parameters. Key Generation \u2013 Prior to each individual election, guardians must generate individual public-private key pairs and exchange shares of private keys to enable completion of an election even if some guardians become unavailable. Although it is preferred to generate new keys for each election, it is permissible to use the same keys for multiple elections so long as the set of guardians remains the same. A complete new set of keys must be generated if even a single guardian is replaced. Ballot Encryption \u2013 While encrypting the contents of a ballot is a relatively simple operation, most of the work of ElectionGuard is the process of creating externallyverifiable artifacts to prove that each encrypted ballot is well-formed (i.e., its decryption is a legitimate ballot without overvotes or improper values). Verifiable Decryption \u2013 At the conclusion of each election, guardians use their private keys to produce election tallies together with verifiable artifacts that prove that the tallies are correct. Notation In the remainder of this specification, the following notation will be used. \u2022 \\(\u2124 = \\{\u2026 , \u22123, \u22122, \u22121, 0, 1, 2, 3, \u2026 \\}\\) is the set of integers. \u2022 \\(\u2124_n = \\{0, 1, 2, \u2026 , n \u2212 1\\}\\) is the additive group of the integers modulo \\(p\\) . \u2022 \\(\u2124_n^\u2217\\) is the multiplicative subgroup of \\(\u2124_n\\) . When \\(p\\) is a prime, \\(\u2124_p^* = \\{1, 2, 3, \u2026 , p \u2212 1\\}.\\) \u2022 \\(\u2124_p^r\\) is the set of \\(r^{th}\\) -residues in \\(\u2124_p^*\\) . Formally, \\(\u2124_p^r = \\{y \\in \u2124_p^*\\) for which \\(\\exists x \\in \u2124_p^\u2217\\) such that \\(y = x^r \\bmod p\\}\\) . When \\(p\\) is a prime for which \\(p \u2212 1 = qr\\) with \\(q\\) a prime that is not a divisor of integer \\(r\\) , then \\(\u2124_p^r\\) is an order \\(q\\) cyclic subgroup of \\(\u2124_p^\u2217\\) and for each \\(y \\in \u2124_p^\u2217, y \\in \u2124_p^r\\) if and only if \\(y^q \\bmod p = 1\\) . \u2022 \\(x \\equiv_n y\\) is the predicate that is true if and only if \\(x \\bmod n = y \\bmod n\\) . \u2022 The function \\(H()\\) shall be used to designate the SHA-256 hash function (as defined in NIST PUB FIPS 180-4 1 ). \u2022 In general, the variable pairs \\((\\alpha, \\beta)\\) , \\((a, b)\\) , and \\((A, B)\\) will be used to denote encryptions. Specifically, \\((\\alpha, \\beta)\\) will be used to designate encryptions of votes (always an encryption of a zero or a one), \\((A, B)\\) will be used to denote aggregations of encryptions \u2013 which may be encryptions of larger values, and \\((a, b)\\) will be used to denote encryption commitments used to prove properties of other encryptions. Encryption of Votes Encryption of votes in ElectionGuard is performed using an exponential form of the ElGamal cryptosystem. 2 Primes \\(p\\) and \\(q\\) are publicly fixed such that \\(q\\) is not a divisor of \\(r = \\frac {p\u22121} {q}\\) . A generator \\(g\\) of the order \\(q\\) subgroup \\(\u2124_p^r\\) is also fixed. (Any \\(g = x^r \\bmod p\\) for which \\(x \\in \u2124_p^*\\) suffices so long as \\(g \\neq 1\\) .) A public-private key pair can be chosen by selecting a random \\(s \\in \u2124_q\\) as a private key and publishing \\(K = g^s \\bmod p\\) as a public key. 3 A message \\(M \\in \u2124_p^r\\) is then encrypted by selecting a random nonce \\(R \\in \u2124_q\\) and forming the pair \\((\\alpha, \\beta) = (g^R \\bmod p,g^M \u22c5 K^R \\bmod p)\\) . An encryption \\((\\alpha, \\beta)\\) can be decrypted by the holder of the secret \\(s\\) as \\(\\frac \\beta {\\alpha^s} \\bmod p =\\frac {g^M \u22c5 K^R} {(g^R)^s} \\bmod p = \\frac {g^M \u22c5 (g^s)^R} {(g^R)^s} \\bmod p = \\frac {g^M \u22c5 g^{Rs}} {g^{Rs}} \\bmod p = g^M \\bmod p.\\) The value of \\(M\\) can be computed from \\(g^M \\bmod p\\) as long as the message \\(M\\) is limited to a small, known set of options. 4 Only two possible messages are encrypted in this way by ElectionGuard . An encryption of one is used to indicate that an option is selected, and an encryption of zero is used to indicate that an option is not selected. Homomorphic Properties A fundamental quality of the exponential form of ElGamal described above is its additively homomorphic property. If two messages \\(M_1\\) and \\(M_2\\) are respectively encrypted as \\((A_1,B_1) =(g^{R_1} \\bmod p, g^{M_1} \u22c5 K^{R_1} \\bmod p)\\) and \\((A_2,B_2) = (g^{R_2} \\bmod p, g^{M_2} \u22c5 K^{R_2} \\bmod p)\\) , then the component-wise product \\((A, B) = (A_1A_2 \\bmod p,B_1B_2 \\bmod p) = (g^{R_1+R_2} \\bmod p, g^{M_1+M_2}\u22c5K^{R_1+R_2} \\bmod p)\\) is an encryption of the sum \\(M_1 + M_2\\) . (There is an implicit assumption here that \\((M_1 + M_2) < q\\) which is easily satisfied when \\(M_1\\) and \\(M_2\\) are both small. If \\((R_1 + R_2) \u2265 q, (R_1 + R_2) \\bmod q\\) may be substituted without changing the equation since \\(g^q \\bmod p = 1.)\\) This additively homomorphic property is used in two important ways in ElectionGuard. First, all of the encryptions of a single option across ballots can be multiplied to form an encryption of the sum of the individual values. Since the individual values are one on ballots that select that option and zero otherwise, the sum is the tally of votes for that option and the product of the individual encryptions is an encryption of the tally. The other use is to sum all of the selections made in a single contest on a single ballot. After demonstrating that each option is an encryption of either zero or one, the product of the encryptions indicates the number of options that are encryptions of one, and this can be used to show that no more ones than permitted are among the encrypted options \u2013 i.e., that no more options were selected than permitted. However, as will be described below, it is possible for a holder of a nonce \\(R\\) to prove to a third party that a pair \\((\\alpha, \\beta)\\) is an encryption of \\(M\\) without revealing the nonce \\(R\\) and without access to the secret \\(s\\) . Non-Interactive Zero-Knowledge (NIZK) Proofs ElectionGuard provides numerous proofs about encryption keys, encrypted ballots, and election tallies using the following four techniques. A Schnorr proof 5 allows the holder of an ElGamal secret key \\(s\\) to interactively prove possession of \\(s\\) without revealing \\(s\\) . A Chaum-Pedersen proof 6 allows an ElGamal encryption to be interactively proven to decrypt to a particular value without revealing the nonce used for encryption or the secret decryption key \\(s\\) . (This proof can be constructed with access to either the nonce used for encryption or the secret decryption key.) The Cramer-Damg\u00e5rd-Schoenmakers technique 7 enables a disjunction to be interactively proven without revealing which disjunct is true. The Fiat-Shamir heuristic 8 allows interactive proofs to be converted into noninteractive proofs. Using a combination of the above techniques, it is possible for ElectionGuard to demonstrate that keys are properly chosen, that ballots are properly formed, and that decryptions match claimed values. Threshold Encryption Threshold ElGamal encryption is used for encryption of ballots and other data. This form of encryption makes it very easy to combine individual guardian public keys into a single public key. It also offers a homomorphic property that allows individual encrypted votes to be combined to form encrypted tallies. The guardians of an election will each generate a public-private key pair. The public keys will then be combined (as described in the following section) into a single election public key which is used to encrypt all selections made by voters in the election. Ideally, at the conclusion of the election, each guardian will use its private key to form a verifiable partial decryption of each tally. These partial decryptions will then be combined to form full verifiable decryptions of the election tallies. To accommodate the possibility that one or more of the guardians will not be available at the conclusion of the election to form their partial decryptions, the guardians will cryptographically share 9 their private keys amongst each other during key generation in a manner to be detailed in the next section. A pre-determined threshold quorum value \\((k)\\) out of the \\((n)\\) guardians will be necessary to produce a full decryption. NIST (2015) Secure Hash Standard (SHS). In: FIPS 180-4. https://csrc.nist.gov/publications/detail/fips/180/4/final \u21a9 ElGamal T. (1985) A Public Key Cryptosystem and a Signature Scheme Based on Discrete Logarithms. In: Blakley G.R., Chaum D. (eds) Advances in Cryptology. CRYPTO 1984. Lecture Notes in Computer Science, vol 196. Springer, Berlin, Heidelberg. https://link.springer.com/content/pdf/10.1007/3-540-39568-7_2.pdf \u21a9 As will be seen below, the actual public key used to encrypt votes will be a combination of separately-generated public keys. So no entity will ever be in possession of a private key that can be used to decrypt votes. \u21a9 The simplest way to compute \\(M\\) from \\(g^M \\bmod p\\) is an exhaustive search through possible values of \\(M\\) . Alternatively, a table of pairing each possible value of \\(g^M \\bmod p\\) can be pre-computed. A final option which can accommodate a larger space of possible values for \\(M\\) is to use Shanks\u2019s baby-step giant-step method as described in the 1971 paper \u201cClass Number, a Theory of Factorization and Genera,\u201d Proceedings of Symposium in Pure Mathematics, Vol. 20, American Mathematical Society, Providence, 1971, pp. 415-440. \u21a9 Schnorr C.P. (1990) Efficient Identification and Signatures for Smart Cards. In: Brassard G. (eds) Advances in Cryptology \u2014 CRYPTO\u2019 89 Proceedings. CRYPTO 1989. Lecture Notes in Computer Science, vol 435. Springer, New York, NY. https://link.springer.com/content/pdf/10.1007%2F0-387-34805-0_22.pdf \u21a9 Chaum D., Pedersen T.P. (1993) Wallet Databases with Observers. In: Brickell E.F. (eds) Advances in Cryptology \u2014 CRYPTO\u2019 92. CRYPTO 1992. Lecture Notes in Computer Science, vol 740. Springer, Berlin, Heidelberg. https://link.springer.com/content/pdf/10.1007%2F3-540-48071-4_7.pdf \u21a9 Cramer R., Damg\u00e5rd I., Schoenmakers B. (1994) Proofs of Partial Knowledge and Simplified Design of Witness Hiding Protocols. In: Desmedt Y.G. (eds) Advances in Cryptology \u2014 CRYPTO \u201994. CRYPTO 1994. Lecture Notes in Computer Science, vol 839. Springer, Berlin, Heidelberg. https://link.springer.com/content/pdf/10.1007%2F3-540-48658-5_19.pdf \u21a9 Fiat A., Shamir A. (1987) How To Prove Yourself: Practical Solutions to Identification and Signature Problems. In: Odlyzko A.M. (eds) Advances in Cryptology \u2014 CRYPTO\u2019 86. CRYPTO 1986. Lecture Notes in Computer Science, vol 263. Springer, Berlin, Heidelberg. https://link.springer.com/content/pdf/10.1007%2F3- 540-47721-7_12.pdf \u21a9 Shamir A. How to Share a Secret. (1979) Communications of the ACM. \u21a9","title":"Components"},{"location":"spec/web/3_ElectionGuard_Components/#electionguard-components","text":"This document describes the four principal components of ElectionGuard. Baseline Parameters \u2013 These are general parameters that are standard in every election. An alternate means for generating parameters is described, but the burden of verifying an election is increased if alternate parameters are used because a verifier would need to verify the proper construction of any alternate parameters. Key Generation \u2013 Prior to each individual election, guardians must generate individual public-private key pairs and exchange shares of private keys to enable completion of an election even if some guardians become unavailable. Although it is preferred to generate new keys for each election, it is permissible to use the same keys for multiple elections so long as the set of guardians remains the same. A complete new set of keys must be generated if even a single guardian is replaced. Ballot Encryption \u2013 While encrypting the contents of a ballot is a relatively simple operation, most of the work of ElectionGuard is the process of creating externallyverifiable artifacts to prove that each encrypted ballot is well-formed (i.e., its decryption is a legitimate ballot without overvotes or improper values). Verifiable Decryption \u2013 At the conclusion of each election, guardians use their private keys to produce election tallies together with verifiable artifacts that prove that the tallies are correct.","title":"ElectionGuard Components"},{"location":"spec/web/3_ElectionGuard_Components/#notation","text":"In the remainder of this specification, the following notation will be used. \u2022 \\(\u2124 = \\{\u2026 , \u22123, \u22122, \u22121, 0, 1, 2, 3, \u2026 \\}\\) is the set of integers. \u2022 \\(\u2124_n = \\{0, 1, 2, \u2026 , n \u2212 1\\}\\) is the additive group of the integers modulo \\(p\\) . \u2022 \\(\u2124_n^\u2217\\) is the multiplicative subgroup of \\(\u2124_n\\) . When \\(p\\) is a prime, \\(\u2124_p^* = \\{1, 2, 3, \u2026 , p \u2212 1\\}.\\) \u2022 \\(\u2124_p^r\\) is the set of \\(r^{th}\\) -residues in \\(\u2124_p^*\\) . Formally, \\(\u2124_p^r = \\{y \\in \u2124_p^*\\) for which \\(\\exists x \\in \u2124_p^\u2217\\) such that \\(y = x^r \\bmod p\\}\\) . When \\(p\\) is a prime for which \\(p \u2212 1 = qr\\) with \\(q\\) a prime that is not a divisor of integer \\(r\\) , then \\(\u2124_p^r\\) is an order \\(q\\) cyclic subgroup of \\(\u2124_p^\u2217\\) and for each \\(y \\in \u2124_p^\u2217, y \\in \u2124_p^r\\) if and only if \\(y^q \\bmod p = 1\\) . \u2022 \\(x \\equiv_n y\\) is the predicate that is true if and only if \\(x \\bmod n = y \\bmod n\\) . \u2022 The function \\(H()\\) shall be used to designate the SHA-256 hash function (as defined in NIST PUB FIPS 180-4 1 ). \u2022 In general, the variable pairs \\((\\alpha, \\beta)\\) , \\((a, b)\\) , and \\((A, B)\\) will be used to denote encryptions. Specifically, \\((\\alpha, \\beta)\\) will be used to designate encryptions of votes (always an encryption of a zero or a one), \\((A, B)\\) will be used to denote aggregations of encryptions \u2013 which may be encryptions of larger values, and \\((a, b)\\) will be used to denote encryption commitments used to prove properties of other encryptions.","title":"Notation"},{"location":"spec/web/3_ElectionGuard_Components/#encryption-of-votes","text":"Encryption of votes in ElectionGuard is performed using an exponential form of the ElGamal cryptosystem. 2 Primes \\(p\\) and \\(q\\) are publicly fixed such that \\(q\\) is not a divisor of \\(r = \\frac {p\u22121} {q}\\) . A generator \\(g\\) of the order \\(q\\) subgroup \\(\u2124_p^r\\) is also fixed. (Any \\(g = x^r \\bmod p\\) for which \\(x \\in \u2124_p^*\\) suffices so long as \\(g \\neq 1\\) .) A public-private key pair can be chosen by selecting a random \\(s \\in \u2124_q\\) as a private key and publishing \\(K = g^s \\bmod p\\) as a public key. 3 A message \\(M \\in \u2124_p^r\\) is then encrypted by selecting a random nonce \\(R \\in \u2124_q\\) and forming the pair \\((\\alpha, \\beta) = (g^R \\bmod p,g^M \u22c5 K^R \\bmod p)\\) . An encryption \\((\\alpha, \\beta)\\) can be decrypted by the holder of the secret \\(s\\) as \\(\\frac \\beta {\\alpha^s} \\bmod p =\\frac {g^M \u22c5 K^R} {(g^R)^s} \\bmod p = \\frac {g^M \u22c5 (g^s)^R} {(g^R)^s} \\bmod p = \\frac {g^M \u22c5 g^{Rs}} {g^{Rs}} \\bmod p = g^M \\bmod p.\\) The value of \\(M\\) can be computed from \\(g^M \\bmod p\\) as long as the message \\(M\\) is limited to a small, known set of options. 4 Only two possible messages are encrypted in this way by ElectionGuard . An encryption of one is used to indicate that an option is selected, and an encryption of zero is used to indicate that an option is not selected.","title":"Encryption of Votes"},{"location":"spec/web/3_ElectionGuard_Components/#homomorphic-properties","text":"A fundamental quality of the exponential form of ElGamal described above is its additively homomorphic property. If two messages \\(M_1\\) and \\(M_2\\) are respectively encrypted as \\((A_1,B_1) =(g^{R_1} \\bmod p, g^{M_1} \u22c5 K^{R_1} \\bmod p)\\) and \\((A_2,B_2) = (g^{R_2} \\bmod p, g^{M_2} \u22c5 K^{R_2} \\bmod p)\\) , then the component-wise product \\((A, B) = (A_1A_2 \\bmod p,B_1B_2 \\bmod p) = (g^{R_1+R_2} \\bmod p, g^{M_1+M_2}\u22c5K^{R_1+R_2} \\bmod p)\\) is an encryption of the sum \\(M_1 + M_2\\) . (There is an implicit assumption here that \\((M_1 + M_2) < q\\) which is easily satisfied when \\(M_1\\) and \\(M_2\\) are both small. If \\((R_1 + R_2) \u2265 q, (R_1 + R_2) \\bmod q\\) may be substituted without changing the equation since \\(g^q \\bmod p = 1.)\\) This additively homomorphic property is used in two important ways in ElectionGuard. First, all of the encryptions of a single option across ballots can be multiplied to form an encryption of the sum of the individual values. Since the individual values are one on ballots that select that option and zero otherwise, the sum is the tally of votes for that option and the product of the individual encryptions is an encryption of the tally. The other use is to sum all of the selections made in a single contest on a single ballot. After demonstrating that each option is an encryption of either zero or one, the product of the encryptions indicates the number of options that are encryptions of one, and this can be used to show that no more ones than permitted are among the encrypted options \u2013 i.e., that no more options were selected than permitted. However, as will be described below, it is possible for a holder of a nonce \\(R\\) to prove to a third party that a pair \\((\\alpha, \\beta)\\) is an encryption of \\(M\\) without revealing the nonce \\(R\\) and without access to the secret \\(s\\) .","title":"Homomorphic Properties"},{"location":"spec/web/3_ElectionGuard_Components/#non-interactive-zero-knowledge-nizk-proofs","text":"ElectionGuard provides numerous proofs about encryption keys, encrypted ballots, and election tallies using the following four techniques. A Schnorr proof 5 allows the holder of an ElGamal secret key \\(s\\) to interactively prove possession of \\(s\\) without revealing \\(s\\) . A Chaum-Pedersen proof 6 allows an ElGamal encryption to be interactively proven to decrypt to a particular value without revealing the nonce used for encryption or the secret decryption key \\(s\\) . (This proof can be constructed with access to either the nonce used for encryption or the secret decryption key.) The Cramer-Damg\u00e5rd-Schoenmakers technique 7 enables a disjunction to be interactively proven without revealing which disjunct is true. The Fiat-Shamir heuristic 8 allows interactive proofs to be converted into noninteractive proofs. Using a combination of the above techniques, it is possible for ElectionGuard to demonstrate that keys are properly chosen, that ballots are properly formed, and that decryptions match claimed values.","title":"Non-Interactive Zero-Knowledge (NIZK) Proofs"},{"location":"spec/web/3_ElectionGuard_Components/#threshold-encryption","text":"Threshold ElGamal encryption is used for encryption of ballots and other data. This form of encryption makes it very easy to combine individual guardian public keys into a single public key. It also offers a homomorphic property that allows individual encrypted votes to be combined to form encrypted tallies. The guardians of an election will each generate a public-private key pair. The public keys will then be combined (as described in the following section) into a single election public key which is used to encrypt all selections made by voters in the election. Ideally, at the conclusion of the election, each guardian will use its private key to form a verifiable partial decryption of each tally. These partial decryptions will then be combined to form full verifiable decryptions of the election tallies. To accommodate the possibility that one or more of the guardians will not be available at the conclusion of the election to form their partial decryptions, the guardians will cryptographically share 9 their private keys amongst each other during key generation in a manner to be detailed in the next section. A pre-determined threshold quorum value \\((k)\\) out of the \\((n)\\) guardians will be necessary to produce a full decryption. NIST (2015) Secure Hash Standard (SHS). In: FIPS 180-4. https://csrc.nist.gov/publications/detail/fips/180/4/final \u21a9 ElGamal T. (1985) A Public Key Cryptosystem and a Signature Scheme Based on Discrete Logarithms. In: Blakley G.R., Chaum D. (eds) Advances in Cryptology. CRYPTO 1984. Lecture Notes in Computer Science, vol 196. Springer, Berlin, Heidelberg. https://link.springer.com/content/pdf/10.1007/3-540-39568-7_2.pdf \u21a9 As will be seen below, the actual public key used to encrypt votes will be a combination of separately-generated public keys. So no entity will ever be in possession of a private key that can be used to decrypt votes. \u21a9 The simplest way to compute \\(M\\) from \\(g^M \\bmod p\\) is an exhaustive search through possible values of \\(M\\) . Alternatively, a table of pairing each possible value of \\(g^M \\bmod p\\) can be pre-computed. A final option which can accommodate a larger space of possible values for \\(M\\) is to use Shanks\u2019s baby-step giant-step method as described in the 1971 paper \u201cClass Number, a Theory of Factorization and Genera,\u201d Proceedings of Symposium in Pure Mathematics, Vol. 20, American Mathematical Society, Providence, 1971, pp. 415-440. \u21a9 Schnorr C.P. (1990) Efficient Identification and Signatures for Smart Cards. In: Brassard G. (eds) Advances in Cryptology \u2014 CRYPTO\u2019 89 Proceedings. CRYPTO 1989. Lecture Notes in Computer Science, vol 435. Springer, New York, NY. https://link.springer.com/content/pdf/10.1007%2F0-387-34805-0_22.pdf \u21a9 Chaum D., Pedersen T.P. (1993) Wallet Databases with Observers. In: Brickell E.F. (eds) Advances in Cryptology \u2014 CRYPTO\u2019 92. CRYPTO 1992. Lecture Notes in Computer Science, vol 740. Springer, Berlin, Heidelberg. https://link.springer.com/content/pdf/10.1007%2F3-540-48071-4_7.pdf \u21a9 Cramer R., Damg\u00e5rd I., Schoenmakers B. (1994) Proofs of Partial Knowledge and Simplified Design of Witness Hiding Protocols. In: Desmedt Y.G. (eds) Advances in Cryptology \u2014 CRYPTO \u201994. CRYPTO 1994. Lecture Notes in Computer Science, vol 839. Springer, Berlin, Heidelberg. https://link.springer.com/content/pdf/10.1007%2F3-540-48658-5_19.pdf \u21a9 Fiat A., Shamir A. (1987) How To Prove Yourself: Practical Solutions to Identification and Signature Problems. In: Odlyzko A.M. (eds) Advances in Cryptology \u2014 CRYPTO\u2019 86. CRYPTO 1986. Lecture Notes in Computer Science, vol 263. Springer, Berlin, Heidelberg. https://link.springer.com/content/pdf/10.1007%2F3- 540-47721-7_12.pdf \u21a9 Shamir A. How to Share a Secret. (1979) Communications of the ACM. \u21a9","title":"Threshold Encryption"},{"location":"spec/web/4_Baseline_Parameters/","text":"Baseline Parameters ElectionGuard uses integer ElGamal rather than elliptic-curve ElGamal in order to make construction of election verifiers as simple as possible without requiring special tools and dependencies. The exponential ElGamal used to encrypt votes is defined by a 4096-bit prime \\(p\\) and a 256-bit prime \\(q\\) which divides \\((p \u2212 1)\\) . We use \\(r = \\frac{p-1}{q}\\) to denote cofactor of \\(q\\) , and a generator \\(g\\) of the order \\(q\\) subgroup \\(\\mathbb{Z}^{r}_{p}\\) is fixed. Another parameter of an election should be a public ballot coding file. This file should list all the contests in an election, the number of selections allowed for each contest, and the options for each contest together with associations between each option and its representation on a virtual ballot. It is assumed that each contest in the ballot coding file has a unique label and that within each contest, each option also has a unique label. For instance, if Alice, Bob, and Carol are running for governor, and David and Ellen are running for senator, the ballot coding file could enable the vector \\(\u30080,1,0; 0,1\u3009\\) to be recognized as a ballot with votes for Bob as governor and Ellen as senator. The detailed format of a ballot coding file will not be specified in this document. But the contents of this file are hashed together with the prime modulus \\((p)\\) , subgroup order \\((q)\\) , generator \\((g)\\) , number of guardians \\((n)\\) , decryption quorum threshold value \\((k)\\) , date, and jurisdictional information to form a base hash code \\((Q)\\) which will be incorporated into every subsequent hash computation in the election. Standard parameters for ElectionGuard begin with the largest 256-bit prime \\(q = 2^{256} \u2212 189\\) . The hexadecimal representation of q is as follows. FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFF43 The modulus \\(p\\) is then set to be a 4096-bit prime with the following properties. The first 256 bits of \\(p\\) are all ones. The last 256 bits of \\(p\\) are all ones. \\(p \u2212 1\\) is a multiple of \\(q\\) . \\(\\frac{p\u22121}{2q}\\) is also prime. The middle 3584 bits of \\(p\\) are chosen by starting with the first 3584 bits of the Euler\u2013Mascheroni constant ( \\(\\gamma\\) ), pre-pending and appending 256 ones, and finding the smallest prime larger than this value that satisfies the above properties. This works out to \\(p = 2^{4096} \u2212 2^{3840} \u2212 1 + 2^{256}(\u230a2^{3584}\\gamma\u230b + \\delta)\\) where the value of \\(\\delta\\) is given by 1 \\[ \\delta = 495448529856135475846147600290107731951815687842437876083937612367400355133042233301. \\] The hexadecimal representation of q is as follows. FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 93C467E3 7DB0C7A4 D1BE3F81 0152CB56 A1CECC3A F65CC019 0C03DF34 709AFFBD 8E4B59FA 03A9F0EE D0649CCB 621057D1 1056AE91 32135A08 E43B4673 D74BAFEA 58DEB878 CC86D733 DBE7BF38 154B36CF 8A96D156 7899AAAE 0C09D4C8 B6B7B86F D2A1EA1D E62FF864 3EC7C271 82797722 5E6AC2F0 BD61C746 961542A3 CE3BEA5D B54FE70E 63E6D09F 8FC28658 E80567A4 7CFDE60E E741E5D8 5A7BD469 31CED822 03655949 64B83989 6FCAABCC C9B31959 C083F22A D3EE591C 32FAB2C7 448F2A05 7DB2DB49 EE52E018 2741E538 65F004CC 8E704B7C 5C40BF30 4C4D8C4F 13EDF604 7C555302 D2238D8C E11DF242 4F1B66C2 C5D238D0 744DB679 AF289048 7031F9C0 AEA1C4BB 6FE9554E E528FDF1 B05E5B25 6223B2F0 9215F371 9F9C7CCC 69DDF172 D0D62342 17FCC003 7F18B93E F5389130 B7A661E5 C26E5421 4068BBCA FEA32A67 818BD307 5AD1F5C7 E9CC3D17 37FB2817 1BAF84DB B6612B78 81C1A48E 439CD03A 92BF5222 5A2B38E6 542E9F72 2BCE15A3 81B5753E A8427633 81CCAE83 512B3051 1B32E5E8 D8036214 9AD030AA BA5F3A57 98BB22AA 7EC1B6D0 F17903F4 E234EA60 34AA8597 3F79A93F FB82A75C 47C03D43 D2F9CA02 D03199BA CEDDD453 34DBC6B5 FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF The hexadecimal representation of the cofactor \\(r = \\frac{p\u22121}{q}\\) is as follows. 1 00000000 00000000 00000000 00000000 00000000 00000000 00000000 000000BC 93C467E3 7DB0C7A4 D1BE3F81 0152CB56 A1CECC3A F65CC019 0C03DF34 709B8AF6 A64C0CED CF2D559D A9D97F09 5C3076C6 86037619 148D2C86 C317102A FA214803 1F04440A C0FF0C9A 417A8921 2512E760 7B2501DA A4D38A2C 1410C483 6149E2BD B8C8260E 627C4646 963EFFE9 E16E495D 48BD215C 6D8EC9D1 667657A2 A1C8506F 2113FFAD 19A6B2BC 7C457604 56719183 309F874B C9ACE570 FFDA877A A2B23A2D 6F291C15 54CA2EB1 2F12CD00 9B8B8734 A64AD51E B893BD89 1750B851 62241D90 8F0C9709 879758E7 E8233EAB 3BF2D6AB 53AFA32A A153AD66 82E5A064 8897C9BE 18A0D50B ECE030C3 432336AD 9163E33F 8E7DAF49 8F14BB28 52AFFA81 4841EB18 DD5F0E89 516D5577 76285C16 071D2111 94EE1C3F 34642036 AB886E3E C28882CE 4003DEA3 35B4D935 BAE4B582 35B9FB2B AB713C8F 705A1C7D E4222020 9D6BBCAC C4673186 01565272 E4A63E38 E2499754 AE493AC1 A8E83469 EEF35CA2 7C271BC7 92EEE211 56E617B9 22EA8F71 3C22CF28 2DC5D638 5BB12868 EB781278 FA0AB2A8 958FCCB5 FFE2E5C3 61FC1744 20122B01 63CA4A46 308C8C46 C91EA745 7C1AD0D6 9FD4A7F5 29FD4A7F 529FD4A7 F529FD4A 7F529FD4 A7F529FD 4A7F529F D4A7F52A Finally, the generator \\(g\\) is chosen to be \\(g = 2^r\\bmod p\\) and has the following hexadecimal representation. 037DE384 F98F6E03 8D2A3141 825B33D5 D45EC4CC 64CFD15E 750D6798 F5196CF2 A142CDF3 3F6EF853 840EC7D4 EC804794 CFB0CFB6 5363B256 6387B98E E0E3DEF1 B706FA55 D5038FFB 4A62DCBB 93B1DDD8 D3B308DA 86D1C3A5 25EF356F E5BB5931 4E656334 80B396E1 DD4B795F 78DE07D8 6B0E2A05 BE6AF78F D7F736FC BA6C032E 26E050AF 50A03C65 FA7B6C87 F4554CB5 7F3DABCB AD8EB9D8 FDEBEEF5 8570669A CC3EDA17 DBFC47B8 B3C39AA0 8B829B28 872E62B5 D1B13A98 F09D40AC 20C2AB74 A6750E7C 8750B514 1E221C41 F55BBA31 D8E41422 B64D2CBA 7AAA0E9F D8785702 F6932825 BF45DE83 86D24900 742062C1 322B37C5 0AF18215 8090C35D A9355E6C F7F72DA3 9A2284FD FB1918B2 A2A30E69 501FA234 2B728263 DF23F1DB 8355BDE1 EB276FB3 685F3716 72CEB313 FDAB069C C9B11AB6 C59BCE62 BAAD96AA C96B0DBE 0C7E71FC B2255254 5A5D1CED EEE01E4B C0CDBDB7 6B6AD45F 09AF5E71 114A005F 93AD97B8 FE09274E 76C94B20 08926B38 CAEC94C9 5E96D628 F6BC8066 2BA06207 801328B2 C6A60526 BF7CD02D 9661385A C3B1CBDB 50F759D0 E9F61C11 A07BF421 8F299BCB 29005200 76EBD2D9 5A3DEE96 D4809EF3 4ABEB83F DBA8A12C 5CA82757 288A89C9 31CF564F 00E8A317 AE1E1D82 8E61369B A0DDBADB 10C136F8 691101AD 82DC5477 5AB83538 40D99921 97D80A6E 94B38AC4 17CDDF40 B0C73ABF 03E8E0AA Alternative parameter sets are possible. A good source for parameter generation is appendix A of FIPS \\(186-4\\) 2 . However, allowing alternate parameters would force election verifiers to recognize and check that parameters are correctly generated. Since these checks would be very different from other checks that are required of a verifier, allowing alternate parameters would add substantial complexity to election verifiers. For this reason, this version of ElectionGuard fixes the parameters as above. An ElectionGuard version 1 election verifier may assume that the baseline parameters match the parameters provided above. However, it is recommended that the above parameters be checked against the parameters of each election to accommodate the possibility of different parameters in future versions of ElectionGuard. 3 Discovering this value \\(\\delta\\) required a search through roughly 42 million values satisfying the first three of the above properties to find one for which both \\(p\\) and \\(\\frac{p-1}{2q}\\) are both prime. \u21a9 NIST (2013) Digital Signature Standard (DSS). In: FIPS 186-4. https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf \u21a9 If alternative parameters are allowed, election verifiers must confir that \\(p, q, r\\) and \\(g\\) are such that both \\(p\\) and \\(q\\) are prime (this may be done probabilistically using the Miller-Rabin algorithm), that \\(p-1 = qr\\) is satisfied, that \\(q\\) is not a divisor of \\(r\\) , that \\(1<g<p\\) , that \\(g^qq \\bmod p = 1\\) , and that generation of parameters is consistent with the sited standard. \u21a9","title":"Baseline Parameters"},{"location":"spec/web/4_Baseline_Parameters/#baseline-parameters","text":"ElectionGuard uses integer ElGamal rather than elliptic-curve ElGamal in order to make construction of election verifiers as simple as possible without requiring special tools and dependencies. The exponential ElGamal used to encrypt votes is defined by a 4096-bit prime \\(p\\) and a 256-bit prime \\(q\\) which divides \\((p \u2212 1)\\) . We use \\(r = \\frac{p-1}{q}\\) to denote cofactor of \\(q\\) , and a generator \\(g\\) of the order \\(q\\) subgroup \\(\\mathbb{Z}^{r}_{p}\\) is fixed. Another parameter of an election should be a public ballot coding file. This file should list all the contests in an election, the number of selections allowed for each contest, and the options for each contest together with associations between each option and its representation on a virtual ballot. It is assumed that each contest in the ballot coding file has a unique label and that within each contest, each option also has a unique label. For instance, if Alice, Bob, and Carol are running for governor, and David and Ellen are running for senator, the ballot coding file could enable the vector \\(\u30080,1,0; 0,1\u3009\\) to be recognized as a ballot with votes for Bob as governor and Ellen as senator. The detailed format of a ballot coding file will not be specified in this document. But the contents of this file are hashed together with the prime modulus \\((p)\\) , subgroup order \\((q)\\) , generator \\((g)\\) , number of guardians \\((n)\\) , decryption quorum threshold value \\((k)\\) , date, and jurisdictional information to form a base hash code \\((Q)\\) which will be incorporated into every subsequent hash computation in the election. Standard parameters for ElectionGuard begin with the largest 256-bit prime \\(q = 2^{256} \u2212 189\\) . The hexadecimal representation of q is as follows. FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFF43 The modulus \\(p\\) is then set to be a 4096-bit prime with the following properties. The first 256 bits of \\(p\\) are all ones. The last 256 bits of \\(p\\) are all ones. \\(p \u2212 1\\) is a multiple of \\(q\\) . \\(\\frac{p\u22121}{2q}\\) is also prime. The middle 3584 bits of \\(p\\) are chosen by starting with the first 3584 bits of the Euler\u2013Mascheroni constant ( \\(\\gamma\\) ), pre-pending and appending 256 ones, and finding the smallest prime larger than this value that satisfies the above properties. This works out to \\(p = 2^{4096} \u2212 2^{3840} \u2212 1 + 2^{256}(\u230a2^{3584}\\gamma\u230b + \\delta)\\) where the value of \\(\\delta\\) is given by 1 \\[ \\delta = 495448529856135475846147600290107731951815687842437876083937612367400355133042233301. \\] The hexadecimal representation of q is as follows. FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 93C467E3 7DB0C7A4 D1BE3F81 0152CB56 A1CECC3A F65CC019 0C03DF34 709AFFBD 8E4B59FA 03A9F0EE D0649CCB 621057D1 1056AE91 32135A08 E43B4673 D74BAFEA 58DEB878 CC86D733 DBE7BF38 154B36CF 8A96D156 7899AAAE 0C09D4C8 B6B7B86F D2A1EA1D E62FF864 3EC7C271 82797722 5E6AC2F0 BD61C746 961542A3 CE3BEA5D B54FE70E 63E6D09F 8FC28658 E80567A4 7CFDE60E E741E5D8 5A7BD469 31CED822 03655949 64B83989 6FCAABCC C9B31959 C083F22A D3EE591C 32FAB2C7 448F2A05 7DB2DB49 EE52E018 2741E538 65F004CC 8E704B7C 5C40BF30 4C4D8C4F 13EDF604 7C555302 D2238D8C E11DF242 4F1B66C2 C5D238D0 744DB679 AF289048 7031F9C0 AEA1C4BB 6FE9554E E528FDF1 B05E5B25 6223B2F0 9215F371 9F9C7CCC 69DDF172 D0D62342 17FCC003 7F18B93E F5389130 B7A661E5 C26E5421 4068BBCA FEA32A67 818BD307 5AD1F5C7 E9CC3D17 37FB2817 1BAF84DB B6612B78 81C1A48E 439CD03A 92BF5222 5A2B38E6 542E9F72 2BCE15A3 81B5753E A8427633 81CCAE83 512B3051 1B32E5E8 D8036214 9AD030AA BA5F3A57 98BB22AA 7EC1B6D0 F17903F4 E234EA60 34AA8597 3F79A93F FB82A75C 47C03D43 D2F9CA02 D03199BA CEDDD453 34DBC6B5 FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF The hexadecimal representation of the cofactor \\(r = \\frac{p\u22121}{q}\\) is as follows. 1 00000000 00000000 00000000 00000000 00000000 00000000 00000000 000000BC 93C467E3 7DB0C7A4 D1BE3F81 0152CB56 A1CECC3A F65CC019 0C03DF34 709B8AF6 A64C0CED CF2D559D A9D97F09 5C3076C6 86037619 148D2C86 C317102A FA214803 1F04440A C0FF0C9A 417A8921 2512E760 7B2501DA A4D38A2C 1410C483 6149E2BD B8C8260E 627C4646 963EFFE9 E16E495D 48BD215C 6D8EC9D1 667657A2 A1C8506F 2113FFAD 19A6B2BC 7C457604 56719183 309F874B C9ACE570 FFDA877A A2B23A2D 6F291C15 54CA2EB1 2F12CD00 9B8B8734 A64AD51E B893BD89 1750B851 62241D90 8F0C9709 879758E7 E8233EAB 3BF2D6AB 53AFA32A A153AD66 82E5A064 8897C9BE 18A0D50B ECE030C3 432336AD 9163E33F 8E7DAF49 8F14BB28 52AFFA81 4841EB18 DD5F0E89 516D5577 76285C16 071D2111 94EE1C3F 34642036 AB886E3E C28882CE 4003DEA3 35B4D935 BAE4B582 35B9FB2B AB713C8F 705A1C7D E4222020 9D6BBCAC C4673186 01565272 E4A63E38 E2499754 AE493AC1 A8E83469 EEF35CA2 7C271BC7 92EEE211 56E617B9 22EA8F71 3C22CF28 2DC5D638 5BB12868 EB781278 FA0AB2A8 958FCCB5 FFE2E5C3 61FC1744 20122B01 63CA4A46 308C8C46 C91EA745 7C1AD0D6 9FD4A7F5 29FD4A7F 529FD4A7 F529FD4A 7F529FD4 A7F529FD 4A7F529F D4A7F52A Finally, the generator \\(g\\) is chosen to be \\(g = 2^r\\bmod p\\) and has the following hexadecimal representation. 037DE384 F98F6E03 8D2A3141 825B33D5 D45EC4CC 64CFD15E 750D6798 F5196CF2 A142CDF3 3F6EF853 840EC7D4 EC804794 CFB0CFB6 5363B256 6387B98E E0E3DEF1 B706FA55 D5038FFB 4A62DCBB 93B1DDD8 D3B308DA 86D1C3A5 25EF356F E5BB5931 4E656334 80B396E1 DD4B795F 78DE07D8 6B0E2A05 BE6AF78F D7F736FC BA6C032E 26E050AF 50A03C65 FA7B6C87 F4554CB5 7F3DABCB AD8EB9D8 FDEBEEF5 8570669A CC3EDA17 DBFC47B8 B3C39AA0 8B829B28 872E62B5 D1B13A98 F09D40AC 20C2AB74 A6750E7C 8750B514 1E221C41 F55BBA31 D8E41422 B64D2CBA 7AAA0E9F D8785702 F6932825 BF45DE83 86D24900 742062C1 322B37C5 0AF18215 8090C35D A9355E6C F7F72DA3 9A2284FD FB1918B2 A2A30E69 501FA234 2B728263 DF23F1DB 8355BDE1 EB276FB3 685F3716 72CEB313 FDAB069C C9B11AB6 C59BCE62 BAAD96AA C96B0DBE 0C7E71FC B2255254 5A5D1CED EEE01E4B C0CDBDB7 6B6AD45F 09AF5E71 114A005F 93AD97B8 FE09274E 76C94B20 08926B38 CAEC94C9 5E96D628 F6BC8066 2BA06207 801328B2 C6A60526 BF7CD02D 9661385A C3B1CBDB 50F759D0 E9F61C11 A07BF421 8F299BCB 29005200 76EBD2D9 5A3DEE96 D4809EF3 4ABEB83F DBA8A12C 5CA82757 288A89C9 31CF564F 00E8A317 AE1E1D82 8E61369B A0DDBADB 10C136F8 691101AD 82DC5477 5AB83538 40D99921 97D80A6E 94B38AC4 17CDDF40 B0C73ABF 03E8E0AA Alternative parameter sets are possible. A good source for parameter generation is appendix A of FIPS \\(186-4\\) 2 . However, allowing alternate parameters would force election verifiers to recognize and check that parameters are correctly generated. Since these checks would be very different from other checks that are required of a verifier, allowing alternate parameters would add substantial complexity to election verifiers. For this reason, this version of ElectionGuard fixes the parameters as above. An ElectionGuard version 1 election verifier may assume that the baseline parameters match the parameters provided above. However, it is recommended that the above parameters be checked against the parameters of each election to accommodate the possibility of different parameters in future versions of ElectionGuard. 3 Discovering this value \\(\\delta\\) required a search through roughly 42 million values satisfying the first three of the above properties to find one for which both \\(p\\) and \\(\\frac{p-1}{2q}\\) are both prime. \u21a9 NIST (2013) Digital Signature Standard (DSS). In: FIPS 186-4. https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf \u21a9 If alternative parameters are allowed, election verifiers must confir that \\(p, q, r\\) and \\(g\\) are such that both \\(p\\) and \\(q\\) are prime (this may be done probabilistically using the Miller-Rabin algorithm), that \\(p-1 = qr\\) is satisfied, that \\(q\\) is not a divisor of \\(r\\) , that \\(1<g<p\\) , that \\(g^qq \\bmod p = 1\\) , and that generation of parameters is consistent with the sited standard. \u21a9","title":"Baseline Parameters"},{"location":"spec/web/6_Ballot_Encryption/","text":"Ballot Encryption An ElectionGuard ballot is comprised entirely of encryptions of one (indicating selection made) and zero (indicating selection not made). To enable homomorphic addition (for tallying), these values are exponentiated during encryption. Specifically, to encrypt a ballot entry \\((V)\\) , a random value \\(R\\) is selected such that \\(0 \u2264 R < q\\) , and the following computation is performed. Zero (not selected) is encrypted as \\((g^R \\bmod p,K^R \\bmod p)\\) . One (selected) is encrypted as \\((g^R \\bmod p, g \u22c5 K^R \\bmod p)\\) . Note that if multiple encrypted votes \\((g^{R_i} \\bmod p, g^{V_i} \u22c5 K^{R_i} \\bmod p)\\) are formed, their component-wise product \\((g^{\\sum_iR_i} \\bmod p, g^{\\sum_iV_i} \u22c5 K^{\\sum_iR_i} \\bmod p)\\) serves as an encryption of \\(\\sum_iV_i \u2013\\) which is the tally of those votes. 1 A contest in an election consists of a set of options together with a selection limit that indicates the number of selections that are allowed to be made in that contest. In most elections, most contests have a selection limit of one. However, a larger selection limit (e.g., select up to three) is not uncommon in some elections. Approval voting can be achieved by setting the selection limit to the total number of options in a contest. Ranked choice voting is not supported in this version of ElectionGuard, but it may be enabled in a future version. 2 Also, write-ins are assumed to be explicitly registered or allowed to be lumped into a single \u201cwrite-ins\u201d category for the purpose of verifiable tallying. Verifiable tallying of free-form write-ins may be best done with a MixNet 3 design. A legitimate vote in a contest consists of a set of selections with cardinality not exceeding the selection limit of that contest. To accommodate legitimate undervotes, the internal representation of a contest is augmented with \u201cplaceholder\u201d options equal in number to the selection limit. Placeholder options are selected as necessary to force the total number of selections made in a contest to be equal to the selection limit. When the selection limit is one, for example, the single placeholder option can be thought of as a \u201cnone of the above\u201d option. With larger selection limits, the number of placeholder options selected corresponds to the number of additional options that a voter could have selected in a contest. Note For efficiency, the placeholder options could be eliminated in an approval vote. However, to simplify the construction of election verifiers, we presume that placeholder options are always present \u2013 even for approval votes. Two things must now be proven about the encryption of each vote to ensure the integrity of a ballot. The encryption associated with each option is either an encryption of zero or an encryption of one. The sum of all encrypted values in each contest is equal to the selection limit for that contest (usually one). The use of ElGamal encryption enables efficient zero-knowledge proofs of these requirements, and the Fiat-Shamir heuristic can be used to make these proofs non-interactive. ChaumPedersen proofs are used to demonstrate that an encryption is that of a specified value, and these are combined with the Cramer-Damg\u00e5rd-Schoenmakers technique to show that an encryption is that of one of a specified set of values \u2013 particularly that a value is an encryption of either zero or one. The encryptions of selections in a contest are homomorphically combined, and the result is shown to be an encryption of that contest\u2019s selection limit \u2013 again using a Chaum-Pedersen proof. Note Note that the decryption of the selection limit could be more efficiently demonstrated by just releasing the sum of the nonces used for each of the individual encryptions. But, again to simplify the construction of election verifiers, a Chaum-Pedersen proof is used here as well. The \u201crandom\u201d nonces used for the ElGamal encryption of the ballot nonces are derived from a single 256-bit master nonce \\(R_B\\) for each ballot. For each contest listed in the ballot coding file, a contest nonce \\(R_C\\) is derived from the master nonce \\((R_B)\\) and the contest label \\((L_C)\\) as \\(R_C = H(L_C,R_B)\\) using the hash function SHA-256. For each option listed in the ballot coding file, the nonce used to encrypt that option is derived from the contest nonce \\((R_C)\\) and the selection label for that option \\((L_S)\\) as \\(R = H(L_S, R_C)\\) . A user of ElectionGuard may optionally provide an additional public key. If such a key is provided, ElectionGuard uses that key to encrypt each ballot\u2019s master nonce \\(R_B\\) and return this encryption together with the encrypted ballot. Ballot nonces may be independent across different ballots, and only the nonces used to encrypt ballot selections need to be derived from the master nonce. The use of a single master nonce for each ballot allows the entire ballot encryption to be re-derived from the contents of a ballot and the master nonce. It also allows the encrypted ballot to be fully decrypted with the single master nonce. Outline for proofs of ballot correctness To prove that an ElGamal encryption pair \\((\\alpha, \\beta)\\) is an encryption of zero, the Chaum-Pedersen protocol proceeds as follows. NIZK Proof that \\((\\alpha, \\beta)\\) is an encryption of zero (given knowledge of encryption nonce \\(R\\) ) The prover selects a random value \\(u\\) in \\(\u2124_q\\) and commits to the pair \\((a, b) =(g^u \\bmod p,K^u \\bmod p)\\) . A hash computation is then performed (using the Fiat-Shamir heuristic) to create a pseudo-random challenge value \\(c = H(\\bar{Q}, (\\alpha, \\beta), (a, b))\\) , and the prover responds with \\(v = (u + cR) \\bmod q\\) . A verifier can now confirm the claim by checking that both \\(g^v\\bmod p = a\u22c5\\alpha^c\\bmod p\\) and \\(K^v \\bmod p = b\u22c5\\beta^c \\bmod p\\) are true. NIZK Proof that \\((\\alpha, \\beta)\\) is an encryption of one (given knowledge of encryption nonce \\(R\\) ) To prove that \\((\\alpha, \\beta)\\) is an encryption of one, \\(\\frac \\beta g \\bmod p\\) is substituted for \\(\\beta\\) in the above. The verifier can be relieved of the need to perform a modular division by computing \\(\\beta \\bar{g} \\bmod p\\) rather than \\(\\frac \\beta g \\bmod p\\) . As an alternative, the verifier can confirm that \\(g^c \u22c5 K^v \\bmod p = b \u22c5 \\beta^c \\bmod p\\) instead of \\(K^{v} \\bmod p = b \u22c5 (\\frac \\beta g)^c \\bmod p\\) . As with many zero-knowledge protocols, if the prover knows a challenge value prior to making its commitment, it can create a false proof. For example, if a challenge \\(c\\) is known to be forthcoming, a prover can generate a random \\(v\\) in \\(\u2124_q\\) and commit to \\((a, b) = (\\frac {g^v} {\\alpha^c} \\bmod p, \\frac {K^v} {\\beta^c} \\bmod p) = (g^{v} \\alpha^{q\u2212c} \\bmod p, K^v \\beta^{q\u2212c} \\bmod p)\\) . This selection will satisfy the required checks for \\((\\alpha, \\beta)\\) to appear as an encryption of zero regardless of the values of \\((\\alpha, \\beta)\\) . Similarly, setting \\((a, b) = (\\frac {g^v} {\\alpha^c} \\bmod p, \\frac {K^vg^c} {\\beta^c} \\bmod p) = (g^{v} \\alpha^{q\u2212c} \\bmod p, K^v g^c\\beta^{q\u2212c} \\bmod p)\\) will satisfy the required checks for \\((\\alpha, \\beta)\\) to appear as an encryption of one regardless of the values of \\((\\alpha, \\beta)\\) . This quirk is what enables the Cramer-Damg\u00e5rd-Schoenmakers technique to prove a disjunction of two predicates. Sketch of NIZK Proof that \\((\\alpha, \\beta)\\) is an encryption of zero or one After the prover makes commitments \\((a_0, b_0)\\) and \\((a_1, b_1)\\) to the respective assertions that \\((\\alpha, \\beta)\\) is an encryption of zero and \\((\\alpha, \\beta)\\) is an encryption of one, a single challenge value \\(c\\) is selected by hashing all commitments and baseline parameters. The prover must then provide challenge values \\(c_0\\) and \\(c_1\\) such that \\(c = c_0 + c_1 \\bmod q\\) . Since the prover has complete freedom to choose one of \\(c_0\\) and \\(c_1\\) , the prover can fix one value in advance \u2013 either \\(c_0\\) if \\((\\alpha, \\beta)\\) is actually an encryption of one or \\(c_1\\) if \\((\\alpha, \\beta)\\) is actually an encryption of zero. In response to the resulting challenge \\(c\\) , the prover uses this freedom to answer its faux claim with its chosen challenge value and then uses the remaining challenge value (as forced by the constraint that \\(c = (c_0 + c_1) \\bmod q\\) ) to demonstrate the truth of the other claim. An observer can see that one of the two claims must be true but cannot tell which. Details for proofs of ballot correctness The full protocol proceeds as follows \u2013 fully divided into the two cases. To encrypt an \u201cunselected\u201d option on a ballot, a random nonce \\(R\\) is selected uniformly \\(\u2124_q\\) and an encryption of zero is formed as \\((\\alpha, \\beta) = (g^R \\bmod p,K^R \\bmod p)\\) . NIZK Proof that \\((\\alpha, \\beta)\\) is an encryption of zero or one (given knowledge of encryption nonce \\(R\\) for which \\((\\alpha, \\beta)\\) is an encryption of zero ) To create the proof that \\((\\alpha, \\beta)\\) is an encryption of a zero or a one, randomly select \\(c_1\\) , \\(v_1\\) , and \\(u_0\\) from \\(\u2124_q\\) and form the commitments \\[ (a_0, b_0) = (g^{u_0} \\bmod p,K^{u_0} \\bmod p) \\] and \\[ (a_1, b_1) = (\\frac {g^{v_1}} {\\alpha^{c_1}} \\bmod p, \\frac {K^{v_1}g^{c_1}} {\\beta^{c_1}} \\bmod p) = (g^{v_1}\\alpha^{q-c_1} \\bmod p, K^{v_1}g^{c_1}\\beta^{q-c_1}\\bmod p). \\] A challenge value \\(c\\) is formed by hashing the extended base hash \\(\\bar{Q}\\) together with \\((\\alpha, \\beta)\\) , \\((a_0, b_0)\\) , and \\((a_1, b_1)\\) to form a challenge value \\(c = H(Q, (\\alpha, \\beta), (a_0, b_0), (a_1, b_1))\\) . The proof is completed by forming \\(c_0 = (c \u2212 c_1) \\bmod q\\) and \\(v_0 = (u_0 + c_0 \u22c5 R) \\bmod q\\) and answering the challenge by returning \\(c_0\\) , \\(c_1\\) , \\(v_0\\) , and \\(v_1\\) . To encrypt a \u201cselected\u201d option on a ballot, a random nonce \\(R\\) is selected uniformly from \\(\u2124_q\\) and an encryption of one is formed as \\((\\alpha, \\beta) = (g^r \\bmod p, g \u22c5 K^r\\bmod p)\\) . NIZK Proof that \\((\\alpha, \\beta)\\) is an encryption of zero or one (given knowledge of encryption nonce \\(R\\) for which \\((\\alpha, \\beta)\\) is an encryption of one ) To create the proof that \\((\\alpha, \\beta)\\) is an encryption of a zero or a one, randomly select \\(c_0\\) , \\(v_0\\) , and \\(u_1\\) from \\(\u2124_q\\) and form the commitments \\[ (a_0, b_0) = (\\frac{g^{v_0}}{\\alpha^{c_0}} \\bmod p, \\frac{K^{v_0}}{\\beta^{c_0}}\\bmod p) = (g^{v_0}\\alpha^{q-c_0}\\bmod p, K^{v_0}\\beta^{q-c_0}\\bmod p) \\] and \\[ (a_1,b_1)=(g^{u_1} \\bmod p,K^{u_1}\\bmod p) \\] A challenge value \\(c\\) is formed by hashing the extended base hash \\(\\bar{Q}\\) together with \\((\\alpha, \\beta)\\) , \\((a_0, b_0)\\) , and \\((a_1, b_1)\\) to form a challenge value \\(c = H(\\bar{Q}, (\\alpha, \\beta), (a_0, b_0), (a_1, b_1))\\) . The proof is completed by forming \\(c_1 = (c \u2212 c_0) \\bmod q\\) and \\(v_1 = (u_1 + c_1 \u22c5 R) \\bmod q\\) and answering the challenge by returning \\(c_0\\) , \\(c_1\\) , \\(v_0\\) , and \\(v_1\\) . In either of the two above cases, what is published in the election record is the encryption \\((\\alpha, \\beta)\\) together with the commitments \\((a_0, b_0)\\) and \\((a_1, b_1)\\) which are all hashed together with the election\u2019s extended base hash to form the challenge value \\(c\\) which is published together with values \\(c_0\\) , \\(c_1\\) , \\(v_0\\) , and \\(v_1\\) . Important An election verifier must confirm the following for each possible selection on a ballot: (A) The given values \\(\\alpha\\) , \\(\\beta\\) , \\(a_0\\) , \\(b_0\\) , \\(a_1\\) , and \\(b_1\\) are all in the set \\(\u2124_p^r\\) . (A value \\(x\\) is in \\(\u2124_p^r\\) if and only if \\(x\\) is an integer such that 0 \u2264 \\(x\\) < \\(p\\) and \\(x^q \\bmod p = 1\\) is satisfied.) (B) The challenge \\(c\\) is correctly computed as \\(c = H(\\bar{Q}, (\\alpha,\\beta), (a_0, b_0), (a_1, b_1))\\) . (C) The given values \\(c_0\\) , \\(c_1\\) , \\(v_0\\) , and \\(v_1\\) are each in the set \\(\u2124_q\\) . (A value \\(x\\) is in \\(\u2124_q\\) if and only if \\(x\\) is an integer such that \\(0 \u2264 x < q\\) .) (D) The equation \\(c = (c_0 + c_1) \\bmod q\\) is satisfied. (E) The equation \\(g^{v_0} \\bmod p = a_0\\alpha^{c_0} \\bmod p\\) is satisfied. (F) The equation \\(g^{v_1} \\bmod p = a_1\\alpha^{c_1} \\bmod p\\) is satisfied. (G) The equation \\(K^{v_0} \\bmod p = b_0\\beta^{c_0} \\bmod p\\) is satisfied. (H) The equation \\(g^{c_1}K^{v_1} \\bmod p = b_1\\beta^{c_1} \\bmod p\\) is satisfied. Proof of satisfying the selection limit The final step in proving that a ballot is well-formed is demonstrating that the selection limits for each contest have not been exceeded. This is accomplished by homomorphically combining all of the \\((\\alpha_i, \\beta_i)\\) values for a contest by forming the aggregate contest encryption \\((\\alpha, \\beta) = (\\Pi_i\\alpha_i \\bmod p , \\Pi_i\\beta_i \\bmod p)\\) and proving that \\((\\alpha, \\beta)\\) is an encryption of the total number of votes allowed for that contest (usually one). The simplest way to complete this proof is to combine all of the random nonces \\(R_i\\) that were used to form each \\((\\alpha_i,\\beta_i) = (g^{R_i} \\bmod p, K^{R_i} \\bmod p)\\) or \\((\\alpha_i,\\beta_i) = (g^{R_i} \\bmod p, g \u22c5 K^{R_i} \\bmod p)\\) \u2013 depending on whether the value encrypted is zero or one. The aggregate nonce \\(R = \\sum_iR_i \\bmod q\\) matches the aggregate contest encryption as \\((\\alpha, \\beta) = (\\Pi_i\\alpha_i \\bmod p, \\Pi_i\\beta_i \\bmod p) = (g^R \\bmod p,g^LK^R \\bmod p)\\) - where \\(L\\) is the selection limit for the contest. (Recall that \\(L\\) extra \u201cplaceholder\u201d positions will be added to each contest and set to one as necessary to ensure that exactly \\(L\\) selections are made for the contest.) NIZK Proof that \\((\\alpha, \\beta)\\) is an encryption of \\(L\\) (given knowledge of aggregate encryption nonce \\(R\\) ) An additional Chaum-Pedersen proof of \\((\\alpha,\\beta)\\) being an encryption of \\(L\\) is performed by selecting a random \\(U\\) in \\(\u2124_q\\) , publishing \\((a,b) = (g^U \\bmod p,K^U \\bmod p)\\) , hashing these values together with election\u2019s extended base hash \\(\\bar{Q}\\) to form a pseudo-random challenge \\(C = H(\\bar{Q}, (\\alpha, \\beta), (a, b))\\) , and responding by publishing \\(V = (U + CR) \\bmod q\\) . 4 Note that all of the above proofs can be performed directly by the entity performing the public key encryption of a ballot without access to the decryption key(s). All that is required is the nonces \\(R_i\\) used for the individual selection encryptions. Important An election verifier must confirm the following for each contest on the ballot: (A) The number of placeholder positions matches the contest\u2019s selection limit \\(L\\) . (B) The contest total \\((A, B)\\) satisfies \\(A = \\Pi_i\\alpha_i \\bmod p\\) and \\(B = \\Pi_i\\beta_i \\bmod p\\) where the \\((\\alpha_i, \\beta_i)\\) represent all possible selections (including placeholder selections) for the contest. (C) The given value \\(V\\) is in \\(\u2124_q\\) . (D) The given values \\(a\\) and \\(b\\) are each in \\(\u2124_q^r\\) . (E) The challenge value \\(C\\) is correctly computed as \\(C = H(\\bar{Q}, (A, B), (a, b))\\) . (F) The equation \\(g^V \\bmod p = (aA^C) \\bmod p\\) is satisfied. (G) The equation \\((g^{LC}K^V) \\bmod p = (bB^C) \\bmod p\\) is satisfied. Tracking codes Upon completion of the encryption of each ballot, a tracking code is prepared for each voter. The code is a running hash that begins with the extended base hash code \\(\\bar{Q}\\) and includes an identifier for the voting device, the location of the voting device, the date and time that the ballot was encrypted, and, of course, the encryption of the ballot itself. The hash \\((H)\\) used for this purpose is SHA-256. The tracking code is formed as follows. \\(H_0 = H(\\bar{Q})\\) where \\(\\bar{Q}\\) is the extended base hash code of the election. For ballot with index \\(i > 0, H_i = H(H_{i\u22121},D, T, B_i)\\) where \\(D\\) consists of the voting device information described above, \\(T\\) is the date and time of ballot encryption, and \\(B_i\\) is an ordered list of the individual encryptions on the ballot \u2013 with the ordering as specified by the ballot coding file. At the conclusion of a voting period (this may be the end of a day in a multi-day election), the hash chain is closed by computing \\(\\bar{H} = H(H_\u2113,\\) \"CLOSE\" \\()\\) , where \\(H_\u2113\\) is the final tracking code produced by that device during that voting period. The close of the hash chain can be computed either by the voting device or subsequently by election administrators, and it is published as part of the election record. Important An election verifier must confirm that each of the values in the running hash is correctly computed. Specifically, an election verifier must confirm each of the following. (A) The equation \\(H_0 = H(\\bar{Q})\\) is satisfied. (B) For each ballot \\(B_i,H_i = H(H_{i-1},D,T,B_i)\\) is satisfied. (C) The closing hash \\(\\bar{H} = H(H_\u2113,\\) \"CLOSE\" \\()\\) is correctly computed from the final tracking code \\(H_\u2113\\) . Once in possession of a tracking code (and never before), a voter is afforded an option to either cast the associated ballot or spoil it and restart the ballot preparation process. The precise mechanism for voters to make these selections may vary depending upon the instantiation, but this choice would ordinarily be made immediately after a voter is presented with the tracking code, and the status of the ballot would be undetermined until the decision is made. It is possible, for instance, for a voter to make the decision directly on the voting device, or a voter may instead be afforded an option to deposit the ballot in a receptacle or to take it to a poll worker to be spoiled. For vote-by-mail scenarios, a voter can be sent (hashes of) two complete sets of encryptions for each selectable option and can effect a ballot challenge implicitly by choosing which encryptions to return. The initial decryption actually forms the value \\(g^{\\sum_iV_i}\\bmod p\\) . However, since \\(\\sum_iV_i\\) is a relatively small value, it can be effectively computed from \\(g^{\\sum_iV_i}\\bmod p\\) by means of an exhaustive search or similar methods. \u21a9 Benaloh J., Moran. T, Naish L., Ramchen K., and Teague V. Shuffle-Sum: Coercion-Resistant Verifiable Tallying for STV Voting (2009) in Transactions of Information Forensics and Security. \u21a9 Chaum D. Untraceable Electronic Mail, Return Addresses, and Digital Pseudonyms (1981) Communications of the ACM. \u21a9 One could simply release the aggregate nonce \\(R = \\sum_iR_i \\bmod q\\) to complete this proof. However, since Chaum-Pedersen proofs are being performed elsewhere, it is simpler for a verifier to just repeat the same steps. \u21a9","title":"Ballot Encryption"},{"location":"spec/web/6_Ballot_Encryption/#ballot-encryption","text":"An ElectionGuard ballot is comprised entirely of encryptions of one (indicating selection made) and zero (indicating selection not made). To enable homomorphic addition (for tallying), these values are exponentiated during encryption. Specifically, to encrypt a ballot entry \\((V)\\) , a random value \\(R\\) is selected such that \\(0 \u2264 R < q\\) , and the following computation is performed. Zero (not selected) is encrypted as \\((g^R \\bmod p,K^R \\bmod p)\\) . One (selected) is encrypted as \\((g^R \\bmod p, g \u22c5 K^R \\bmod p)\\) . Note that if multiple encrypted votes \\((g^{R_i} \\bmod p, g^{V_i} \u22c5 K^{R_i} \\bmod p)\\) are formed, their component-wise product \\((g^{\\sum_iR_i} \\bmod p, g^{\\sum_iV_i} \u22c5 K^{\\sum_iR_i} \\bmod p)\\) serves as an encryption of \\(\\sum_iV_i \u2013\\) which is the tally of those votes. 1 A contest in an election consists of a set of options together with a selection limit that indicates the number of selections that are allowed to be made in that contest. In most elections, most contests have a selection limit of one. However, a larger selection limit (e.g., select up to three) is not uncommon in some elections. Approval voting can be achieved by setting the selection limit to the total number of options in a contest. Ranked choice voting is not supported in this version of ElectionGuard, but it may be enabled in a future version. 2 Also, write-ins are assumed to be explicitly registered or allowed to be lumped into a single \u201cwrite-ins\u201d category for the purpose of verifiable tallying. Verifiable tallying of free-form write-ins may be best done with a MixNet 3 design. A legitimate vote in a contest consists of a set of selections with cardinality not exceeding the selection limit of that contest. To accommodate legitimate undervotes, the internal representation of a contest is augmented with \u201cplaceholder\u201d options equal in number to the selection limit. Placeholder options are selected as necessary to force the total number of selections made in a contest to be equal to the selection limit. When the selection limit is one, for example, the single placeholder option can be thought of as a \u201cnone of the above\u201d option. With larger selection limits, the number of placeholder options selected corresponds to the number of additional options that a voter could have selected in a contest. Note For efficiency, the placeholder options could be eliminated in an approval vote. However, to simplify the construction of election verifiers, we presume that placeholder options are always present \u2013 even for approval votes. Two things must now be proven about the encryption of each vote to ensure the integrity of a ballot. The encryption associated with each option is either an encryption of zero or an encryption of one. The sum of all encrypted values in each contest is equal to the selection limit for that contest (usually one). The use of ElGamal encryption enables efficient zero-knowledge proofs of these requirements, and the Fiat-Shamir heuristic can be used to make these proofs non-interactive. ChaumPedersen proofs are used to demonstrate that an encryption is that of a specified value, and these are combined with the Cramer-Damg\u00e5rd-Schoenmakers technique to show that an encryption is that of one of a specified set of values \u2013 particularly that a value is an encryption of either zero or one. The encryptions of selections in a contest are homomorphically combined, and the result is shown to be an encryption of that contest\u2019s selection limit \u2013 again using a Chaum-Pedersen proof. Note Note that the decryption of the selection limit could be more efficiently demonstrated by just releasing the sum of the nonces used for each of the individual encryptions. But, again to simplify the construction of election verifiers, a Chaum-Pedersen proof is used here as well. The \u201crandom\u201d nonces used for the ElGamal encryption of the ballot nonces are derived from a single 256-bit master nonce \\(R_B\\) for each ballot. For each contest listed in the ballot coding file, a contest nonce \\(R_C\\) is derived from the master nonce \\((R_B)\\) and the contest label \\((L_C)\\) as \\(R_C = H(L_C,R_B)\\) using the hash function SHA-256. For each option listed in the ballot coding file, the nonce used to encrypt that option is derived from the contest nonce \\((R_C)\\) and the selection label for that option \\((L_S)\\) as \\(R = H(L_S, R_C)\\) . A user of ElectionGuard may optionally provide an additional public key. If such a key is provided, ElectionGuard uses that key to encrypt each ballot\u2019s master nonce \\(R_B\\) and return this encryption together with the encrypted ballot. Ballot nonces may be independent across different ballots, and only the nonces used to encrypt ballot selections need to be derived from the master nonce. The use of a single master nonce for each ballot allows the entire ballot encryption to be re-derived from the contents of a ballot and the master nonce. It also allows the encrypted ballot to be fully decrypted with the single master nonce.","title":"Ballot Encryption"},{"location":"spec/web/6_Ballot_Encryption/#outline-for-proofs-of-ballot-correctness","text":"To prove that an ElGamal encryption pair \\((\\alpha, \\beta)\\) is an encryption of zero, the Chaum-Pedersen protocol proceeds as follows. NIZK Proof that \\((\\alpha, \\beta)\\) is an encryption of zero (given knowledge of encryption nonce \\(R\\) ) The prover selects a random value \\(u\\) in \\(\u2124_q\\) and commits to the pair \\((a, b) =(g^u \\bmod p,K^u \\bmod p)\\) . A hash computation is then performed (using the Fiat-Shamir heuristic) to create a pseudo-random challenge value \\(c = H(\\bar{Q}, (\\alpha, \\beta), (a, b))\\) , and the prover responds with \\(v = (u + cR) \\bmod q\\) . A verifier can now confirm the claim by checking that both \\(g^v\\bmod p = a\u22c5\\alpha^c\\bmod p\\) and \\(K^v \\bmod p = b\u22c5\\beta^c \\bmod p\\) are true. NIZK Proof that \\((\\alpha, \\beta)\\) is an encryption of one (given knowledge of encryption nonce \\(R\\) ) To prove that \\((\\alpha, \\beta)\\) is an encryption of one, \\(\\frac \\beta g \\bmod p\\) is substituted for \\(\\beta\\) in the above. The verifier can be relieved of the need to perform a modular division by computing \\(\\beta \\bar{g} \\bmod p\\) rather than \\(\\frac \\beta g \\bmod p\\) . As an alternative, the verifier can confirm that \\(g^c \u22c5 K^v \\bmod p = b \u22c5 \\beta^c \\bmod p\\) instead of \\(K^{v} \\bmod p = b \u22c5 (\\frac \\beta g)^c \\bmod p\\) . As with many zero-knowledge protocols, if the prover knows a challenge value prior to making its commitment, it can create a false proof. For example, if a challenge \\(c\\) is known to be forthcoming, a prover can generate a random \\(v\\) in \\(\u2124_q\\) and commit to \\((a, b) = (\\frac {g^v} {\\alpha^c} \\bmod p, \\frac {K^v} {\\beta^c} \\bmod p) = (g^{v} \\alpha^{q\u2212c} \\bmod p, K^v \\beta^{q\u2212c} \\bmod p)\\) . This selection will satisfy the required checks for \\((\\alpha, \\beta)\\) to appear as an encryption of zero regardless of the values of \\((\\alpha, \\beta)\\) . Similarly, setting \\((a, b) = (\\frac {g^v} {\\alpha^c} \\bmod p, \\frac {K^vg^c} {\\beta^c} \\bmod p) = (g^{v} \\alpha^{q\u2212c} \\bmod p, K^v g^c\\beta^{q\u2212c} \\bmod p)\\) will satisfy the required checks for \\((\\alpha, \\beta)\\) to appear as an encryption of one regardless of the values of \\((\\alpha, \\beta)\\) . This quirk is what enables the Cramer-Damg\u00e5rd-Schoenmakers technique to prove a disjunction of two predicates. Sketch of NIZK Proof that \\((\\alpha, \\beta)\\) is an encryption of zero or one After the prover makes commitments \\((a_0, b_0)\\) and \\((a_1, b_1)\\) to the respective assertions that \\((\\alpha, \\beta)\\) is an encryption of zero and \\((\\alpha, \\beta)\\) is an encryption of one, a single challenge value \\(c\\) is selected by hashing all commitments and baseline parameters. The prover must then provide challenge values \\(c_0\\) and \\(c_1\\) such that \\(c = c_0 + c_1 \\bmod q\\) . Since the prover has complete freedom to choose one of \\(c_0\\) and \\(c_1\\) , the prover can fix one value in advance \u2013 either \\(c_0\\) if \\((\\alpha, \\beta)\\) is actually an encryption of one or \\(c_1\\) if \\((\\alpha, \\beta)\\) is actually an encryption of zero. In response to the resulting challenge \\(c\\) , the prover uses this freedom to answer its faux claim with its chosen challenge value and then uses the remaining challenge value (as forced by the constraint that \\(c = (c_0 + c_1) \\bmod q\\) ) to demonstrate the truth of the other claim. An observer can see that one of the two claims must be true but cannot tell which.","title":"Outline for proofs of ballot correctness"},{"location":"spec/web/6_Ballot_Encryption/#details-for-proofs-of-ballot-correctness","text":"The full protocol proceeds as follows \u2013 fully divided into the two cases. To encrypt an \u201cunselected\u201d option on a ballot, a random nonce \\(R\\) is selected uniformly \\(\u2124_q\\) and an encryption of zero is formed as \\((\\alpha, \\beta) = (g^R \\bmod p,K^R \\bmod p)\\) . NIZK Proof that \\((\\alpha, \\beta)\\) is an encryption of zero or one (given knowledge of encryption nonce \\(R\\) for which \\((\\alpha, \\beta)\\) is an encryption of zero ) To create the proof that \\((\\alpha, \\beta)\\) is an encryption of a zero or a one, randomly select \\(c_1\\) , \\(v_1\\) , and \\(u_0\\) from \\(\u2124_q\\) and form the commitments \\[ (a_0, b_0) = (g^{u_0} \\bmod p,K^{u_0} \\bmod p) \\] and \\[ (a_1, b_1) = (\\frac {g^{v_1}} {\\alpha^{c_1}} \\bmod p, \\frac {K^{v_1}g^{c_1}} {\\beta^{c_1}} \\bmod p) = (g^{v_1}\\alpha^{q-c_1} \\bmod p, K^{v_1}g^{c_1}\\beta^{q-c_1}\\bmod p). \\] A challenge value \\(c\\) is formed by hashing the extended base hash \\(\\bar{Q}\\) together with \\((\\alpha, \\beta)\\) , \\((a_0, b_0)\\) , and \\((a_1, b_1)\\) to form a challenge value \\(c = H(Q, (\\alpha, \\beta), (a_0, b_0), (a_1, b_1))\\) . The proof is completed by forming \\(c_0 = (c \u2212 c_1) \\bmod q\\) and \\(v_0 = (u_0 + c_0 \u22c5 R) \\bmod q\\) and answering the challenge by returning \\(c_0\\) , \\(c_1\\) , \\(v_0\\) , and \\(v_1\\) . To encrypt a \u201cselected\u201d option on a ballot, a random nonce \\(R\\) is selected uniformly from \\(\u2124_q\\) and an encryption of one is formed as \\((\\alpha, \\beta) = (g^r \\bmod p, g \u22c5 K^r\\bmod p)\\) . NIZK Proof that \\((\\alpha, \\beta)\\) is an encryption of zero or one (given knowledge of encryption nonce \\(R\\) for which \\((\\alpha, \\beta)\\) is an encryption of one ) To create the proof that \\((\\alpha, \\beta)\\) is an encryption of a zero or a one, randomly select \\(c_0\\) , \\(v_0\\) , and \\(u_1\\) from \\(\u2124_q\\) and form the commitments \\[ (a_0, b_0) = (\\frac{g^{v_0}}{\\alpha^{c_0}} \\bmod p, \\frac{K^{v_0}}{\\beta^{c_0}}\\bmod p) = (g^{v_0}\\alpha^{q-c_0}\\bmod p, K^{v_0}\\beta^{q-c_0}\\bmod p) \\] and \\[ (a_1,b_1)=(g^{u_1} \\bmod p,K^{u_1}\\bmod p) \\] A challenge value \\(c\\) is formed by hashing the extended base hash \\(\\bar{Q}\\) together with \\((\\alpha, \\beta)\\) , \\((a_0, b_0)\\) , and \\((a_1, b_1)\\) to form a challenge value \\(c = H(\\bar{Q}, (\\alpha, \\beta), (a_0, b_0), (a_1, b_1))\\) . The proof is completed by forming \\(c_1 = (c \u2212 c_0) \\bmod q\\) and \\(v_1 = (u_1 + c_1 \u22c5 R) \\bmod q\\) and answering the challenge by returning \\(c_0\\) , \\(c_1\\) , \\(v_0\\) , and \\(v_1\\) . In either of the two above cases, what is published in the election record is the encryption \\((\\alpha, \\beta)\\) together with the commitments \\((a_0, b_0)\\) and \\((a_1, b_1)\\) which are all hashed together with the election\u2019s extended base hash to form the challenge value \\(c\\) which is published together with values \\(c_0\\) , \\(c_1\\) , \\(v_0\\) , and \\(v_1\\) . Important An election verifier must confirm the following for each possible selection on a ballot: (A) The given values \\(\\alpha\\) , \\(\\beta\\) , \\(a_0\\) , \\(b_0\\) , \\(a_1\\) , and \\(b_1\\) are all in the set \\(\u2124_p^r\\) . (A value \\(x\\) is in \\(\u2124_p^r\\) if and only if \\(x\\) is an integer such that 0 \u2264 \\(x\\) < \\(p\\) and \\(x^q \\bmod p = 1\\) is satisfied.) (B) The challenge \\(c\\) is correctly computed as \\(c = H(\\bar{Q}, (\\alpha,\\beta), (a_0, b_0), (a_1, b_1))\\) . (C) The given values \\(c_0\\) , \\(c_1\\) , \\(v_0\\) , and \\(v_1\\) are each in the set \\(\u2124_q\\) . (A value \\(x\\) is in \\(\u2124_q\\) if and only if \\(x\\) is an integer such that \\(0 \u2264 x < q\\) .) (D) The equation \\(c = (c_0 + c_1) \\bmod q\\) is satisfied. (E) The equation \\(g^{v_0} \\bmod p = a_0\\alpha^{c_0} \\bmod p\\) is satisfied. (F) The equation \\(g^{v_1} \\bmod p = a_1\\alpha^{c_1} \\bmod p\\) is satisfied. (G) The equation \\(K^{v_0} \\bmod p = b_0\\beta^{c_0} \\bmod p\\) is satisfied. (H) The equation \\(g^{c_1}K^{v_1} \\bmod p = b_1\\beta^{c_1} \\bmod p\\) is satisfied.","title":"Details for proofs of ballot correctness"},{"location":"spec/web/6_Ballot_Encryption/#proof-of-satisfying-the-selection-limit","text":"The final step in proving that a ballot is well-formed is demonstrating that the selection limits for each contest have not been exceeded. This is accomplished by homomorphically combining all of the \\((\\alpha_i, \\beta_i)\\) values for a contest by forming the aggregate contest encryption \\((\\alpha, \\beta) = (\\Pi_i\\alpha_i \\bmod p , \\Pi_i\\beta_i \\bmod p)\\) and proving that \\((\\alpha, \\beta)\\) is an encryption of the total number of votes allowed for that contest (usually one). The simplest way to complete this proof is to combine all of the random nonces \\(R_i\\) that were used to form each \\((\\alpha_i,\\beta_i) = (g^{R_i} \\bmod p, K^{R_i} \\bmod p)\\) or \\((\\alpha_i,\\beta_i) = (g^{R_i} \\bmod p, g \u22c5 K^{R_i} \\bmod p)\\) \u2013 depending on whether the value encrypted is zero or one. The aggregate nonce \\(R = \\sum_iR_i \\bmod q\\) matches the aggregate contest encryption as \\((\\alpha, \\beta) = (\\Pi_i\\alpha_i \\bmod p, \\Pi_i\\beta_i \\bmod p) = (g^R \\bmod p,g^LK^R \\bmod p)\\) - where \\(L\\) is the selection limit for the contest. (Recall that \\(L\\) extra \u201cplaceholder\u201d positions will be added to each contest and set to one as necessary to ensure that exactly \\(L\\) selections are made for the contest.) NIZK Proof that \\((\\alpha, \\beta)\\) is an encryption of \\(L\\) (given knowledge of aggregate encryption nonce \\(R\\) ) An additional Chaum-Pedersen proof of \\((\\alpha,\\beta)\\) being an encryption of \\(L\\) is performed by selecting a random \\(U\\) in \\(\u2124_q\\) , publishing \\((a,b) = (g^U \\bmod p,K^U \\bmod p)\\) , hashing these values together with election\u2019s extended base hash \\(\\bar{Q}\\) to form a pseudo-random challenge \\(C = H(\\bar{Q}, (\\alpha, \\beta), (a, b))\\) , and responding by publishing \\(V = (U + CR) \\bmod q\\) . 4 Note that all of the above proofs can be performed directly by the entity performing the public key encryption of a ballot without access to the decryption key(s). All that is required is the nonces \\(R_i\\) used for the individual selection encryptions. Important An election verifier must confirm the following for each contest on the ballot: (A) The number of placeholder positions matches the contest\u2019s selection limit \\(L\\) . (B) The contest total \\((A, B)\\) satisfies \\(A = \\Pi_i\\alpha_i \\bmod p\\) and \\(B = \\Pi_i\\beta_i \\bmod p\\) where the \\((\\alpha_i, \\beta_i)\\) represent all possible selections (including placeholder selections) for the contest. (C) The given value \\(V\\) is in \\(\u2124_q\\) . (D) The given values \\(a\\) and \\(b\\) are each in \\(\u2124_q^r\\) . (E) The challenge value \\(C\\) is correctly computed as \\(C = H(\\bar{Q}, (A, B), (a, b))\\) . (F) The equation \\(g^V \\bmod p = (aA^C) \\bmod p\\) is satisfied. (G) The equation \\((g^{LC}K^V) \\bmod p = (bB^C) \\bmod p\\) is satisfied.","title":"Proof of satisfying the selection limit"},{"location":"spec/web/6_Ballot_Encryption/#tracking-codes","text":"Upon completion of the encryption of each ballot, a tracking code is prepared for each voter. The code is a running hash that begins with the extended base hash code \\(\\bar{Q}\\) and includes an identifier for the voting device, the location of the voting device, the date and time that the ballot was encrypted, and, of course, the encryption of the ballot itself. The hash \\((H)\\) used for this purpose is SHA-256. The tracking code is formed as follows. \\(H_0 = H(\\bar{Q})\\) where \\(\\bar{Q}\\) is the extended base hash code of the election. For ballot with index \\(i > 0, H_i = H(H_{i\u22121},D, T, B_i)\\) where \\(D\\) consists of the voting device information described above, \\(T\\) is the date and time of ballot encryption, and \\(B_i\\) is an ordered list of the individual encryptions on the ballot \u2013 with the ordering as specified by the ballot coding file. At the conclusion of a voting period (this may be the end of a day in a multi-day election), the hash chain is closed by computing \\(\\bar{H} = H(H_\u2113,\\) \"CLOSE\" \\()\\) , where \\(H_\u2113\\) is the final tracking code produced by that device during that voting period. The close of the hash chain can be computed either by the voting device or subsequently by election administrators, and it is published as part of the election record. Important An election verifier must confirm that each of the values in the running hash is correctly computed. Specifically, an election verifier must confirm each of the following. (A) The equation \\(H_0 = H(\\bar{Q})\\) is satisfied. (B) For each ballot \\(B_i,H_i = H(H_{i-1},D,T,B_i)\\) is satisfied. (C) The closing hash \\(\\bar{H} = H(H_\u2113,\\) \"CLOSE\" \\()\\) is correctly computed from the final tracking code \\(H_\u2113\\) . Once in possession of a tracking code (and never before), a voter is afforded an option to either cast the associated ballot or spoil it and restart the ballot preparation process. The precise mechanism for voters to make these selections may vary depending upon the instantiation, but this choice would ordinarily be made immediately after a voter is presented with the tracking code, and the status of the ballot would be undetermined until the decision is made. It is possible, for instance, for a voter to make the decision directly on the voting device, or a voter may instead be afforded an option to deposit the ballot in a receptacle or to take it to a poll worker to be spoiled. For vote-by-mail scenarios, a voter can be sent (hashes of) two complete sets of encryptions for each selectable option and can effect a ballot challenge implicitly by choosing which encryptions to return. The initial decryption actually forms the value \\(g^{\\sum_iV_i}\\bmod p\\) . However, since \\(\\sum_iV_i\\) is a relatively small value, it can be effectively computed from \\(g^{\\sum_iV_i}\\bmod p\\) by means of an exhaustive search or similar methods. \u21a9 Benaloh J., Moran. T, Naish L., Ramchen K., and Teague V. Shuffle-Sum: Coercion-Resistant Verifiable Tallying for STV Voting (2009) in Transactions of Information Forensics and Security. \u21a9 Chaum D. Untraceable Electronic Mail, Return Addresses, and Digital Pseudonyms (1981) Communications of the ACM. \u21a9 One could simply release the aggregate nonce \\(R = \\sum_iR_i \\bmod q\\) to complete this proof. However, since Chaum-Pedersen proofs are being performed elsewhere, it is simpler for a verifier to just repeat the same steps. \u21a9","title":"Tracking codes"},{"location":"spec/web/7_Ballot_Aggregation/","text":"Ballot Aggregation At the conclusion of voting, all of the ballot encryptions are published in the election record together with the proofs that the ballots are well-formed. Additionally, all of the encryptions of each option are homomorphically combined to form an encryption of the total number of times that option was selected. The encryptions \\(\\mathbf(\\alpha_{i},\\beta_{i})\\) of each individual option are combined by forming the product \\((A,B) = (\\Pi_{i}\\alpha_{i}\\bmod p,\\Pi_{i}\\beta_{i}\\bmod p)\\) . This aggregate encryption \\((A,B)\\) , which represents an encryption of the tally of that option, is published in the election record for each option. Important An election verifier must confirm for each (non-placeholder) option in each contest in the ballot coding file that the aggregate encryption \\((A,B)\\) satisfies \\(A = \\Pi_{j}\\alpha_{j}\\) and \\(B = \\Pi_{j}\\beta_{j}\\) where the \\((\\alpha_{j}, \\beta_{j})\\) are the corresponding encryptions on all cast ballots in the election record.","title":"Ballot Aggregation"},{"location":"spec/web/7_Ballot_Aggregation/#ballot-aggregation","text":"At the conclusion of voting, all of the ballot encryptions are published in the election record together with the proofs that the ballots are well-formed. Additionally, all of the encryptions of each option are homomorphically combined to form an encryption of the total number of times that option was selected. The encryptions \\(\\mathbf(\\alpha_{i},\\beta_{i})\\) of each individual option are combined by forming the product \\((A,B) = (\\Pi_{i}\\alpha_{i}\\bmod p,\\Pi_{i}\\beta_{i}\\bmod p)\\) . This aggregate encryption \\((A,B)\\) , which represents an encryption of the tally of that option, is published in the election record for each option. Important An election verifier must confirm for each (non-placeholder) option in each contest in the ballot coding file that the aggregate encryption \\((A,B)\\) satisfies \\(A = \\Pi_{j}\\alpha_{j}\\) and \\(B = \\Pi_{j}\\beta_{j}\\) where the \\((\\alpha_{j}, \\beta_{j})\\) are the corresponding encryptions on all cast ballots in the election record.","title":"Ballot Aggregation"},{"location":"spec/web/8_Verifiable_Decryption/","text":"Verifiable Decryption To decrypt an aggregate encryption \\((A, B)\\) (or an individual encryption such as one on a spoiled ballot), each available election guardian \\(T_i\\) uses its secret key \\(s_i\\) to compute its share of the decryption as \\[ M_i = A^{s_i} \\bmod p \\] Each guardian \\(T_i\\) also publishes a Chaum-Pedersen proof of the correctness of \\(M_i\\) as follows. NIZK Proof by Guardian \ud835\udc47\ud835\udc56 of knowledge of \\(s_i \\in \\mathbb{Z}^r_p\\) for which both \\(M_i = A^{s_i} \\bmod p\\) and \\(K_i = g^{s_i} \\bmod p\\) Guardian \\(T_i\\) selects a random value \\(u_i\\) in \\(\\mathbb{Z}_q\\) and commits too the pair \\((a_i, b_i) = (g^{u_i} \\bmod p, A^{u_i} \\bmod p)\\) . The values \\((A, B), (a, b)\\) and \\(M\\) are hashed together with the extended base hash value \\(\\overline{Q}\\) t to form a challenge value \\(c_i = H(\\overline{Q}, (A, B), (a_i, b_i), M)\\) , and the guardian \\(T_i\\) responds with \\(v_i = (u_i + c_i s_i) \\bmod q\\) . Important An election verifier must then confirm for each (non-placeholder) option in each contest in the ballot coding ffile the following for each decrypting guardian \\(T_i\\) : (A) The given value \\(v_i\\) is in the set \\(\\mathbb{Z}_q^r\\) (B) The given values \\(a_i\\) and \\(b_i\\) are both in the set \\(\\mathbb{Z}_q^r\\) (C) The challenge value \\(c_i\\) satisfies \\(c_i = H(\\overline{Q}, (A, B), (a_i, b_i), M)\\) . (D) The equation \\(g^{v_i} \\bmod p = (a_i K_i^{c_i}) \\bmod p\\) is satisfied. (E) The equation \\(A^{v_i} \\bmod p = (b_i M_i^{c_i}) \\bmod p\\) is satisfied. Decryption when all guardians are present If all guardians are present and have posted suitable proofs, the next step is to publish the value \\[ M = B / (\\prod_{i=1}^n M_i) \\bmod p. \\] This \\(M\\) has the property that \\(M = g_t \\bmod p\\) where \\(t\\) is the tally of the associated option. In general, computation of this tally value \\(t\\) is computationally intractable. However, in this application, \\(t\\) is relatively small - bounded by the number of votes cast. Election administrators can determine this tally value \\(t\\) from \\(M\\) by exhaustive search, by precomputing a table of all possible \\(M\\) values in the allowable range and then performing a single look-up, or by a combination in which some exponentiations are precomputed and a small search is used to find the value of \\(t\\) (e.g., a partial table consisting of \\(g^{100} \\bmod p, g^{200} \\bmod p, g^{300} \\bmod p\\) \u2026 is precomputed and the value \\(M\\) is repeatedly divided by \\(g\\) until a value is found that is in the partial table). The value \\(t\\) is published in the election record, and verifiers should check both that \\(M = g^t \\bmod p\\) and that \\(B = (M \\cdot \\prod^n_{i=1} M_i) \\bmod p\\) . Decryption with missing guardians If one or more of the election guardians are not available for decryption, any \\(k\\) available guardians can use the information they have to reconstruct the partial decryptions for missing guardians as follows. If guardian \\(T_i\\) is missing during decryption, each of at least \\(k\\) available guardians \\(T_\\ell\\) should use its share \\(P_i(\\ell)\\) of the secret value \\(s_i\\) previously shared by \\(T_i\\) to compute a share of the missing partial decryption \\(M_i\\) in the same way that it used its own secret \\(s_\\ell\\) . Specifically, guardian \\(T_\\ell\\) publishes partial decryption share \\[ M_{i, \\ell} = A^{P_i(\\ell)} \\bmod p \\] Guardian \\(T_\\ell\\) also publishes a Chaum-Pedersen proof of the correctness of \\(M_{i, \\ell}\\) as follows. NIZK Proof by Guardian \\(T_\\ell\\) of knowledge of \\(s_{i, \\ell} \\in \\mathbb{Z}^r_p\\) for which both \\(M_{i, \\ell} = A^{s_{i, \\ell}} \\bmod p\\) and \\(g^{s_i} \\bmod p = \\prod^{k=1}_{j=0}K^{\\ell^j}_{i, j} \\bmod p\\) Guardian \\(T_\\ell\\) selects a random value \\(u_{i, \\ell}\\) in \\(\\mathbb{Z}_q\\) and commits to the pair \\((a_{i, \\ell}, b_{i, \\ell}) = (g^{u_{i, \\ell}} \\bmod p, A^{u_{i, \\ell}} \\bmod p)\\) . The values \\((A, B)\\) , \\((a_{i, \\ell}, b_{i, \\ell})\\) , and \\(M_{i, \\ell}\\) are hashed together with the extended base hash value \\(\\bar{Q}\\) to form a challenge value \\(c_{i, \\ell} = H(\\bar{Q}, (A, B), (a_{i, \\ell}, b_{i, \\ell}), M_{i, \\ell})\\) , and the guardian \\(T_\\ell\\) responds with \\(v_{i, \\ell} = (u_{i, \\ell} + c_{i, \\ell} P_i(\\ell)) \\bmod q\\) . It is important to note here that although the value \\(P_i(\\ell)\\) is known to both the missing guardian \\(T_i\\) and the guardian \\(T_\\ell\\) , it need not published or generally known. However, the value \\(g^{P_i(\\ell)} \\bmod p\\) can be computer form public values as \\[ g^{P_i(\\ell)} \\bmod p = \\prod_{j=0}^{k-1} K^{\\ell^j}_{i, j} \\bmod p. \\] Important An election verifier must confirm for each (non-placeholder) option in each contest in the ballot coding file the following for each missing guardian \\(T_i\\) and for each surrogate guardian \\(T_\\ell\\) . (A) The given value \\(v_{i, \\ell}\\) is in the set \\(\\mathbb{Z}_q\\) . (B) The given values \\(a_{i, \\ell}\\) and \\(b_{i, \\ell}\\) are both in the set \\(\\mathbb{Z}_q^r\\) . (C) The challenge value \\(c_{i, \\ell}\\) satisfies \\(c_{i, \\ell} = H(\\bar{Q}, (A, B), (a_{i, \\ell}, b_{i, \\ell}), M_{i, \\ell})\\) . (D) The equation \\(g^{v_{i, \\ell}} \\bmod p = (a_{i, \\ell} K_{i, \\ell}^{c_{i, \\ell}}) \\bmod p\\) is satisfied. (E) The equation \\(A^{v_{i, \\ell}} \\bmod p = (b_{i, \\ell} M_{i, \\ell}^{c_{i, \\ell}}) \\bmod p\\) is satisfied. The final step to reconstruct a missing partial decryption \\(M_i\\) is to compute Lagrange coefficients for a set of \\(k\\) available guardians \\(\\{ T_\\ell:\\ell \\in U \\}\\) with \\(|U| = k\\) as \\[ w_\\ell = \\frac{(\\prod_{j \\in (U - \\{\\ell\\})}j)}{(\\prod_{j \\in (U - \\{\\ell\\}))}(j - \\ell))} \\bmod q. \\] Important An election verifier should confirm that for each guardian \\(T_\\ell\\) serving to help compute a missing share of a tally, that its Lagrange coefficient \\(w_\\ell\\) is correctly computer by confirming the equation \\((\\prod_{j\\in(U = \\{\\ell\\})} j) \\bmod q = (w_\\ell (\\prod_{j \\in (U - \\{\\ell\\})} (j-\\ell))) \\bmod q\\) . An election verifier should then confirm the correcty missing tally share for each (non-placeholder) option in each contest in the ballot coding file for each missing guardian \\(T_i\\) as \\(M_i = \\prod_{\\ell \\in U} (M_{i, \\ell})^{w_\\ell} \\bmod p\\) . Info Note that the missing secret \\(s_i\\) could be computed directly as \\(s_i = \\sum_{\\ell \\in U}w_\\ell P_i(\\ell) \\bmod q\\) . However, it is preferable to not release the missing secret and instead only release the partial decryption that the missing secret would have produced. This prevents the missing secret \\(s_i\\) from being used for additional decryptions without the cooperation of at least \\(k\\) guardians. As an example, consider an election with five guardians and a threshold of three. If two guardians are missing at the time of decryption, the remaining three can perform any required decryption, the remaining three can perform any required decryptions by constructing missing partial descriptions as described in the text above. If, instead, they take the shortcut of simply reconstructing and then using the two missing secrets, then any of the three could, at a later time, use its own secret together with the two reconstructed secrets to perform additional decryptions without cooperation of any other guardian. The final step is to verify the tallies themselves. Important An election verifier should confirm the following equations for each (non-placeholder) option in each contest in the ballot coding file. (A) \\(B = (M (\\prod^n_{i=i} M_i)) \\bmod p\\) . (B) \\(M = g^t \\bmod p\\) . An election verifier should also confirm that the text labels listed in the election record match the corresponding text labels in the ballot coding file. Decryption of spoiled ballots Every ballot spoiled in an election is individually verifiably decrypted in exactly the same way that the aggregate ballot of tallies is decrypted. Election verifiers should confirm all such decryptions so that casual observers can simply view the decryptions and confirm that they match their expectations. Important An election verifier should confirm the correct decryption of each spoiled ballot using the same process that was used to confirm the election tallies. An election verifier should also confirm that for each decrypted spoiled ballot, the selections listed in text match the corresponding text in the ballot coding file.","title":"Verifiable Decryption"},{"location":"spec/web/8_Verifiable_Decryption/#verifiable-decryption","text":"To decrypt an aggregate encryption \\((A, B)\\) (or an individual encryption such as one on a spoiled ballot), each available election guardian \\(T_i\\) uses its secret key \\(s_i\\) to compute its share of the decryption as \\[ M_i = A^{s_i} \\bmod p \\] Each guardian \\(T_i\\) also publishes a Chaum-Pedersen proof of the correctness of \\(M_i\\) as follows. NIZK Proof by Guardian \ud835\udc47\ud835\udc56 of knowledge of \\(s_i \\in \\mathbb{Z}^r_p\\) for which both \\(M_i = A^{s_i} \\bmod p\\) and \\(K_i = g^{s_i} \\bmod p\\) Guardian \\(T_i\\) selects a random value \\(u_i\\) in \\(\\mathbb{Z}_q\\) and commits too the pair \\((a_i, b_i) = (g^{u_i} \\bmod p, A^{u_i} \\bmod p)\\) . The values \\((A, B), (a, b)\\) and \\(M\\) are hashed together with the extended base hash value \\(\\overline{Q}\\) t to form a challenge value \\(c_i = H(\\overline{Q}, (A, B), (a_i, b_i), M)\\) , and the guardian \\(T_i\\) responds with \\(v_i = (u_i + c_i s_i) \\bmod q\\) . Important An election verifier must then confirm for each (non-placeholder) option in each contest in the ballot coding ffile the following for each decrypting guardian \\(T_i\\) : (A) The given value \\(v_i\\) is in the set \\(\\mathbb{Z}_q^r\\) (B) The given values \\(a_i\\) and \\(b_i\\) are both in the set \\(\\mathbb{Z}_q^r\\) (C) The challenge value \\(c_i\\) satisfies \\(c_i = H(\\overline{Q}, (A, B), (a_i, b_i), M)\\) . (D) The equation \\(g^{v_i} \\bmod p = (a_i K_i^{c_i}) \\bmod p\\) is satisfied. (E) The equation \\(A^{v_i} \\bmod p = (b_i M_i^{c_i}) \\bmod p\\) is satisfied.","title":"Verifiable Decryption"},{"location":"spec/web/8_Verifiable_Decryption/#decryption-when-all-guardians-are-present","text":"If all guardians are present and have posted suitable proofs, the next step is to publish the value \\[ M = B / (\\prod_{i=1}^n M_i) \\bmod p. \\] This \\(M\\) has the property that \\(M = g_t \\bmod p\\) where \\(t\\) is the tally of the associated option. In general, computation of this tally value \\(t\\) is computationally intractable. However, in this application, \\(t\\) is relatively small - bounded by the number of votes cast. Election administrators can determine this tally value \\(t\\) from \\(M\\) by exhaustive search, by precomputing a table of all possible \\(M\\) values in the allowable range and then performing a single look-up, or by a combination in which some exponentiations are precomputed and a small search is used to find the value of \\(t\\) (e.g., a partial table consisting of \\(g^{100} \\bmod p, g^{200} \\bmod p, g^{300} \\bmod p\\) \u2026 is precomputed and the value \\(M\\) is repeatedly divided by \\(g\\) until a value is found that is in the partial table). The value \\(t\\) is published in the election record, and verifiers should check both that \\(M = g^t \\bmod p\\) and that \\(B = (M \\cdot \\prod^n_{i=1} M_i) \\bmod p\\) .","title":"Decryption when all guardians are present"},{"location":"spec/web/8_Verifiable_Decryption/#decryption-with-missing-guardians","text":"If one or more of the election guardians are not available for decryption, any \\(k\\) available guardians can use the information they have to reconstruct the partial decryptions for missing guardians as follows. If guardian \\(T_i\\) is missing during decryption, each of at least \\(k\\) available guardians \\(T_\\ell\\) should use its share \\(P_i(\\ell)\\) of the secret value \\(s_i\\) previously shared by \\(T_i\\) to compute a share of the missing partial decryption \\(M_i\\) in the same way that it used its own secret \\(s_\\ell\\) . Specifically, guardian \\(T_\\ell\\) publishes partial decryption share \\[ M_{i, \\ell} = A^{P_i(\\ell)} \\bmod p \\] Guardian \\(T_\\ell\\) also publishes a Chaum-Pedersen proof of the correctness of \\(M_{i, \\ell}\\) as follows. NIZK Proof by Guardian \\(T_\\ell\\) of knowledge of \\(s_{i, \\ell} \\in \\mathbb{Z}^r_p\\) for which both \\(M_{i, \\ell} = A^{s_{i, \\ell}} \\bmod p\\) and \\(g^{s_i} \\bmod p = \\prod^{k=1}_{j=0}K^{\\ell^j}_{i, j} \\bmod p\\) Guardian \\(T_\\ell\\) selects a random value \\(u_{i, \\ell}\\) in \\(\\mathbb{Z}_q\\) and commits to the pair \\((a_{i, \\ell}, b_{i, \\ell}) = (g^{u_{i, \\ell}} \\bmod p, A^{u_{i, \\ell}} \\bmod p)\\) . The values \\((A, B)\\) , \\((a_{i, \\ell}, b_{i, \\ell})\\) , and \\(M_{i, \\ell}\\) are hashed together with the extended base hash value \\(\\bar{Q}\\) to form a challenge value \\(c_{i, \\ell} = H(\\bar{Q}, (A, B), (a_{i, \\ell}, b_{i, \\ell}), M_{i, \\ell})\\) , and the guardian \\(T_\\ell\\) responds with \\(v_{i, \\ell} = (u_{i, \\ell} + c_{i, \\ell} P_i(\\ell)) \\bmod q\\) . It is important to note here that although the value \\(P_i(\\ell)\\) is known to both the missing guardian \\(T_i\\) and the guardian \\(T_\\ell\\) , it need not published or generally known. However, the value \\(g^{P_i(\\ell)} \\bmod p\\) can be computer form public values as \\[ g^{P_i(\\ell)} \\bmod p = \\prod_{j=0}^{k-1} K^{\\ell^j}_{i, j} \\bmod p. \\] Important An election verifier must confirm for each (non-placeholder) option in each contest in the ballot coding file the following for each missing guardian \\(T_i\\) and for each surrogate guardian \\(T_\\ell\\) . (A) The given value \\(v_{i, \\ell}\\) is in the set \\(\\mathbb{Z}_q\\) . (B) The given values \\(a_{i, \\ell}\\) and \\(b_{i, \\ell}\\) are both in the set \\(\\mathbb{Z}_q^r\\) . (C) The challenge value \\(c_{i, \\ell}\\) satisfies \\(c_{i, \\ell} = H(\\bar{Q}, (A, B), (a_{i, \\ell}, b_{i, \\ell}), M_{i, \\ell})\\) . (D) The equation \\(g^{v_{i, \\ell}} \\bmod p = (a_{i, \\ell} K_{i, \\ell}^{c_{i, \\ell}}) \\bmod p\\) is satisfied. (E) The equation \\(A^{v_{i, \\ell}} \\bmod p = (b_{i, \\ell} M_{i, \\ell}^{c_{i, \\ell}}) \\bmod p\\) is satisfied. The final step to reconstruct a missing partial decryption \\(M_i\\) is to compute Lagrange coefficients for a set of \\(k\\) available guardians \\(\\{ T_\\ell:\\ell \\in U \\}\\) with \\(|U| = k\\) as \\[ w_\\ell = \\frac{(\\prod_{j \\in (U - \\{\\ell\\})}j)}{(\\prod_{j \\in (U - \\{\\ell\\}))}(j - \\ell))} \\bmod q. \\] Important An election verifier should confirm that for each guardian \\(T_\\ell\\) serving to help compute a missing share of a tally, that its Lagrange coefficient \\(w_\\ell\\) is correctly computer by confirming the equation \\((\\prod_{j\\in(U = \\{\\ell\\})} j) \\bmod q = (w_\\ell (\\prod_{j \\in (U - \\{\\ell\\})} (j-\\ell))) \\bmod q\\) . An election verifier should then confirm the correcty missing tally share for each (non-placeholder) option in each contest in the ballot coding file for each missing guardian \\(T_i\\) as \\(M_i = \\prod_{\\ell \\in U} (M_{i, \\ell})^{w_\\ell} \\bmod p\\) . Info Note that the missing secret \\(s_i\\) could be computed directly as \\(s_i = \\sum_{\\ell \\in U}w_\\ell P_i(\\ell) \\bmod q\\) . However, it is preferable to not release the missing secret and instead only release the partial decryption that the missing secret would have produced. This prevents the missing secret \\(s_i\\) from being used for additional decryptions without the cooperation of at least \\(k\\) guardians. As an example, consider an election with five guardians and a threshold of three. If two guardians are missing at the time of decryption, the remaining three can perform any required decryption, the remaining three can perform any required decryptions by constructing missing partial descriptions as described in the text above. If, instead, they take the shortcut of simply reconstructing and then using the two missing secrets, then any of the three could, at a later time, use its own secret together with the two reconstructed secrets to perform additional decryptions without cooperation of any other guardian. The final step is to verify the tallies themselves. Important An election verifier should confirm the following equations for each (non-placeholder) option in each contest in the ballot coding file. (A) \\(B = (M (\\prod^n_{i=i} M_i)) \\bmod p\\) . (B) \\(M = g^t \\bmod p\\) . An election verifier should also confirm that the text labels listed in the election record match the corresponding text labels in the ballot coding file.","title":"Decryption with missing guardians"},{"location":"spec/web/8_Verifiable_Decryption/#decryption-of-spoiled-ballots","text":"Every ballot spoiled in an election is individually verifiably decrypted in exactly the same way that the aggregate ballot of tallies is decrypted. Election verifiers should confirm all such decryptions so that casual observers can simply view the decryptions and confirm that they match their expectations. Important An election verifier should confirm the correct decryption of each spoiled ballot using the same process that was used to confirm the election tallies. An election verifier should also confirm that for each decrypted spoiled ballot, the selections listed in text match the corresponding text in the ballot coding file.","title":"Decryption of spoiled ballots"},{"location":"spec/web/9_Election_Record/","text":"The Election Record The record of an election should be a full accounting of all of the election artifacts. Specifically, it should contain the following. Date and location of an election The ballot coding file The baseline parameters Primes \ud835\udc5d and \ud835\udc5e and integer \ud835\udc5f such that \ud835\udc5d=\ud835\udc5e\ud835\udc5f+1 and \ud835\udc5f is not a multiple of \ud835\udc5e A generator \ud835\udc54 of the order \ud835\udc5e multiplicative subgroup \u2124 * p The number \ud835\udc5b of election guardians The quorum threshold \ud835\udc58 of guardians required to complete verification The base hash value \ud835\udc44 computed from the above The commitments from each election guardian to each of their polynomial coefficients The proofs from each guardian of possession of each of the associated coefficients The election public key The extended base hash value \ud835\udc44 computed from the above Every encrypted ballot prepared in the election (whether cast or spoiled) All of the encrypted options on each ballot (including \u201cplaceholder\u201d options) The proofs that each such value is an encryption of either zero or one The selection limit for each contest The proof that the number of selections made matches the selection limit The device information for the device that encrypted the ballot The date and time of the ballot encryption The tracker code produced for the ballot The decryption of each spoiled ballot The selections made on the ballot The cleartext representation of the selections Partial decryptions by each guardian of each option Proofs of each partial decryption Shares of each missing partial decryption (if any) Proofs of shares of each missing partial decryption (if any) Lagrange coefficients used for replacement of any missing partial decryptions (if any) Tallies of each option in an election The encrypted tally of each option Full decryptions of each encrypted tally Cleartext representations of each tally Partial decryptions by each guardian of each tally Proofs of partial decryption of each tally Shares of each missing partial decryption (if any) Proofs of shares of each missing partial decryptio(if any) Lagrange coefficients used for replacement of any missing partial decryptions (if any) Ordered lists of the ballots encrypted by each device An election record should be digitally signed by election administrators together with the date of the signature. The entire election record and its digital signature should be published and made available for full download by any interested individuals. Tools should also be provided for easy look up of tracking codes by voters.","title":"Election Record"},{"location":"spec/web/9_Election_Record/#the-election-record","text":"The record of an election should be a full accounting of all of the election artifacts. Specifically, it should contain the following. Date and location of an election The ballot coding file The baseline parameters Primes \ud835\udc5d and \ud835\udc5e and integer \ud835\udc5f such that \ud835\udc5d=\ud835\udc5e\ud835\udc5f+1 and \ud835\udc5f is not a multiple of \ud835\udc5e A generator \ud835\udc54 of the order \ud835\udc5e multiplicative subgroup \u2124 * p The number \ud835\udc5b of election guardians The quorum threshold \ud835\udc58 of guardians required to complete verification The base hash value \ud835\udc44 computed from the above The commitments from each election guardian to each of their polynomial coefficients The proofs from each guardian of possession of each of the associated coefficients The election public key The extended base hash value \ud835\udc44 computed from the above Every encrypted ballot prepared in the election (whether cast or spoiled) All of the encrypted options on each ballot (including \u201cplaceholder\u201d options) The proofs that each such value is an encryption of either zero or one The selection limit for each contest The proof that the number of selections made matches the selection limit The device information for the device that encrypted the ballot The date and time of the ballot encryption The tracker code produced for the ballot The decryption of each spoiled ballot The selections made on the ballot The cleartext representation of the selections Partial decryptions by each guardian of each option Proofs of each partial decryption Shares of each missing partial decryption (if any) Proofs of shares of each missing partial decryption (if any) Lagrange coefficients used for replacement of any missing partial decryptions (if any) Tallies of each option in an election The encrypted tally of each option Full decryptions of each encrypted tally Cleartext representations of each tally Partial decryptions by each guardian of each tally Proofs of partial decryption of each tally Shares of each missing partial decryption (if any) Proofs of shares of each missing partial decryptio(if any) Lagrange coefficients used for replacement of any missing partial decryptions (if any) Ordered lists of the ballots encrypted by each device An election record should be digitally signed by election administrators together with the date of the signature. The entire election record and its digital signature should be published and made available for full download by any interested individuals. Tools should also be provided for easy look up of tracking codes by voters.","title":"The Election Record"},{"location":"use_cases/Audit/","text":"Audit Work in Progress This is a work in progress. Feel free to contribute.","title":"Audit"},{"location":"use_cases/Audit/#audit","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Audit"},{"location":"use_cases/Electronic_Delivery/","text":"Electronic Delivery Work in Progress This is a work in progress. Feel free to contribute.","title":"Electronic Delivery"},{"location":"use_cases/Electronic_Delivery/#electronic-delivery","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Electronic Delivery"},{"location":"use_cases/Mail_In/","text":"Mail In Work in Progress This is a work in progress. Feel free to contribute.","title":"Mail In"},{"location":"use_cases/Mail_In/#mail-in","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Mail In"},{"location":"use_cases/Precinct_Scan/","text":"Precinct Scan Work in Progress This is a work in progress. Feel free to contribute. Overview By design, the ElectionGuard SDK can be used to enable end-to-end verifiability (e2e-v) in a variety of use cases. This article discusses the \"default\" use case of ElectionGuard: an end-to-end verifiable election that uses precinct scanners where ballots are inserted (and approved) by voters directly 1 . This document aims to provide a \" vertical slice \" of the considerations and practices necessary to add end-to-end verifiability to an existing precinct scanner. We necessarily make assumptions about the compute and storage capabilities of the scanner itself, and the modifications necessary to implement end-to-end verifiability . In so doing, it illustrates the interlocking system of security and encryption that comprises an e2e-v system . Info ElectionGuard relies on slight adaptations of existing voting processes to accommodate different aspects of end-to-end verifiability . For example, many voting jurisdictions already have a procedure called ballot spoiling to handle mistakes voters make when they fill out ballots. A voter may inadvertently fill out a contest incorrectly by selecting more candidates than allowed. When the voter then proceeds to scan the ballot, the scanner stops the ballot and alerts the voter of the overvote ; the voter then has the opportunity, as allowed within the voting regulations and practices of the voting district, to start over with a new ballot; the ballot with the mistake is then spoiled and stored separately to ensure it is not included in the tabulation. ElectionGuard uses this spoil process to enable a voter to test the integrity of the system capturing their vote. Effectively, the voter acts as if they are going to vote, submitting their ballot into the scanner and enabling it to process and interpret the ballot. After the encryption of the ballot has occurred, and the verification code has been generated, the voter can decide NOT to cast this ballot via some kind of option on the summary screen presented by the scanner. End-to-end verifiability mandates that these challenged ballots , unlike cast ballots , be published separately from the tally, and in addition that they be decrypted and published in their decrypted state. When voters use their verification code to look up the provenance of these challenged ballots after the election record have been published, they will be able to see both that the ballot they challenged was NOT included in the tally, and also what its contents would have been if it were. When the contents of a challenged ballot are revealed to the voter and the selections match, their confidence about the provenance of their cast ballot is ideally bolstered. If the contents do not match their expectation, they should be given the means to flag this situation to election administrators to investigate. Thus, challenge ballots serve the dual role of affording voters the opportunity to more meaningfully evaluate the disposition of their voting preferences while also providing a security check on the voting system itself. Because the system has to be prepared for ANY voter to challenge a ballot, and because that challenge occurs AFTER the ElectionGuard encryption has occurred, the scanner has already committed its choice to ElectionGuard. And since the scanner can only encrypt ballots (only the tally process overseen by a quorum of election guardians has the \"power\" to decrypt anything ), the system is forced to act in good faith (if a small and random minority of voters can be relied upon to exercise challenges). This document illustrates these e2e-v concepts in the context of setting up and running an election. It begins with a general discussion of the precinct scan user experience and technical assumptions of scanner capabilities, and then runs an election, outlining where ElectionGuard needs to be integrated and ideally providing any wider security and integrity context for any process alterations that may obtain relative to current general election practice. Current Precinct Scan Voter Experience A typical voter flow for a precinct scan system is illustrated below. After a voter has acquired their ballot, they fill it out by hand or using a ballot marking device. When they finish they proceed to the scanner and insert the completed ballot. The scanner scans and interprets the ballot and generates a cast vote record , an electronic representation of the voter's selections. If all contests in a ballot are filled out properly and interpreted as such by the scanner, the ballot is accepted and the voter is free to leave the voting booth. If the scanner interprets the voter has voted for more options than the ballot contests allow (called an overvote ), the scanner stops the ballot from being deposited into the ballot box and prompts the voter whether they would like to have the ballot returned to fix the discrepancy. If the voter agrees, a poll worker is alerted and the ballot remediated by whatever process obtains, which could involve issuance of a new ballot and \"spoiling\" of the overvoted ballot. The scanner can also determine whether the voter didn't fill out all the contests available (called an undervote ). The scanner can be programmed to follow the same process as an overvote (returning the ballot for remediation), but election administrators often assume the undervote is intentional by the voter. Adapting Precinct Scan for End-to-end Verifiability (E2E-V) Voter Experience As outlined in the Verifiable Election page of the ElectionGuard SDK 2 , for end-to-end verifiability to apply, the precinct scanner itself must provide the following capabilities for each voter: immediately upon scanning the ballot, create an encrypted version of the ballot using the public key generated by the election guardians (see Key Ceremony) present the verification code generated by the encryption to the voter (ideally in paper format) present the means for the voter to cast or challenge (spoil) the ballot Technical Requirements For end-to-end verifiability, the scanner has to implement the user experience described above as well as generate and finalize an encrypted ballot reflecting the voter's selections. ElectionGuard assumes all other e2e-v functions such as key and tally ceremonies are performed independently of the scanner on modern laptop or desktop computers or secure cloud environments. Technical Implementation Overview and Operational Assumptions Precinct scanners, unlike other components of voting systems, are assumed to follow the economics and performance characteristics of embedded devices rather than consumer off-the-shelf (COTS) devices such as laptops. ElectionGuard assumes these devices operate in storage-limited environments more akin to operating systems such as Raspberry Pi than Windows 10. Information transfer (if not base storage) is assumed to occur via USB drives with capacities designed for space-efficient data constructs, not 4096-bit encryptions. To support operation in these environments, ElectionGuard enables an encryption-only library built in C++ from which it can target different standalone package deployments that generate encrypted ballots using a separately-provided public election key. Because encrypted ballots in modern elections can each occupy up to 1MB or more of device storage, ElectionGuard also specifies a dehydration \"process\" that allows a more space-efficient format for local storage and transmission post-election. Prior to initiating the tally and publishing process, these ballots are transferred to an external system and reconsitituted (and validated) by re-executing the encryption process using the dehydrated data as inputs. (See the discussions around ballot construction, chaining, etc., below to understand how dehydration should not affect system integrity or end-to-end verifiability.) General Election Setup Elections can be considered to have three core \"states\": the election itself, where voters cast their ballots, but also election setup and post-election data collection and tally publishing. ElectionGuard necessarily manifests in each state. Election setup generally consists of preparing the voting machines for the current election contests, running any pre-production testing, and final configuration for election readiness. For ElectionGuard, the public election key generated by the election guardians is deployed to the scanner at this time and, if necessary, the ElectionGuard executable (the scanner is assumed to be entirely offline and code and election-related data is transferred via USB storage devices). Poll workers should also be prompted to manually enter an election launch code (see below) generated uniquely for the current election at election instantiation. In modern US elections, voters often vote multiple contests, determined by the type of election they're voting in and where they live. Because of the diversity of contests that different voters are eligible to vote in [even within a single county or precinct (imagine school districts, utility districts, city councillors, etc.)], a single precinct scanner may need to recognize and interpret tens or even hundreds of different ballot styles in a single election. Ballot manifest Consider a ballot manifest the master list of all the contests voters could face in a single election. ElectionGuard assumes and validates the ballot manifest for a variety of criteria . ElectionGuard uses manifests to properly interpret ballots generally, but for records created by precinct scanners the manifest provides the means to reconstitute the encrypted ballots from the dehydrated records created. Strictly speaking, the ballot manifest isn't necessary for ElectionGuard until the tally process evaluates the encrypted ballots generated during the election, but the precinct scanner needs to encode ballots and votes properly for their downstream construction, and that is dependent on the unique ballot styles presented to voters, which themselves need to follow proper convention as well. Public encryption key One of the core innovations of ElectionGuard is the use of multiple election guardians to administer the creation of the election record. Guardians are intended to be independent, trustworthy individuals. They don't need to have technical skills, but they do need to physically perform tasks collectively with the other guardians at the beginning and end of elections. As part of the election setup process, or any time prior, the guardians meet to create the public key that will be used by the precinct scanner to encrypt voter ballots. The Logic and Accuracy Testing Scanner Final Production Setup Launch Code Scanner Election Operation Ballot Encryption Generation of Verification Code Ballot Chaining Ballot Dehydration Dehydrated ballot structure A dehydrated ballot must provide the following data to be properly rehydrated and preserve end-to-end verifiability. Label Type Description Notes ballot_object_id string Unique ID to identify each ballot in an election session_id string Unique ID to enable the correct sorting of the election ballot chain when rehydrated needs to be resilient across device restarts and other service interruptions launch_code integer 10-digit ID generated at election initiation by rolling of 10-sided dice used to protect against attacks to insert votes outside of election context. See insert reference here ballot_style_id string Uniquely identifies the set of contests and responses a voter encounters with their ballot Used as part of the rehydration and tally processes to ensure the ballot is correctly interpreted and reconstituted ballot_finalization_indicator flag Indicates whether ballot is CAST or CHALLENGED applied by scanner based on determination by voter ballot_selections array Set of responses (and, as applicable, non-responses) of voter to ballot style reflective of non-selections; critical for rehydration and re-establishment of ballot encryption artifacts ballot_extra_data array Additional data applied at contest level to capture non-selection data Principally envisioned for capturing ballot selection metadata for write-ins; each entry needs to identify contest and selection as well as extra data string ballot_nonce ? The nonce used as input to the encryption of the ballot selections See spec on Ballot Encryption previous_tracker_hash ? As discussed in ballot chaining the previous_tracker_hash is an input to the current ballot encryption See spec on Ballot Encryption verification_code_hash ? Hashed version of verification code generated by ballot encryption process Ballot Finalization Cast ballots Challenge ballots As distinct from scanners used solely for central tabulation, which occurs with mail-in voting or any tabulation / aggregation scenario where voters are not present when the cast vote record is created \u21a9 ElectionGuard Verifiable Election [https://www.electionguard.vote/guide/Verifiable_Election/] \u21a9","title":"Precinct Scan"},{"location":"use_cases/Precinct_Scan/#precinct-scan","text":"Work in Progress This is a work in progress. Feel free to contribute.","title":"Precinct Scan"},{"location":"use_cases/Precinct_Scan/#overview","text":"By design, the ElectionGuard SDK can be used to enable end-to-end verifiability (e2e-v) in a variety of use cases. This article discusses the \"default\" use case of ElectionGuard: an end-to-end verifiable election that uses precinct scanners where ballots are inserted (and approved) by voters directly 1 . This document aims to provide a \" vertical slice \" of the considerations and practices necessary to add end-to-end verifiability to an existing precinct scanner. We necessarily make assumptions about the compute and storage capabilities of the scanner itself, and the modifications necessary to implement end-to-end verifiability . In so doing, it illustrates the interlocking system of security and encryption that comprises an e2e-v system . Info ElectionGuard relies on slight adaptations of existing voting processes to accommodate different aspects of end-to-end verifiability . For example, many voting jurisdictions already have a procedure called ballot spoiling to handle mistakes voters make when they fill out ballots. A voter may inadvertently fill out a contest incorrectly by selecting more candidates than allowed. When the voter then proceeds to scan the ballot, the scanner stops the ballot and alerts the voter of the overvote ; the voter then has the opportunity, as allowed within the voting regulations and practices of the voting district, to start over with a new ballot; the ballot with the mistake is then spoiled and stored separately to ensure it is not included in the tabulation. ElectionGuard uses this spoil process to enable a voter to test the integrity of the system capturing their vote. Effectively, the voter acts as if they are going to vote, submitting their ballot into the scanner and enabling it to process and interpret the ballot. After the encryption of the ballot has occurred, and the verification code has been generated, the voter can decide NOT to cast this ballot via some kind of option on the summary screen presented by the scanner. End-to-end verifiability mandates that these challenged ballots , unlike cast ballots , be published separately from the tally, and in addition that they be decrypted and published in their decrypted state. When voters use their verification code to look up the provenance of these challenged ballots after the election record have been published, they will be able to see both that the ballot they challenged was NOT included in the tally, and also what its contents would have been if it were. When the contents of a challenged ballot are revealed to the voter and the selections match, their confidence about the provenance of their cast ballot is ideally bolstered. If the contents do not match their expectation, they should be given the means to flag this situation to election administrators to investigate. Thus, challenge ballots serve the dual role of affording voters the opportunity to more meaningfully evaluate the disposition of their voting preferences while also providing a security check on the voting system itself. Because the system has to be prepared for ANY voter to challenge a ballot, and because that challenge occurs AFTER the ElectionGuard encryption has occurred, the scanner has already committed its choice to ElectionGuard. And since the scanner can only encrypt ballots (only the tally process overseen by a quorum of election guardians has the \"power\" to decrypt anything ), the system is forced to act in good faith (if a small and random minority of voters can be relied upon to exercise challenges). This document illustrates these e2e-v concepts in the context of setting up and running an election. It begins with a general discussion of the precinct scan user experience and technical assumptions of scanner capabilities, and then runs an election, outlining where ElectionGuard needs to be integrated and ideally providing any wider security and integrity context for any process alterations that may obtain relative to current general election practice.","title":"Overview"},{"location":"use_cases/Precinct_Scan/#current-precinct-scan-voter-experience","text":"A typical voter flow for a precinct scan system is illustrated below. After a voter has acquired their ballot, they fill it out by hand or using a ballot marking device. When they finish they proceed to the scanner and insert the completed ballot. The scanner scans and interprets the ballot and generates a cast vote record , an electronic representation of the voter's selections. If all contests in a ballot are filled out properly and interpreted as such by the scanner, the ballot is accepted and the voter is free to leave the voting booth. If the scanner interprets the voter has voted for more options than the ballot contests allow (called an overvote ), the scanner stops the ballot from being deposited into the ballot box and prompts the voter whether they would like to have the ballot returned to fix the discrepancy. If the voter agrees, a poll worker is alerted and the ballot remediated by whatever process obtains, which could involve issuance of a new ballot and \"spoiling\" of the overvoted ballot. The scanner can also determine whether the voter didn't fill out all the contests available (called an undervote ). The scanner can be programmed to follow the same process as an overvote (returning the ballot for remediation), but election administrators often assume the undervote is intentional by the voter.","title":"Current Precinct Scan Voter Experience"},{"location":"use_cases/Precinct_Scan/#adapting-precinct-scan-for-end-to-end-verifiability-e2e-v","text":"","title":"Adapting Precinct Scan for End-to-end Verifiability (E2E-V)"},{"location":"use_cases/Precinct_Scan/#voter-experience","text":"As outlined in the Verifiable Election page of the ElectionGuard SDK 2 , for end-to-end verifiability to apply, the precinct scanner itself must provide the following capabilities for each voter: immediately upon scanning the ballot, create an encrypted version of the ballot using the public key generated by the election guardians (see Key Ceremony) present the verification code generated by the encryption to the voter (ideally in paper format) present the means for the voter to cast or challenge (spoil) the ballot","title":"Voter Experience"},{"location":"use_cases/Precinct_Scan/#technical-requirements","text":"For end-to-end verifiability, the scanner has to implement the user experience described above as well as generate and finalize an encrypted ballot reflecting the voter's selections. ElectionGuard assumes all other e2e-v functions such as key and tally ceremonies are performed independently of the scanner on modern laptop or desktop computers or secure cloud environments.","title":"Technical Requirements"},{"location":"use_cases/Precinct_Scan/#technical-implementation","text":"","title":"Technical Implementation"},{"location":"use_cases/Precinct_Scan/#overview-and-operational-assumptions","text":"Precinct scanners, unlike other components of voting systems, are assumed to follow the economics and performance characteristics of embedded devices rather than consumer off-the-shelf (COTS) devices such as laptops. ElectionGuard assumes these devices operate in storage-limited environments more akin to operating systems such as Raspberry Pi than Windows 10. Information transfer (if not base storage) is assumed to occur via USB drives with capacities designed for space-efficient data constructs, not 4096-bit encryptions. To support operation in these environments, ElectionGuard enables an encryption-only library built in C++ from which it can target different standalone package deployments that generate encrypted ballots using a separately-provided public election key. Because encrypted ballots in modern elections can each occupy up to 1MB or more of device storage, ElectionGuard also specifies a dehydration \"process\" that allows a more space-efficient format for local storage and transmission post-election. Prior to initiating the tally and publishing process, these ballots are transferred to an external system and reconsitituted (and validated) by re-executing the encryption process using the dehydrated data as inputs. (See the discussions around ballot construction, chaining, etc., below to understand how dehydration should not affect system integrity or end-to-end verifiability.)","title":"Overview and Operational Assumptions"},{"location":"use_cases/Precinct_Scan/#general-election-setup","text":"Elections can be considered to have three core \"states\": the election itself, where voters cast their ballots, but also election setup and post-election data collection and tally publishing. ElectionGuard necessarily manifests in each state. Election setup generally consists of preparing the voting machines for the current election contests, running any pre-production testing, and final configuration for election readiness. For ElectionGuard, the public election key generated by the election guardians is deployed to the scanner at this time and, if necessary, the ElectionGuard executable (the scanner is assumed to be entirely offline and code and election-related data is transferred via USB storage devices). Poll workers should also be prompted to manually enter an election launch code (see below) generated uniquely for the current election at election instantiation. In modern US elections, voters often vote multiple contests, determined by the type of election they're voting in and where they live. Because of the diversity of contests that different voters are eligible to vote in [even within a single county or precinct (imagine school districts, utility districts, city councillors, etc.)], a single precinct scanner may need to recognize and interpret tens or even hundreds of different ballot styles in a single election.","title":"General Election Setup"},{"location":"use_cases/Precinct_Scan/#ballot-manifest","text":"Consider a ballot manifest the master list of all the contests voters could face in a single election. ElectionGuard assumes and validates the ballot manifest for a variety of criteria . ElectionGuard uses manifests to properly interpret ballots generally, but for records created by precinct scanners the manifest provides the means to reconstitute the encrypted ballots from the dehydrated records created. Strictly speaking, the ballot manifest isn't necessary for ElectionGuard until the tally process evaluates the encrypted ballots generated during the election, but the precinct scanner needs to encode ballots and votes properly for their downstream construction, and that is dependent on the unique ballot styles presented to voters, which themselves need to follow proper convention as well.","title":"Ballot manifest"},{"location":"use_cases/Precinct_Scan/#public-encryption-key","text":"One of the core innovations of ElectionGuard is the use of multiple election guardians to administer the creation of the election record. Guardians are intended to be independent, trustworthy individuals. They don't need to have technical skills, but they do need to physically perform tasks collectively with the other guardians at the beginning and end of elections. As part of the election setup process, or any time prior, the guardians meet to create the public key that will be used by the precinct scanner to encrypt voter ballots. The","title":"Public encryption key"},{"location":"use_cases/Precinct_Scan/#logic-and-accuracy-testing","text":"","title":"Logic and Accuracy Testing"},{"location":"use_cases/Precinct_Scan/#scanner-final-production-setup","text":"","title":"Scanner Final Production Setup"},{"location":"use_cases/Precinct_Scan/#launch-code","text":"","title":"Launch Code"},{"location":"use_cases/Precinct_Scan/#scanner-election-operation","text":"","title":"Scanner Election Operation"},{"location":"use_cases/Precinct_Scan/#ballot-encryption","text":"","title":"Ballot Encryption"},{"location":"use_cases/Precinct_Scan/#generation-of-verification-code","text":"","title":"Generation of Verification Code"},{"location":"use_cases/Precinct_Scan/#ballot-chaining","text":"","title":"Ballot Chaining"},{"location":"use_cases/Precinct_Scan/#ballot-dehydration","text":"","title":"Ballot Dehydration"},{"location":"use_cases/Precinct_Scan/#dehydrated-ballot-structure","text":"A dehydrated ballot must provide the following data to be properly rehydrated and preserve end-to-end verifiability. Label Type Description Notes ballot_object_id string Unique ID to identify each ballot in an election session_id string Unique ID to enable the correct sorting of the election ballot chain when rehydrated needs to be resilient across device restarts and other service interruptions launch_code integer 10-digit ID generated at election initiation by rolling of 10-sided dice used to protect against attacks to insert votes outside of election context. See insert reference here ballot_style_id string Uniquely identifies the set of contests and responses a voter encounters with their ballot Used as part of the rehydration and tally processes to ensure the ballot is correctly interpreted and reconstituted ballot_finalization_indicator flag Indicates whether ballot is CAST or CHALLENGED applied by scanner based on determination by voter ballot_selections array Set of responses (and, as applicable, non-responses) of voter to ballot style reflective of non-selections; critical for rehydration and re-establishment of ballot encryption artifacts ballot_extra_data array Additional data applied at contest level to capture non-selection data Principally envisioned for capturing ballot selection metadata for write-ins; each entry needs to identify contest and selection as well as extra data string ballot_nonce ? The nonce used as input to the encryption of the ballot selections See spec on Ballot Encryption previous_tracker_hash ? As discussed in ballot chaining the previous_tracker_hash is an input to the current ballot encryption See spec on Ballot Encryption verification_code_hash ? Hashed version of verification code generated by ballot encryption process","title":"Dehydrated ballot structure"},{"location":"use_cases/Precinct_Scan/#ballot-finalization","text":"","title":"Ballot Finalization"},{"location":"use_cases/Precinct_Scan/#cast-ballots","text":"","title":"Cast ballots"},{"location":"use_cases/Precinct_Scan/#challenge-ballots","text":"As distinct from scanners used solely for central tabulation, which occurs with mail-in voting or any tabulation / aggregation scenario where voters are not present when the cast vote record is created \u21a9 ElectionGuard Verifiable Election [https://www.electionguard.vote/guide/Verifiable_Election/] \u21a9","title":"Challenge ballots"},{"location":"use_cases/Rescans_and_Recounts/","text":"Rescans and Recounts Warning This is a documented but not currently implemented capability. See the Roadmap for implementation details and status. Overview In the course of an election with paper ballots, occasions may arise when all or some of the ballots in an election may need to be rescanned without being in the presence of the voter. For example, if a precinct scanner fails on election day, some municipalities may require a new scanner to be activated and the ballots scanned through the failed scanner to be re-scanned in the new scanner; those rescans would likely not be conducted in the presence of the affected voters, and the verification codes generated from the subsequent scans would not be available to them. Similarly, some elections require multiple recounts, including hand tallies, to resolve challenges or recounts triggered by narrow margins of victory. Ballots may be included or excluded from subsequent recounts dependent on the interpretation of the scans or their inclusion or exclusion in the the subsequent tallies. Info Depending on how the ballot is encrypted (such as whether ballot-chaining is being used), the verification codes generated in the rescan would not be the same. The \"default\" implementation of ElectionGuard, which uses the unique ID of the device performing the encryption as part of the encryption itself, would generate a different verification code if the same ballot is scanned on a different device. If ballot-chaining or any time-based component were included in the encryption, even subsequent scans of the same ballot on the same scanner would generate a different verification code. When a voter checks whether their ballot was included in the ElectionGuard published artifacts, the information should reflect whether the ballot was included (and even more importantly not included) in any subsequent tallies published by the election administration. This must be accomplished without undermining the core integrity and privacy concerns of the verification processes. Warning The proposed process mandates a unique ballot identifier be generated by the host voting system (not ElectionGuard), printed on the ballot, and captured as part of the ElectionGuard metadata. Proposed Approach To maintain the security and integrity of the original election record, rescans and recounts are guardian-based processes. This requirement presents potentially significant additional compute both for the local guardian device / hardware security module and any cloud-based approach to scale the cross-tally mapping. Encrypting a Unique Ballot ID Since a rescan or recount can occur on any independent device, the information for mapping must be present on and derived from the paper ballot itself. Specifically, in addition to all the contests and candidates, there must be an ID unique to the election printed on the ballot. When scanned by the scanner, that ID is included in the encrypted ballot metadata encrypted by the auxiliary guardian RSA key separate from the El Gamal encryption 1 used for the ballot contents. Alert Municipalities that do not allow the printing of unique identifiers on their paper ballots cannot use ElectionGuard for the rescan scenario, since there is no way to perform any mapping across independent tallies Diffing an Election Invoking a Rescan or Recount After the base ElectionGuard verifiable tally has been generated (and, optionally, published) a rescan or recount can be performed. Optimizing the Compute Because the primary joint public key is an ElGamal key, it is optimized for the ones and zeroes that constitute the contents of a ballot, not the generic string values necessary to support arbitrary IDs. \u21a9","title":"Rescans and Recounts"},{"location":"use_cases/Rescans_and_Recounts/#rescans-and-recounts","text":"Warning This is a documented but not currently implemented capability. See the Roadmap for implementation details and status.","title":"Rescans and Recounts"},{"location":"use_cases/Rescans_and_Recounts/#overview","text":"In the course of an election with paper ballots, occasions may arise when all or some of the ballots in an election may need to be rescanned without being in the presence of the voter. For example, if a precinct scanner fails on election day, some municipalities may require a new scanner to be activated and the ballots scanned through the failed scanner to be re-scanned in the new scanner; those rescans would likely not be conducted in the presence of the affected voters, and the verification codes generated from the subsequent scans would not be available to them. Similarly, some elections require multiple recounts, including hand tallies, to resolve challenges or recounts triggered by narrow margins of victory. Ballots may be included or excluded from subsequent recounts dependent on the interpretation of the scans or their inclusion or exclusion in the the subsequent tallies. Info Depending on how the ballot is encrypted (such as whether ballot-chaining is being used), the verification codes generated in the rescan would not be the same. The \"default\" implementation of ElectionGuard, which uses the unique ID of the device performing the encryption as part of the encryption itself, would generate a different verification code if the same ballot is scanned on a different device. If ballot-chaining or any time-based component were included in the encryption, even subsequent scans of the same ballot on the same scanner would generate a different verification code. When a voter checks whether their ballot was included in the ElectionGuard published artifacts, the information should reflect whether the ballot was included (and even more importantly not included) in any subsequent tallies published by the election administration. This must be accomplished without undermining the core integrity and privacy concerns of the verification processes. Warning The proposed process mandates a unique ballot identifier be generated by the host voting system (not ElectionGuard), printed on the ballot, and captured as part of the ElectionGuard metadata.","title":"Overview"},{"location":"use_cases/Rescans_and_Recounts/#proposed-approach","text":"To maintain the security and integrity of the original election record, rescans and recounts are guardian-based processes. This requirement presents potentially significant additional compute both for the local guardian device / hardware security module and any cloud-based approach to scale the cross-tally mapping.","title":"Proposed Approach"},{"location":"use_cases/Rescans_and_Recounts/#encrypting-a-unique-ballot-id","text":"Since a rescan or recount can occur on any independent device, the information for mapping must be present on and derived from the paper ballot itself. Specifically, in addition to all the contests and candidates, there must be an ID unique to the election printed on the ballot. When scanned by the scanner, that ID is included in the encrypted ballot metadata encrypted by the auxiliary guardian RSA key separate from the El Gamal encryption 1 used for the ballot contents. Alert Municipalities that do not allow the printing of unique identifiers on their paper ballots cannot use ElectionGuard for the rescan scenario, since there is no way to perform any mapping across independent tallies","title":"Encrypting a Unique Ballot ID"},{"location":"use_cases/Rescans_and_Recounts/#diffing-an-election","text":"","title":"Diffing an Election"},{"location":"use_cases/Rescans_and_Recounts/#invoking-a-rescan-or-recount","text":"After the base ElectionGuard verifiable tally has been generated (and, optionally, published) a rescan or recount can be performed.","title":"Invoking a Rescan or Recount"},{"location":"use_cases/Rescans_and_Recounts/#optimizing-the-compute","text":"Because the primary joint public key is an ElGamal key, it is optimized for the ones and zeroes that constitute the contents of a ballot, not the generic string values necessary to support arbitrary IDs. \u21a9","title":"Optimizing the Compute"}]}